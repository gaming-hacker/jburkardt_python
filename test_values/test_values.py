#! /usr/bin/env python3
#
def abram0_values ( n_data ):

#*****************************************************************************80
#
## abram0_values returns some values of the Abramowitz0 function.
#
#  Discussion:
#
#    The function is defined by:
#
#      abram0(X) = integral ( 0 <= T < infinity ) exp ( -T * T - X / T ) dT
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 November 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
     0.87377726306985360531E+00, \
     0.84721859650456925922E+00, \
     0.77288934483988301615E+00, \
     0.59684345853450151603E+00, \
     0.29871735283675888392E+00, \
     0.15004596450516388138E+00, \
     0.11114662419157955096E+00, \
     0.83909567153151897766E-01, \
     0.56552321717943417515E-01, \
     0.49876496603033790206E-01, \
     0.44100889219762791328E-01, \
     0.19738535180254062496E-01, \
     0.86193088287161479900E-02, \
     0.40224788162540127227E-02, \
     0.19718658458164884826E-02, \
     0.10045868340133538505E-02, \
     0.15726917263304498649E-03, \
     0.10352666912350263437E-04, \
     0.91229759190956745069E-06, \
     0.25628287737952698742E-09 ) )

  x_vec = np.array ( ( \
     0.0019531250E+00, \
     0.0078125000E+00, \
     0.0312500000E+00, \
     0.1250000000E+00, \
     0.5000000000E+00, \
     1.0000000000E+00, \
     1.2500000000E+00, \
     1.5000000000E+00, \
     1.8750000000E+00, \
     2.0000000000E+00, \
     2.1250000000E+00, \
     3.0000000000E+00, \
     4.0000000000E+00, \
     5.0000000000E+00, \
     6.0000000000E+00, \
     7.0000000000E+00, \
     10.0000000000E+00, \
     15.0000000000E+00, \
     20.0000000000E+00, \
     40.0000000000E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def abram0_values_test ( ):

#*****************************************************************************80
#
## abram0_values_test() tests abram0_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 April 2007
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'abram0_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  abram0_values stores values of' )
  print ( '  the Abramowitz function of order 0.' )
  print ( '' )
  print ( '      X           FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    [ n_data, x, fx ] = abram0_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'abram0_values_test:' )
  print ( '  Normal end of execution.' )
  return

def abram1_values ( n_data ):

#*****************************************************************************80
#
## abram1_values returns some values of the Abramowitz1 function.
#
#  Discussion:
#
#    The function is defined by:
#
#      abram1(x) = integral ( 0 <= t < infinity ) t * exp ( -t^2 - x / t ) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 September 2004
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#      special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
     0.49828219848799921792E+00, \
     0.49324391773047288556E+00, \
     0.47431612784691234649E+00, \
     0.41095983258760410149E+00, \
     0.25317617388227035867E+00, \
     0.14656338138597777543E+00, \
     0.11421547056018366587E+00, \
     0.90026307383483764795E-01, \
     0.64088214170742303375E-01, \
     0.57446614314166191085E-01, \
     0.51581624564800730959E-01, \
     0.25263719555776416016E-01, \
     0.11930803330196594536E-01, \
     0.59270542280915272465E-02, \
     0.30609215358017829567E-02, \
     0.16307382136979552833E-02, \
     0.28371851916959455295E-03, \
     0.21122150121323238154E-04, \
     0.20344578892601627337E-05, \
     0.71116517236209642290E-09 ) )

  x_vec = np.array ( ( \
     0.0019531250E+00, \
     0.0078125000E+00, \
     0.0312500000E+00, \
     0.1250000000E+00, \
     0.5000000000E+00, \
     1.0000000000E+00, \
     1.2500000000E+00, \
     1.5000000000E+00, \
     1.8750000000E+00, \
     2.0000000000E+00, \
     2.1250000000E+00, \
     3.0000000000E+00, \
     4.0000000000E+00, \
     5.0000000000E+00, \
     6.0000000000E+00, \
     7.0000000000E+00, \
     10.0000000000E+00, \
     15.0000000000E+00, \
     20.0000000000E+00, \
     40.0000000000E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def abram1_values_test ( ):

#*****************************************************************************80
#
## abram1_values_test() tests abram1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 April 2007
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'abram1_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  abram1_values stores values of' )
  print ( '  the Abramowitz function of order 1.' )
  print ( '' )
  print ( '      X           FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = abram1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'abram1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def abram2_values ( n_data ):

#*****************************************************************************80
#
## abram2_values returns some values of the Abramowitz2 function.
#
#  Discussion:
#
#    The function is defined by:
#
#      abram2(x) = Integral ( 0 <= t < infinity ) t^2 * exp( -t^2 - x / t ) dt
# 
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 November 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
     0.44213858162107913430E+00, \
     0.43923379545684026308E+00, \
     0.42789857297092602234E+00, \
     0.38652825661854504406E+00, \
     0.26538204413231368110E+00, \
     0.16848734838334595000E+00, \
     0.13609200032513227112E+00, \
     0.11070330027727917352E+00, \
     0.82126019995530382267E-01, \
     0.74538781999594581763E-01, \
     0.67732034377612811390E-01, \
     0.35641808698811851022E-01, \
     0.17956589956618269083E-01, \
     0.94058737143575370625E-02, \
     0.50809356204299213556E-02, \
     0.28149565414209719359E-02, \
     0.53808696422559303431E-03, \
     0.44821756380146327259E-04, \
     0.46890678427324100410E-05, \
     0.20161544850996420504E-08 ) )

  x_vec = np.array ( ( \
     0.0019531250E+00, \
     0.0078125000E+00, \
     0.0312500000E+00, \
     0.1250000000E+00, \
     0.5000000000E+00, \
     1.0000000000E+00, \
     1.2500000000E+00, \
     1.5000000000E+00, \
     1.8750000000E+00, \
     2.0000000000E+00, \
     2.1250000000E+00, \
     3.0000000000E+00, \
     4.0000000000E+00, \
     5.0000000000E+00, \
     6.0000000000E+00, \
     7.0000000000E+00, \
     10.0000000000E+00, \
     15.0000000000E+00, \
     20.0000000000E+00, \
     40.0000000000E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def abram2_values_test ( ):

#*****************************************************************************80
#
## abram2_values_test() tests abram2_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 April 2007
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'abram2_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  abram2_values stores values of' )
  print ( '  the Abramowitz function of order 2.' )
  print ( '' )
  print ( '      X           FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = abram2_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'abram2_values_test:' )
  print ( '  Normal end of execution.' )
  return

def agm_values ( n_data ):

#*****************************************************************************80
#
## agm_values returns some values of the AGM.
#
#  Discussion:
#
#    The AGM is defined for nonnegative A and B.
#
#    The AGM of numbers A and B is defined by setting
#
#      A(0) = A,
#      B(0) = B
#
#      A(N+1) = ( A(N) + B(N) ) / 2
#      B(N+1) = sqrt ( A(N) * B(N) )
#
#    The two sequences both converge to AGM(A,B).
#
#    In Mathematica, the AGM can be evaluated by
#
#      ArithmeticGeometricMean [ a, b ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 November 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, B, the argument ofs the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 14

  a_vec = np.array ( ( \
     22.0, \
     83.0, \
     42.0, \
     26.0, \
      4.0, \
      6.0, \
     40.0, \
     80.0, \
     90.0, \
      9.0, \
     53.0, \
      1.0, \
      1.0, \
      1.0, \
      1.5 ) )
  b_vec = np.array ( ( \
     96.0, \
     56.0, \
      7.0, \
     11.0, \
     63.0, \
     45.0, \
     75.0, \
      0.0, \
     35.0, \
      1.0, \
     53.0, \
      2.0, \
      4.0, \
      8.0, \
      8.0 ) )
  fx_vec = np.array ( ( \
     52.274641198704240049, \
     68.836530059858524345, \
     20.659301196734009322, \
     17.696854873743648823, \
     23.867049721753300163, \
     20.717015982805991662, \
     56.127842255616681863, \
      0.000000000000000000, \
     59.269565081229636528, \
     3.9362355036495554780, \
     53.000000000000000000, \
     1.4567910310469068692, \
     2.2430285802876025701, \
     3.6157561775973627487, \
     4.0816924080221632670 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    b = 0.0
    fx = 0.0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, fx

def agm_values_test ( ):

#*****************************************************************************80
#
## agm_values_test() tests agm_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    09 February 2008
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'agm_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  agm_values stores values of' )
  print ( '  the arithmetic geometric mean function.' )
  print ( '' )
  print ( '      A           B         AGM(A,B)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, fx = agm_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f' % ( a, b, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'agm_values_test:' )
  print ( '  Normal end of execution.' )
  return

def airy_ai_int_values ( n_data ):

#*****************************************************************************80
#
## airy_ai_int_values returns some values of the integral of the Airy function.
#
#  Discussion:
#
#    The function is defined by:
#
#      airy_ai_int(x) = Integral ( 0 <= t <= x ) Ai(t) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
     -0.75228838916610124300E+00, \
     -0.57348350185854889466E+00, \
     -0.76569840313421291743E+00, \
     -0.65181015505382467421E+00, \
     -0.55881974894471876922E+00, \
     -0.56902352870716815309E+00, \
     -0.47800749642926168100E+00, \
     -0.46567398346706861416E+00, \
     -0.96783140945618013679E-01, \
     -0.34683049857035607494E-03, \
      0.34658366917927930790E-03, \
      0.27657581846051227124E-02, \
      0.14595330491185717833E+00, \
      0.23631734191710977960E+00, \
      0.33289264538612212697E+00, \
      0.33318759129779422976E+00, \
      0.33332945170523851439E+00, \
      0.33333331724248357420E+00, \
      0.33333333329916901594E+00, \
      0.33333333333329380187E+00 ) )

  x_vec = np.array ( ( \
     -12.0000000000E+00, \
     -11.0000000000E+00, \
     -10.0000000000E+00, \
      -9.5000000000E+00, \
      -9.0000000000E+00, \
      -6.5000000000E+00, \
      -4.0000000000E+00, \
      -1.0000000000E+00, \
      -0.2500000000E+00, \
      -0.0009765625E+00, \
       0.0009765625E+00, \
       0.0078125000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       4.0000000000E+00, \
       4.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      12.0000000000E+00 ) ) 

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data =n_data + 1

  return n_data, x, fx

def airy_ai_int_values_test ( ):

#*****************************************************************************80
#
## airy_ai_int_values_test() tests airy_ai_int_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'airy_ai_int_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  airy_ai_int_values stores values of' )
  print ( '  the integral of the Airy Ai function.' )
  print ( '' )
  print ( '      X           FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = airy_ai_int_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'airy_ai_int_values_test:' )
  print ( '  Normal end of execution.' )
  return

def airy_ai_prime_values ( n_data ):

#*****************************************************************************80
#
## airy_ai_prime_values returns some values of the Airy function Ai'(x).
#
#  Discussion:
#
#    The Airy functions Ai(X) and Bi(X) are a pair of linearly independent
#    solutions of the differential equation:
#
#      W'' - X * W = 0
#
#    In Mathematica, the function can be evaluated by:
#
#      AiryAiPrime[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 September 2004
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real AIP, the derivative of the Airy AI function.
#
  import numpy as np

  n_max = 11

  fx_vec = np.array ( ( \
     -0.2588194037928068E+00, \
     -0.2571304219075862E+00, \
     -0.2524054702856195E+00, \
     -0.2451463642190548E+00, \
     -0.2358320344192082E+00, \
     -0.2249105326646839E+00, \
     -0.2127932593891585E+00, \
     -0.1998511915822805E+00, \
     -0.1864128638072717E+00, \
     -0.1727638434616347E+00, \
     -0.1591474412967932E+00 ) )

  x_vec = np.array ( ( \
     0.0E+00, \
     0.1E+00, \
     0.2E+00, \
     0.3E+00, \
     0.4E+00, \
     0.5E+00, \
     0.6E+00, \
     0.7E+00, \
     0.8E+00, \
     0.9E+00, \
     1.0E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data =n_data + 1

  return n_data, x, fx

def airy_ai_prime_values_test ( ):

#*****************************************************************************80
#
## airy_ai_prime_values_test() tests airy_ai_prime_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    06 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'airy_ai_prime_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  airy_ai_prime_values stores values of' )
  print ( '  the derivative of the Airy Ai function.' )
  print ( '' )
  print ( '      X           FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = airy_ai_prime_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'airy_ai_prime_values_test:' )
  print ( '  Normal end of execution.' )
  return

def airy_ai_values ( n_data ):

#*****************************************************************************80
#
## airy_ai_values returns some values of the Airy Ai(x) function.
#
#  Discussion:
#
#    The Airy functions Ai(X) and Bi(X) are a pair of linearly independent
#    solutions of the differential equation:
#
#      W'' - X * W = 0
#
#    In Mathematica, the function can be evaluated by:
#
#      AiryAi[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 September 2004
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real AI, the value of the Airy AI function.
#
  import numpy as np

  n_max = 11

  ai_vec = np.array ( ( \
     0.3550280538878172E+00, \
     0.3292031299435381E+00, \
     0.3037031542863820E+00, \
     0.2788064819550049E+00, \
     0.2547423542956763E+00, \
     0.2316936064808335E+00, \
     0.2098000616663795E+00, \
     0.1891624003981501E+00, \
     0.1698463174443649E+00, \
     0.1518868036405444E+00, \
     0.1352924163128814E+00 ) )

  x_vec = np.array ( ( \
     0.0E+00, \
     0.1E+00, \
     0.2E+00, \
     0.3E+00, \
     0.4E+00, \
     0.5E+00, \
     0.6E+00, \
     0.7E+00, \
     0.8E+00, \
     0.9E+00, \
     1.0E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    ai = 0.0
  else:
    x = x_vec[n_data]
    ai = ai_vec[n_data]
    n_data =n_data + 1

  return n_data, x, ai

def airy_ai_values_test ( ):

#*****************************************************************************80
#
## airy_ai_values_test() tests airy_ai_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 April 2007
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'airy_ai_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  airy_ai_values stores values of' )
  print ( '  the Airy function Ai(x).' )
  print ( '' )
  print ( '      X           Ai(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, ai = airy_ai_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, ai ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'airy_ai_values_test:' )
  print ( '  Normal end of execution.' )
  return

def airy_bi_int_values ( n_data ):

#*****************************************************************************80
#
## airy_bi_int_values returns some values of the integral of the Airy function.
#
#  Discussion:
#
#    The function is defined by:
#
#      airy_bi_int(x) = Integral ( 0 <= t <= x ) Bi(t) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
      0.17660819031554631869E-01, \
     -0.15040424806140020451E-01, \
      0.14756446293227661920E-01, \
     -0.11847304264848446271E+00, \
     -0.64916741266165856037E-01, \
      0.97260832464381044540E-01, \
      0.50760058495287539119E-01, \
     -0.37300500963429492179E+00, \
     -0.13962988442666578531E+00, \
     -0.12001735266723296160E-02, \
      0.12018836117890354598E-02, \
      0.36533846550952011043E+00, \
      0.87276911673800812196E+00, \
      0.48219475263803429675E+02, \
      0.44006525804904178439E+06, \
      0.17608153976228301458E+07, \
      0.73779211705220007228E+07, \
      0.14780980310740671617E+09, \
      0.97037614223613433849E+11, \
      0.11632737638809878460E+15 ) )

  x_vec = np.array ( ( \
     -12.0000000000E+00, \
     -10.0000000000E+00, \
      -8.0000000000E+00, \
      -7.5000000000E+00, \
      -7.0000000000E+00, \
      -6.5000000000E+00, \
      -4.0000000000E+00, \
      -1.0000000000E+00, \
      -0.2500000000E+00, \
      -0.0019531250E+00, \
       0.0019531250E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       4.0000000000E+00, \
       8.0000000000E+00, \
       8.5000000000E+00, \
       9.0000000000E+00, \
      10.0000000000E+00, \
      12.0000000000E+00, \
      14.0000000000E+00 ) ) 

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data =n_data + 1

  return n_data, x, fx

def airy_bi_int_values_test ( ):

#*****************************************************************************80
#
## airy_bi_int_values_test() tests airy_bi_int_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'airy_bi_int_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  airy_bi_int_values stores values of' )
  print ( '  the integral of the Airy Bi function.' )
  print ( '' )
  print ( '      X           FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = airy_bi_int_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'airy_bi_int_values_test:' )
  print ( '  Normal end of execution.' )
  return

def airy_bi_prime_values ( n_data ):

#*****************************************************************************80
#
## airy_bi_prime_values returns some values of the Airy function Bi'(x).
#
#  Discussion:
#
#    The Airy functions Ai(X) and Bi(X) are a pair of linearly independent
#    solutions of the differential equation:
#
#      W'' - X * W = 0
#
#    In Mathematica, the function can be evaluated by:
#
#      AiryBiPrime[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the derivative of the Airy BI function.
#
  import numpy as np

  n_max = 11

  fx_vec = np.array ( ( \
     0.4482883573538264E+00, \
     0.4515126311496465E+00, \
     0.4617892843621509E+00, \
     0.4800490287524480E+00, \
     0.5072816760506224E+00, \
     0.5445725641405923E+00, \
     0.5931444786342857E+00, \
     0.6544059191721400E+00, \
     0.7300069016152518E+00, \
     0.8219038903072090E+00, \
     0.9324359333927756E+00 ) )

  x_vec = np.array ( ( \
     0.0E+00, \
     0.1E+00, \
     0.2E+00, \
     0.3E+00, \
     0.4E+00, \
     0.5E+00, \
     0.6E+00, \
     0.7E+00, \
     0.8E+00, \
     0.9E+00, \
     1.0E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data =n_data + 1

  return n_data, x, fx

def airy_bi_prime_values_test ( ):

#*****************************************************************************80
#
## airy_bi_prime_values_test() tests airy_bi_prime_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'airy_bi_prime_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  airy_bi_prime_values stores values of' )
  print ( '  the derivative of the Airy Bi function.' )
  print ( '' )
  print ( '      X           FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = airy_bi_prime_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'airy_bi_prime_values_test:' )
  print ( '  Normal end of execution.' )
  return

def airy_bi_values ( n_data ):

#*****************************************************************************80
#
## airy_bi_values returns some values of the Airy Bi(x) function.
#
#  Discussion:
#
#    The Airy functions Ai(X) and Bi(X) are a pair of linearly independent
#    solutions of the differential equation:
#
#      W'' - X * W = 0
#
#    In Mathematica, the function can be evaluated by:
#
#      AiryBi[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the Airy BI function.
#
  import numpy as np

  n_max = 11

  fx_vec = np.array ( ( \
     0.6149266274460007E+00, \
     0.6598616901941892E+00, \
     0.7054642029186612E+00, \
     0.7524855850873156E+00, \
     0.8017730000135972E+00, \
     0.8542770431031555E+00, \
     0.9110633416949405E+00, \
     0.9733286558781659E+00, \
     0.1042422171231561E+01, \
     0.1119872813134447E+01, \
     0.1207423594952871E+01 ) )

  x_vec = np.array ( ( \
     0.0E+00, \
     0.1E+00, \
     0.2E+00, \
     0.3E+00, \
     0.4E+00, \
     0.5E+00, \
     0.6E+00, \
     0.7E+00, \
     0.8E+00, \
     0.9E+00, \
     1.0E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def airy_bi_values_test ( ):

#*****************************************************************************80
#
## airy_bi_values_test() tests airy_bi_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'airy_bi_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  airy_bi_values stores values of' )
  print ( '  the Airy function Bi(x).' )
  print ( '' )
  print ( '      X           Bi(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, ai = airy_bi_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, ai ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'airy_bi_values_test:' )
  print ( '  Normal end of execution.' )
  return

def airy_cai_values ( n_data ):

#*****************************************************************************80
#
## airy_cai_values returns some values of the Airy Ai(x) with complex argument.
#
#  Discussion:
#
#    The Airy functions Ai(X) and Bi(X) are a pair of linearly independent
#    solutions of the differential equation:
#
#      W'' - X * W = 0
#
#    In Mathematica, the function can be evaluated by:
#
#      AiryAi[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 April 2007
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    complex X, the argument of the function.
#
#    complex CAI, the value of the Airy AI function.
#
  import numpy as np

  n_max = 10

  cai_vec = np.array ( [ \
    0.1352924163128814 + 0.0000000000000000j, \
    0.1433824486882056 - 0.1092193342707378j, \
    0.2215404472324631 - 0.2588711788891803j, \
    0.4763929771766866 - 0.3036484220291284j, \
    0.5983692170633874 - 0.08154602160771214j, \
    0.5355608832923521 + 0.00000000000000000j, \
    0.5983692170633874 + 0.08154602160771214j, \
    0.4763929771766866 + 0.3036484220291284j, \
    0.2215404472324631 + 0.2588711788891803j, \
    0.1433824486882056 + 0.1092193342707378j ] )

  x_vec = np.array ( [ \
     1.0000000000000000 + 0.0000000000000000j, \
     0.8090169943749474 + 0.5877852522924731j, \
     0.3090169943749474 + 0.9510565162951536j, \
    -0.3090169943749474 + 0.9510565162951536j, \
    -0.8090169943749474 + 0.5877852522924731j, \
    -1.0000000000000000 + 0.0000000000000000j, \
    -0.8090169943749474 - 0.5877852522924731j, \
    -0.3090169943749474 - 0.9510565162951536j, \
     0.3090169943749474 - 0.9510565162951536j, \
     0.8090169943749474 - 0.5877852522924731j ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    cai = 0.0
  else:
    x = x_vec[n_data]
    cai = cai_vec[n_data]
    n_data = n_data + 1

  return n_data, x, cai

def airy_cai_values_test ( ):

#*****************************************************************************80
#
## airy_cai_values_test() tests airy_cai_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    10 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'airy_cai_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  airy_cai_values stores values of' )
  print ( '  the complex Airy function Ai(x).' )
  print ( '' )
  print ( '        X.real        X.imag          Ai.real                Ai.imag' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, cai = airy_cai_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %24.16g  %24.16g' \
      % ( x.real, x.imag, cai.real, cai.imag ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'airy_cai_values_test:' )
  print ( '  Normal end of execution.' )
  return

def airy_cbi_values ( n_data ):

#*****************************************************************************80
#
## airy_cbi_values returns some values of the Airy Bi(x) with complex argument.
#
#  Discussion:
#
#    The Airy functions Ai(X) and Bi(X) are a pair of linearly independent
#    solutions of the differential equation:
#
#      W'' - X * W = 0
#
#    In Mathematica, the function can be evaluated by:
#
#      AiryBi[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 April 2007
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    complex X, the argument of the function.
#
#    complex CBI, the value of the Airy BI function.
#
  import numpy as np

  n_max = 10

  cbi_vec = np.array ( ( \
    1.207423594952871  + 0.0000000000000000j, \
    0.9127160108293936 + 0.3800456133135556j, \
    0.6824453575635721 + 0.3343047153635002j, \
    0.5726265660086474 + 0.3988641086982559j, \
    0.2511841251049547 + 0.3401447690712719j, \
    0.1039973894969446 + 0.0000000000000000j, \
    0.2511841251049547 - 0.3401447690712719j, \
    0.5726265660086474 - 0.3988641086982559j, \
    0.6824453575635721 - 0.3343047153635002j, \
    0.9127160108293936 - 0.3800456133135556j ) )

  x_vec = np.array ( ( \
     1.0000000000000000 + 0.0000000000000000j, \
     0.8090169943749474 + 0.5877852522924731j, \
     0.3090169943749474 + 0.9510565162951536j, \
    -0.3090169943749474 + 0.9510565162951536j, \
    -0.8090169943749474 + 0.5877852522924731j, \
    -1.0000000000000000 + 0.0000000000000000j, \
    -0.8090169943749474 - 0.5877852522924731j, \
    -0.3090169943749474 - 0.9510565162951536j, \
     0.3090169943749474 - 0.9510565162951536j, \
     0.8090169943749474 - 0.5877852522924731j ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    cbi = 0.0
  else:
    x = x_vec[n_data]
    cbi = cbi_vec[n_data]
    n_data = n_data + 1

  return n_data, x, cbi

def airy_cbi_values_test ( ):

#*****************************************************************************80
#
## airy_cbi_values_test() tests airy_cbi_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    10 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'airy_cbi_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  airy_cbi_values stores values of' )
  print ( '  the complex Airy function Bi(x).' )
  print ( '' )
  print ( '        X.real        X.imag          Bi.real(X)                Bi.imag(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, cbi = airy_cbi_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f  %24.16g' \
      % ( x.real, x.imag, cbi.real, cbi.imag ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'airy_cbi_values_test:' )
  print ( '  Normal end of execution.' )
  return

def airy_gi_values ( n_data ):

#*****************************************************************************80
#
## airy_gi_values returns some values of the Airy Gi(x) function.
#
#  Discussion:
#
#    The function is defined by:
#
#      airy_gi(x) = Integral ( 0 <= t < infinity ) sin ( x*t+t^3/3) dt / pi
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
      0.20468308070040542435E+00, \
      0.18374662832557904078E+00, \
     -0.11667221729601528265E+00, \
      0.31466934902729557596E+00, \
     -0.37089040722426257729E+00, \
     -0.25293059772424019694E+00, \
      0.28967410658692701936E+00, \
     -0.34644836492634090590E+00, \
      0.28076035913873049496E+00, \
      0.21814994508094865815E+00, \
      0.20526679000810503329E+00, \
      0.22123695363784773258E+00, \
      0.23521843981043793760E+00, \
      0.82834303363768729338E-01, \
      0.45757385490989281893E-01, \
      0.44150012014605159922E-01, \
      0.39951133719508907541E-01, \
      0.35467706833949671483E-01, \
      0.31896005100679587981E-01, \
      0.26556892713512410405E-01 ) )

  x_vec = np.array ( ( \
      -0.0019531250E+00, \
      -0.1250000000E+00, \
      -1.0000000000E+00, \
      -4.0000000000E+00, \
      -8.0000000000E+00, \
      -8.2500000000E+00, \
      -9.0000000000E+00, \
     -10.0000000000E+00, \
     -11.0000000000E+00, \
     -13.0000000000E+00, \
       0.0019531250E+00, \
       0.1250000000E+00, \
       1.0000000000E+00, \
       4.0000000000E+00, \
       7.0000000000E+00, \
       7.2500000000E+00, \
       8.0000000000E+00, \
       9.0000000000E+00, \
      10.0000000000E+00, \
      12.0000000000E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def airy_gi_values_test ( ):

#*****************************************************************************80
#
## airy_gi_values_test() tests airy_gi_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'airy_gi_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  airy_gi_values stores values of' )
  print ( '  the Airy function Gi(x).' )
  print ( '' )
  print ( '      X           Gi(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, ai = airy_gi_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, ai ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'airy_gi_values_test:' )
  print ( '  Normal end of execution.' )
  return

def airy_hi_values ( n_data ):

#*****************************************************************************80
#
## airy_hi_values returns some values of the Airy Hi(x) function.
#
#  Discussion:
#
#    The function is defined by:
#
#      airy_hi(x) = Integral ( 0 <= t < infinity ) exp ( x*t-t^3/3) dt / pi
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
     0.40936798278458884024E+00, \
     0.37495291608048868619E+00, \
     0.22066960679295989454E+00, \
     0.77565356679703713590E-01, \
     0.39638826473124717315E-01, \
     0.38450072575004151871E-01, \
     0.35273216868317898556E-01, \
     0.31768535282502272742E-01, \
     0.28894408288051391369E-01, \
     0.24463284011678541180E-01, \
     0.41053540139998941517E+00, \
     0.44993502381204990817E+00, \
     0.97220515514243332184E+00, \
     0.83764237105104371193E+02, \
     0.80327744952044756016E+05, \
     0.15514138847749108298E+06, \
     0.11995859641733262114E+07, \
     0.21472868855967642259E+08, \
     0.45564115351632913590E+09, \
     0.32980722582904761929E+12 ) )

  x_vec = np.array ( ( \
      -0.0019531250E+00, \
      -0.1250000000E+00, \
      -1.0000000000E+00, \
      -4.0000000000E+00, \
      -8.0000000000E+00, \
      -8.2500000000E+00, \
      -9.0000000000E+00, \
     -10.0000000000E+00, \
     -11.0000000000E+00, \
     -13.0000000000E+00, \
       0.0019531250E+00, \
       0.1250000000E+00, \
       1.0000000000E+00, \
       4.0000000000E+00, \
       7.0000000000E+00, \
       7.2500000000E+00, \
       8.0000000000E+00, \
       9.0000000000E+00, \
      10.0000000000E+00, \
      12.0000000000E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def airy_hi_values_test ( ):

#*****************************************************************************80
#
## airy_hi_values_test() tests airy_hi_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'airy_hi_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  airy_hi_values stores values of' )
  print ( '  the Airy function Hi(x).' )
  print ( '' )
  print ( '      X           Hi(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, ai = airy_hi_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, ai ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'airy_hi_values_test:' )
  print ( '  Normal end of execution.' )
  return

def arccosh_values ( n_data ):

#*****************************************************************************80
#
## arccosh_values returns some values of the hyperbolic arc cosine function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      ArcCosh[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 15

  fx_vec = np.array ( ( \
    0.0000000000000000000, \
    0.14130376948564857735, \
    0.44356825438511518913, \
    0.62236250371477866781, \
    0.75643291085695958624, \
    0.86701472649056510395, \
    0.96242365011920689500, \
    1.3169578969248167086, \
    1.7627471740390860505, \
    1.8115262724608531070, \
    2.0634370688955605467, \
    2.2924316695611776878, \
    2.9932228461263808979, \
    5.2982923656104845907, \
    7.6009022095419886114 ) )

  x_vec = np.array ( ( \
       1.0, \
       1.01, \
       1.1, \
       1.2, \
       1.3, \
       1.4, \
       1.5, \
       2.0, \
       3.0, \
       3.1415926535897932385, \
       4.0, \
       5.0, \
      10.0, \
     100.0, \
    1000.0 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def arccosh_values_test ( ):

#*****************************************************************************80
#
## arccosh_values_test() tests arccosh_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'arccosh_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  arccosh_values stores values of' )
  print ( '  the hyperbolic arc cosine function.' )
  print ( '' )
  print ( '        X               F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = arccosh_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'arccosh_values_test:' )
  print ( '  Normal end of execution.' )
  return

def arccos_values ( n_data ):

#*****************************************************************************80
#
## arccos_values returns some values of the arc cosine function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      ArcCos[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 12

  fx_vec = np.array ( ( \
    1.6709637479564564156, \
    1.5707963267948966192, \
    1.4706289056333368229, \
    1.3694384060045658278, \
    1.2661036727794991113, \
    1.1592794807274085998, \
    1.0471975511965977462, \
    0.92729521800161223243, \
    0.79539883018414355549, \
    0.64350110879328438680, \
    0.45102681179626243254, \
    0.00000000000000000000 ) )

  x_vec = np.array ( ( \
    -0.1, \
     0.0, \
     0.1, \
     0.2, \
     0.3, \
     0.4, \
     0.5, \
     0.6, \
     0.7, \
     0.8, \
     0.9, \
     1.0 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def arccos_values_test ( ):

#*****************************************************************************80
#
## arccos_values_test() tests arccos_values().
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'arccos_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  arccos_values stores values of' )
  print ( '  the arc cosine function.' )
  print ( '' )
  print ( '        X               F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = arccos_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'arccos_values_test:' )
  print ( '  Normal end of execution.' )
  return

def arcsinh_values ( n_data ):

#*****************************************************************************80
#
## arcsinh_values returns some values of the hyperbolic arc sine function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      ArcSinh[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2007
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
    -2.3124383412727526203, \
    -0.88137358701954302523, \
     0.00000000000000000000, \
     0.099834078899207563327, \
     0.19869011034924140647, \
     0.29567304756342243910, \
     0.39003531977071527608, \
     0.48121182505960344750, \
     0.56882489873224753010, \
     0.65266656608235578681, \
     0.73266825604541086415, \
     0.80886693565278246251, \
     0.88137358701954302523, \
     1.4436354751788103425, \
     1.8184464592320668235, \
     2.0947125472611012942, \
     2.3124383412727526203, \
     2.9982229502979697388, \
     5.2983423656105887574, \
     7.6009027095419886115 ) )

  x_vec = np.array ( ( \
       -5.0, \
       -1.0, \
        0.0, \
        0.1, \
        0.2, \
        0.3, \
        0.4, \
        0.5, \
        0.6, \
        0.7, \
        0.8, \
        0.9, \
        1.0, \
        2.0, \
        3.0, \
        4.0, \
        5.0, \
       10.0, \
      100.0, \
     1000.0 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def arcsinh_values_test ( ):

#*****************************************************************************80
#
## arcsinh_values_test() tests arcsinh_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'arcsinh_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  arcsinh_values stores values of' )
  print ( '  the hyperbolic arc sine function.' )
  print ( '' )
  print ( '        X               F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = arcsinh_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'arcsinh_values_test:' )
  print ( '  Normal end of execution.' )
  return

def arcsin_values ( n_data ):

#*****************************************************************************80
#
## arcsin_values returns some values of the arc sine function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      ArcSin[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 12

  fx_vec = np.array ( ( \
    -0.10016742116155979635, \
     0.00000000000000000000, \
     0.10016742116155979635, \
     0.20135792079033079146, \
     0.30469265401539750797, \
     0.41151684606748801938, \
     0.52359877559829887308, \
     0.64350110879328438680, \
     0.77539749661075306374, \
     0.92729521800161223243, \
     1.1197695149986341867, \
     1.5707963267948966192 ) )

  x_vec = np.array ( ( \
    -0.1, \
     0.0, \
     0.1, \
     0.2, \
     0.3, \
     0.4, \
     0.5, \
     0.6, \
     0.7, \
     0.8, \
     0.9, \
     1.0 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def arcsin_values_test ( ):

#*****************************************************************************80
#
## arcsin_values_test() tests arcsin_values().
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'arcsin_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  arcsin_values stores values of' )
  print ( '  the arc sine function.' )
  print ( '' )
  print ( '        X               F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = arcsin_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'arcsin_values_test:' )
  print ( '  Normal end of execution.' )
  return

def arctan2_values ( n_data ):

#*****************************************************************************80
#
## arctan2_values: arc tangent function of two arguments.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      ArcTan[x,y]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, Y, the arguments of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 19

  f_vec = np.array ( ( \
   -1.5707963267948966192, \
   -1.0471975511965977462, \
   -0.52359877559829887308, \
    0.00000000000000000000, \
    0.52359877559829887308, \
    1.0471975511965977462, \
    1.5707963267948966192, \
    2.0943951023931954923, \
    2.6179938779914943654, \
    3.1415926535897932385, \
   -2.6179938779914943654, \
   -2.0943951023931954923, \
   -1.5707963267948966192, \
   -1.0471975511965977462, \
   -0.52359877559829887308, \
    0.00000000000000000000, \
    0.52359877559829887308, \
    1.0471975511965977462, \
    1.5707963267948966192 ) )

  x_vec = np.array ( ( \
    0.00000000000000000000, \
    0.50000000000000000000, \
    0.86602540378443864676, \
    1.00000000000000000000, \
    0.86602540378443864676, \
    0.50000000000000000000, \
    0.00000000000000000000, \
   -0.50000000000000000000, \
   -0.86602540378443864676, \
   -1.00000000000000000000, \
   -0.86602540378443864676, \
   -0.50000000000000000000, \
    0.00000000000000000000, \
    0.50000000000000000000, \
    0.86602540378443864676, \
    1.00000000000000000000, \
    0.86602540378443864676, \
    0.50000000000000000000, \
    0.00000000000000000000 ) )

  y_vec = np.array ( ( \
   -1.00000000000000000000, \
   -0.86602540378443864676, \
   -0.50000000000000000000, \
    0.00000000000000000000, \
    0.50000000000000000000, \
    0.86602540378443864676, \
    1.00000000000000000000, \
    0.86602540378443864676, \
    0.50000000000000000000, \
    0.00000000000000000000, \
   -0.50000000000000000000, \
   -0.86602540378443864676, \
   -1.00000000000000000000, \
   -0.86602540378443864676, \
   -0.50000000000000000000, \
    0.00000000000000000000, \
    0.50000000000000000000, \
    0.86602540378443864676, \
    1.00000000000000000000 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    y = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    y = y_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, y, f

def arctan2_values_test ( ):

#*****************************************************************************80
#
## arctan2_values_test() tests arctan2_values().
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'arctan2_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  arctan2_values stores values of' )
  print ( '  the arc tangent function.' )
  print ( '' )
  print ( '        X           Y               F(X,Y)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, y, f = arctan2_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( x, y, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'arctan2_values_test:' )
  print ( '  Normal end of execution.' )
  return

def arctanh_values ( n_data ):

#*****************************************************************************80
#
## arctanh_values returns some values of the hyperbolic arc tangent function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      ArcTanh[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 15

  fx_vec = np.array ( ( \
    -0.54930614433405484570, \
     0.00000000000000000000, \
     0.0010000003333335333335, \
     0.10033534773107558064, \
     0.20273255405408219099, \
     0.30951960420311171547, \
     0.42364893019360180686, \
     0.54930614433405484570, \
     0.69314718055994530942, \
     0.86730052769405319443, \
     1.0986122886681096914, \
     1.4722194895832202300, \
     2.6466524123622461977, \
     3.8002011672502000318, \
     7.2543286192620472067 ) )

  x_vec = np.array ( ( \
    -0.5, \
     0.0, \
     0.001, \
     0.1, \
     0.2, \
     0.3, \
     0.4, \
     0.5, \
     0.6, \
     0.7, \
     0.8, \
     0.9, \
     0.99, \
     0.999, \
     0.999999 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def arctanh_values_test ( ):

#*****************************************************************************80
#
## arctanh_values_test() tests arctanh_values().
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'arctanh_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  arctanh_values stores values of' )
  print ( '  the hyperbolic arc tangent function.' )
  print ( '' )
  print ( '        X               F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = arctanh_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'arctanh_values_test:' )
  print ( '  Normal end of execution.' )
  return

def arctan_int_values ( n_data ):

#*****************************************************************************80
#
## arctan_int_values returns some values of the inverse tangent integral.
#
#  Discussion:
#
#    The function is defined by:
#
#      arctan_int(x) = Integral ( 0 <= t <= x ) arctan ( t ) / t dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
      0.19531241721588483191E-02, \
     -0.39062433772980711281E-02, \
      0.78124470192576499535E-02, \
      0.15624576181996527280E-01, \
     -0.31246610349485401551E-01, \
      0.62472911335014397321E-01, \
      0.12478419717389654039E+00, \
     -0.24830175098230686908E+00, \
      0.48722235829452235711E+00, \
      0.91596559417721901505E+00, \
      0.12749694484943800618E+01, \
     -0.15760154034463234224E+01, \
      0.24258878412859089996E+01, \
      0.33911633326292997361E+01, \
      0.44176450919422186583E+01, \
     -0.47556713749547247774E+01, \
      0.50961912150934111303E+01, \
      0.53759175735714876256E+01, \
     -0.61649904785027487422E+01, \
      0.72437843013083534973E+01 ) )

  x_vec = np.array ( ( \
       0.0019531250E+00, \
      -0.0039062500E+00, \
       0.0078125000E+00, \
       0.0156250000E+00, \
      -0.0312500000E+00, \
       0.0625000000E+00, \
       0.1250000000E+00, \
      -0.2500000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
      -2.0000000000E+00, \
       4.0000000000E+00, \
       8.0000000000E+00, \
      16.0000000000E+00, \
     -20.0000000000E+00, \
      25.0000000000E+00, \
      30.0000000000E+00, \
     -50.0000000000E+00, \
     100.0000000000E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def arctan_int_values_test ( ):

#*****************************************************************************80
#
## arctan_int_values_test() tests arctan_int_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'arctan_int_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  arctan_int_values stores values of' )
  print ( '  the arc tangent integral.' )
  print ( '' )
  print ( '        X               F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = arctan_int_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'arctan_int_values_test:' )
  print ( '  Normal end of execution.' )
  return

def arctan_values ( n_data ):

#*****************************************************************************80
#
## arctan_values returns some values of the arc tangent function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      ArcTan[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 11

  fx_vec = np.array ( ( \
    0.00000000000000000000, \
    0.24497866312686415417, \
    0.32175055439664219340, \
    0.46364760900080611621, \
    0.78539816339744830962, \
    1.1071487177940905030, \
    1.2490457723982544258, \
    1.3258176636680324651, \
    1.3734007669450158609, \
    1.4711276743037345919, \
    1.5208379310729538578 ) )

  x_vec = np.array ( ( \
    0.00000000000000000000, \
    0.25000000000000000000, \
    0.33333333333333333333, \
    0.50000000000000000000, \
    1.0000000000000000000, \
    2.0000000000000000000, \
    3.0000000000000000000, \
    4.0000000000000000000, \
    5.0000000000000000000, \
    10.000000000000000000, \
    20.000000000000000000 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def arctan_values_test ( ):

#*****************************************************************************80
#
## arctan_values_test() tests arctan_values().
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'arctan_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  arctan_values stores values of' )
  print ( '  the arc tangent function.' )
  print ( '' )
  print ( '        X               F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = arctan_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'arctan_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bei0_values ( n_data ):

#*****************************************************************************80
#
## bei0_values returns some values of the Kelvin BEI function of order NU = 0.
#
#  Discussion:
#
#    The function is defined by:
#
#      BER(NU,X) + i * BEI(NU,X) = exp(NU*Pi*I) * J(NU,X*exp(-PI*I/4))
#
#    where J(NU,X) is the J Bessel function.
#
#    In Mathematica, BEI(NU,X) can be defined by:
#
#      Im [ Exp [ NU * Pi * I ] * BesselJ [ NU, X * Exp[ -Pi * I / 4 ] ] ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    28 June 2006
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    LC: QA47.A34,
#    ISBN: 0-486-61272-4.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    LC: QA76.95.W65,
#    ISBN: 0-521-64314-7.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 11

  fx_vec = np.array ( ( \
    0.0000000000000000, \
    0.06249321838219946, \
    0.2495660400366597, \
    0.5575600623030867, \
    0.9722916273066612, \
    1.457182044159804, \
   1.937586785266043, \
   2.283249966853915, \
   2.292690322699300, \
   1.686017203632139, \
   0.1160343815502004 ) )

  x_vec = np.array ( ( \
    0.0, \
    0.5, \
    1.0, \
    1.5, \
    2.0, \
    2.5, \
    3.0, \
    3.5, \
    4.0, \
    4.5, \
    5.0  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bei0_values_test ( ):

#*****************************************************************************80
#
## bei0_values_test() tests bei0_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    24 December 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bei0_values_test:' )
  print ( '  bei0_values stores values of the Kelvin BEI function. of order 0.' )
  print ( '' )
  print ( '      X         BEI(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bei0_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bei0_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bei1_values ( n_data ):

#*****************************************************************************80
#
## bei0_values returns some values of the Kelvin BEI function of order NU = 1.
#
#  Discussion:
#
#    The function is defined by:
#
#      BER(NU,X) + i * BEI(NU,X) = exp(NU*Pi*I) * J(NU,X*exp(-PI*I/4))
#
#    where J(NU,X) is the J Bessel function.
#
#    In Mathematica, BEI(NU,X) can be defined by:
#
#      Im [ Exp [ NU * Pi * I ] * BesselJ [ NU, X * Exp[ -Pi * I / 4 ] ] ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    25 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    LC: QA47.A34,
#    ISBN: 0-486-61272-4.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    LC: QA76.95.W65,
#    ISBN: 0-521-64314-7.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 11

  fx_vec = np.array ( ( \
    0.0000000000000000, \
    0.1711951797170153, \
    0.3075566313755366, \
    0.3678649890020899, \
    0.2997754370020335, \
    0.03866844396595048, \
   -0.4874541770160708, \
   -1.344042373111174, \
   -2.563821688561078, \
   -4.105685408400878, \
   -5.797907901792625 ) )

  x_vec = np.array ( ( \
    0.0, \
    0.5, \
    1.0, \
    1.5, \
    2.0, \
    2.5, \
    3.0, \
    3.5, \
    4.0, \
    4.5, \
    5.0  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bei1_values_test ( ):

#*****************************************************************************80
#
## bei1_values_test() tests bei1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    25 December 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bei1_values_test:' )
  print ( '  bei1_values stores values of the Kelvin BEI function of order 1.' )
  print ( '' )
  print ( '      X         BEI(1,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bei1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bei1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bell_values ( n_data ):

#*****************************************************************************80
#
## bell_values returns some values of the Bell numbers.
#
#  Discussion:
#
#    The Bell number B(N) is the number of restricted growth functions on N.
#
#    Note that the Stirling numbers of the second kind, S^m_n, count the
#    number of partitions of N objects into M classes, and so it is
#    true that
#
#      B(N) = S^1_N + S^2_N + ... + S^N_N.
#
#    The Bell numbers were named for Eric Temple Bell.
#
#    In Mathematica, the function can be evaluated by
#
#      Sum[StirlingS2[n,m],{m,1,n}]
#
#    The Bell number B(N) is defined as the number of partitions (of
#    any size) of a set of N distinguishable objects.  
#
#    A partition of a set is a division of the objects of the set into 
#    subsets.
#
#  Example:
#
#    There are 15 partitions of a set of 4 objects:
#
#      (1234), 
#      (123) (4), 
#      (124) (3), 
#      (12) (34), 
#      (12) (3) (4), 
#      (134) (2), 
#      (13) (24), 
#      (13) (2) (4), 
#      (14) (23), 
#      (1) (234),
#      (1) (23) (4), 
#      (14) (2) (3), 
#      (1) (24) (3), 
#      (1) (2) (34), 
#      (1) (2) (3) (4).
#
#    and so B(4) = 15.
#
#  First values:
#
#     N         B(N)
#     0           1
#     1           1
#     2           2
#     3           5
#     4          15
#     5          52
#     6         203
#     7         877
#     8        4140
#     9       21147
#    10      115975
#
#  Recursion:
#
#    B(I) = sum ( 1 <= J <=I ) Binomial ( I-1, J-1 ) * B(I-J)
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 November 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the Bell number.
#
#    integer C, the value of the Bell number.
#
  import numpy as np

  n_max = 11

  c_vec = np.array ( ( 1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975 ) )

  n_vec = np.array ( ( 0,  1,  2,  3,  4, 5,  6,  7,  8,  9,  10 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    c = 0
  else:
    n = n_vec[n_data]
    c = c_vec[n_data]
    n_data = n_data + 1

  return n_data, n, c

def bell_values_test ( ):

#*****************************************************************************80
#
## bell_values_test() tests bell_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 November 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'bell_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  bell_values returns values of' )
  print ( '  the Bell numbers.' )
  print ( '' )
  print ( '     N        BELL(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, c = bell_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '%6d  %10d' % ( n, c ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bell_values_test:' )
  print ( '  Normal end of execution.' )
  return

def ber0_values ( n_data ):

#*****************************************************************************80
#
## ber0_values returns some values of the Kelvin BER function of order NU = 0.
#
#  Discussion:
#
#    The function is defined by:
#
#      BER(NU,X) + i * BEI(NU,X) = exp(NU*Pi*I) * J(NU,X*exp(-PI*I/4))
#
#    where J(NU,X) is the J Bessel function.
#
#    In Mathematica, BER(NU,X) can be defined by:
#
#      Re [ Exp [ NU * Pi * I ] * BesselJ [ NU, X * Exp[ -Pi * I / 4 ] ] ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 June 2006
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    LC: QA47.A34,
#    ISBN: 0-486-61272-4.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    LC: QA76.95.W65,
#    ISBN: 0-521-64314-7.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 11

  fx_vec = np.array ( ( \
    1.0000000000000000, \
    0.9990234639908383, \
    0.9843817812130869, \
    0.9210721835462558, \
    0.7517341827138082, \
    0.3999684171295313, \
   -0.2213802495986939, \
   -1.193598179589928, \
   -2.563416557258580, \
   -4.299086551599756, \
   -6.230082478666358 ) )

  x_vec = np.array ( ( \
    0.0, \
    0.5, \
    1.0, \
    1.5, \
    2.0, \
    2.5, \
    3.0, \
    3.5, \
    4.0, \
    4.5, \
    5.0  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def ber0_values_test ( ):

#*****************************************************************************80
#
## ber0_values_test() tests ber0_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    25 December 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'ber0_values_test:' )
  print ( '  ber0_values stores values of the Kelvin BER function. of order 0.' )
  print ( '' )
  print ( '      X         BER(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = ber0_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'ber0_values_test:' )
  print ( '  Normal end of execution.' )
  return

def ber1_values ( n_data ):

#*****************************************************************************80
#
## ber1_values returns some values of the Kelvin BER function of order NU = 1.
#
#  Discussion:
#
#    The function is defined by:
#
#      BER(NU,X) + i * BEI(NU,X) = exp(NU*Pi*I) * J(NU,X*exp(-PI*I/4))
#
#    where J(NU,X) is the J Bessel function.
#
#    In Mathematica, BER(NU,X) can be defined by:
#
#      Re [ Exp [ NU * Pi * I ] * BesselJ [ NU, X * Exp[ -Pi * I / 4 ] ] ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    25 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    LC: QA47.A34,
#    ISBN: 0-486-61272-4.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    LC: QA76.95.W65,
#    ISBN: 0-521-64314-7.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 11

  fx_vec = np.array ( ( \
     0.0000000000000000, \
    -0.1822431237551121, \
    -0.3958682610197114, \
    -0.6648654179597691, \
    -0.9970776519264285, \
    -1.373096897645111, \
   -1.732644221128481, \
   -1.959644131289749, \
   -1.869248459031899, \
   -1.202821631480086, \
    0.3597766667766728 ) )

  x_vec = np.array ( ( \
    0.0, \
    0.5, \
    1.0, \
    1.5, \
    2.0, \
    2.5, \
    3.0, \
    3.5, \
    4.0, \
    4.5, \
    5.0  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def ber1_values_test ( ):

#*****************************************************************************80
#
## ber1_values_test() tests ber1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    25 December 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'ber1_values_test:' )
  print ( '  ber1_values stores values of the Kelvin BER function of order 1.' )
  print ( '' )
  print ( '      X         BER(1,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = ber1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'ber1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bernoulli_number_values ( n_data ):

#*****************************************************************************80
#
## bernoulli_number_values returns some values of the Bernoulli numbers.
#
#  Discussion:
#
#    The Bernoulli numbers are rational.
#
#    If we define the sum of the M-th powers of the first N integers as:
#
#      SIGMA(M,N) = sum ( 0 <= I <= N ) I**M
#
#    and let C(I,J) be the combinatorial coefficient:
#
#      C(I,J) = I! / ( ( I - J )! * J! )
#
#    then the Bernoulli numbers B(J) satisfy:
#
#      SIGMA(M,N) = 1/(M+1) * sum ( 0 <= J <= M ) C(M+1,J) B(J) * (N+1)**(M+1-J)
#
#    In Mathematica, the function can be evaluated by:
#
#      BernoulliB[n]
#
#  First values:
#
#   B0  1                   =         1.00000000000
#   B1 -1/2                 =        -0.50000000000
#   B2  1/6                 =         1.66666666666
#   B3  0                   =         0
#   B4 -1/30                =        -0.03333333333
#   B5  0                   =         0
#   B6  1/42                =         0.02380952380
#   B7  0                   =         0
#   B8 -1/30                =        -0.03333333333
#   B9  0                   =         0
#  B10  5/66                =         0.07575757575
#  B11  0                   =         0
#  B12 -691/2730            =        -0.25311355311
#  B13  0                   =         0
#  B14  7/6                 =         1.16666666666
#  B15  0                   =         0
#  B16 -3617/510            =        -7.09215686274
#  B17  0                   =         0
#  B18  43867/798           =        54.97117794486
#  B19  0                   =         0
#  B20 -174611/330          =      -529.12424242424
#  B21  0                   =         0
#  B22  854,513/138         =      6192.123
#  B23  0                   =         0
#  B24 -236364091/2730      =    -86580.257
#  B25  0                   =         0
#  B26  8553103/6           =   1425517.16666
#  B27  0                   =         0
#  B28 -23749461029/870     = -27298231.0678
#  B29  0                   =         0
#  B30  8615841276005/14322 = 601580873.901
#
#  Recursion:
#
#    With C(N+1,K) denoting the standard binomial coefficient,
#
#    B(0) = 1.0
#    B(N) = - ( sum ( 0 <= K < N ) C(N+1,K) * B(K) ) / C(N+1,N)
#
#  Special Values:
#
#    Except for B(1), all Bernoulli numbers of odd index are 0.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the Bernoulli number.
#
#    real C, the value of the Bernoulli number.
#
  import numpy as np

  n_max = 10

  c_vec = np.array ( ( 
      0.1000000000000000E+01, \
     -0.5000000000000000E+00, \
      0.1666666666666667E+00, \
      0.0000000000000000E+00, \
     -0.3333333333333333E-01, \
     -0.2380952380952380E-01, \
     -0.3333333333333333E-01, \
      0.7575757575757575E-01, \
     -0.5291242424242424E+03, \
      0.6015808739006424E+09  ) )

  n_vec = np.array ( ( 0,  1,  2,  3,  4, 6,  8, 10, 20, 30 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    c = 0
  else:
    n = n_vec[n_data]
    c = c_vec[n_data]
    n_data = n_data + 1

  return n_data, n, c

def bernoulli_number_values_test ( ):

#*****************************************************************************80
#
## bernoulli_number_values_test() tests bernoulli_number_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'bernoulli_number_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  bernoulli_number_values returns values of' )
  print ( '  the Bernoulli numbers.' )
  print ( '' )
  print ( '     N        bernoulli_number(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, c = bernoulli_number_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '%6d  %14.6g' % ( n, c ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bernoulli_number_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bernoulli_poly_values ( n_data ):

#*****************************************************************************80
#
## bernoulli_poly_values returns some values of the Bernoulli polynomials.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      BernoulliB[n,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    26 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the Bernoulli polynomial.
#
#    real X, the argument of the Bernoulli polynomial.
#
#    real FX, the value of the Bernoulli polynomial.
#
  import numpy as np

  n_max = 27

  fx_vec = np.array ( ( \
     0.1000000000000000E+01, \
     -0.3000000000000000E+00, \
      0.6666666666666667E-02, \
      0.4800000000000000E-01, \
     -0.7733333333333333E-02, \
     -0.2368000000000000E-01, \
      0.6913523809523810E-02, \
      0.2490880000000000E-01, \
     -0.1014997333333333E-01, \
     -0.4527820800000000E-01, \
      0.2332631815757576E-01, \
     -0.3125000000000000E+00, \
     -0.1142400000000000E+00, \
     -0.0176800000000000E+00, \
      0.0156800000000000E+00, \
      0.0147400000000000E+00, \
      0.0000000000000000E+00, \
     -0.1524000000000000E-01, \
     -0.2368000000000000E-01, \
     -0.2282000000000000E-01, \
     -0.1376000000000000E-01, \
      0.0000000000000000E+01, \
      0.1376000000000000E-01, \
      0.2282000000000000E-01, \
      0.2368000000000000E-01, \
      0.1524000000000000E-01, \
      0.0000000000000000E+01 ) )

  n_vec = np.array ( ( \
     0, \
     1, \
     2, \
     3, \
     4, \
     5, \
     6, \
     7, \
     8, \
     9, \
    10, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5 ))

  x_vec = np.array ( ( \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
     -0.5E+00, \
     -0.4E+00, \
     -0.3E+00, \
     -0.2E+00, \
     -0.1E+00, \
      0.0E+00, \
      0.1E+00, \
      0.2E+00, \
      0.3E+00, \
      0.4E+00, \
      0.5E+00, \
      0.6E+00, \
      0.7E+00, \
      0.8E+00, \
      0.9E+00, \
      1.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    fx = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, fx

def bernoulli_poly_values_test ( ):

#*****************************************************************************80
#
## bernoulli_poly_values_test() tests bernoulli_poly_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    26 December 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bernoulli_poly_values_test:' )
  print ( '  bernoulli_poly_values stores values of the Bernoulli polynomials.' )
  print ( '' )
  print ( '      N            X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, fx = bernoulli_poly_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bernoulli_poly_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bernstein_poly_01_values ( n_data ):

#*****************************************************************************80
#
## bernstein_poly_01_values returns some values of the Bernstein polynomials.
#
#  Discussion:
#
#    The Bernstein polynomials are assumed to be based on [0,1].
#
#    The formula for the Bernstein polynomials is
#
#      B(N,I)(X) = [N!/(I!*(N-I)!)] * (1-X)^(N-I) * X^I
#
#    In Mathematica, the function can be evaluated by:
#
#      Binomial[n,i] * (1-x)^(n-i) * x^i
#
#  First values:
#
#    B(0,0)(X) = 1
#
#    B(1,0)(X) =      1-X
#    B(1,1)(X) =               X
#
#    B(2,0)(X) =     (1-X)^2
#    B(2,1)(X) = 2 * (1-X)   * X
#    B(2,2)(X) =               X^2
#
#    B(3,0)(X) =     (1-X)^3
#    B(3,1)(X) = 3 * (1-X)^2 * X
#    B(3,2)(X) = 3 * (1-X)   * X^2
#    B(3,3)(X) =               X^3
#
#    B(4,0)(X) =     (1-X)^4
#    B(4,1)(X) = 4 * (1-X)^3 * X
#    B(4,2)(X) = 6 * (1-X)^2 * X^2
#    B(4,3)(X) = 4 * (1-X)   * X^3
#    B(4,4)(X) =               X^4
#
#  Special values:
#
#    B(N,I)(X) has a unique maximum value at X = I/N.
#
#    B(N,I)(X) has an I-fold zero at 0 and and N-I fold zero at 1.
#
#    B(N,I)(1/2) = C(N,K) / 2^N
#
#    For a fixed X and N, the polynomials add up to 1:
#
#      Sum ( 0 <= I <= N ) B(N,I)(X) = 1
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    26 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the degree of the polynomial.
#
#    integer K, the index of the polynomial.
#
#    real X, the argument of the polynomial.
#
#    real F, the value of the polynomial B(N,K)(X).
#
  import numpy as np

  n_max = 15

  f_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.7500000000000000E+00, \
     0.2500000000000000E+00, \
     0.5625000000000000E+00, \
     0.3750000000000000E+00, \
     0.6250000000000000E-01, \
     0.4218750000000000E+00, \
     0.4218750000000000E+00, \
     0.1406250000000000E+00, \
     0.1562500000000000E-01, \
     0.3164062500000000E+00, \
     0.4218750000000000E+00, \
     0.2109375000000000E+00, \
     0.4687500000000000E-01, \
     0.3906250000000000E-02 ) )

  k_vec = np.array ( ( \
    0, \
    0, 1, \
    0, 1, 2, \
    0, 1, 2, 3, \
    0, 1, 2, 3, 4 ))

  n_vec = np.array ( ( \
    0, \
    1, 1, \
    2, 2, 2, \
    3, 3, 3, 3, \
    4, 4, 4, 4, 4 ))

  x_vec = np.array ( ( \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    k = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    k = k_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, k, x, f

def bernstein_poly_01_values_test ( ):

#*****************************************************************************80
#
## bernstein_poly_01_values_test() tests bernstein_poly_01_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    26 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'bernstein_poly_01_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  bernstein_poly_01_values stores values of Bernstein polynomials.' )
  print ( '' )
  print ( '      N       K            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, k, x, f = bernstein_poly_01_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %6d  %12f  %24.16g' % ( n, k, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bernstein_poly_01_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_i0_int_values ( n_data ):

#*****************************************************************************80
#
## bessel_i0_int_values returns some values of the Bessel I0 integral.
#
#  Discussion:
#
#    The function is defined by:
#
#      I0_int(x) = Integral ( 0 <= t <= x ) I0(t) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    30 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
      0.19531256208818052282E-02, \
     -0.39062549670565734544E-02, \
      0.62520348032546565850E-01, \
      0.12516285581366971819E+00, \
     -0.51051480879740303760E+00, \
      0.10865210970235898158E+01, \
      0.27750019054282535299E+01, \
     -0.13775208868039716639E+02, \
      0.46424372058106108576E+03, \
      0.64111867658021584522E+07, \
     -0.10414860803175857953E+08, \
      0.44758598913855743089E+08, \
     -0.11852985311558287888E+09, \
      0.31430078220715992752E+09, \
     -0.83440212900794309620E+09, \
      0.22175367579074298261E+10, \
      0.58991731842803636487E+10, \
     -0.41857073244691522147E+11, \
      0.79553885818472357663E+12, \
      0.15089715082719201025E+17 ) )

  x_vec = np.array ( ( \
       0.0019531250E+00, \
      -0.0039062500E+00, \
       0.0625000000E+00, \
       0.1250000000E+00, \
      -0.5000000000E+00, \
       1.0000000000E+00, \
       2.0000000000E+00, \
      -4.0000000000E+00, \
       8.0000000000E+00, \
      18.0000000000E+00, \
     -18.5000000000E+00, \
      20.0000000000E+00, \
     -21.0000000000E+00, \
      22.0000000000E+00, \
     -23.0000000000E+00, \
      24.0000000000E+00, \
      25.0000000000E+00, \
     -27.0000000000E+00, \
      30.0000000000E+00, \
      40.0000000000E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_i0_int_values_test ( ):

#*****************************************************************************80
#
## bessel_i0_int_values_test() tests bessel_i0_int_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    30 December 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_i0_int_values_test:' )
  print ( '  bessel_i0_int_values stores values of the Bessel I integral. of order 0.' )
  print ( '' )
  print ( '      X           int_i(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_i0_int_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_i0_int_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_i0_spherical_values ( n_data ):

#*****************************************************************************80
#
## bessel_i0_spherical_values returns some values of the Spherical Bessel function i0.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Sqrt[Pi/(2*x)] * BesselI[1/2,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    30 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    LC: QA47.A34,
#    ISBN: 0-486-61272-4.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  fx_vec = np.array ( ( \
    1.001667500198440E+00, \
    1.006680012705470E+00, \
    1.026880814507039E+00, \
    1.061089303580402E+00, \
    1.110132477734529E+00, \
    1.175201193643801E+00, \
    1.257884462843477E+00, \
    1.360215358179667E+00, \
    1.484729970750144E+00, \
    1.634541271164267E+00, \
    1.813430203923509E+00, \
    2.025956895698133E+00, \
    2.277595505698373E+00, \
    2.574897010920645E+00, \
    2.925685126512827E+00, \
    3.339291642469967E+00, \
    3.826838748926716E+00, \
    4.401577467270101E+00, \
    5.079293155726485E+00, \
    5.878791279137455E+00, \
    6.822479299281938E+00 ) )

  x_vec = np.array ( ( \
     0.1E+00, \
     0.2E+00, \
     0.4E+00, \
     0.6E+00, \
     0.8E+00, \
     1.0E+00, \
     1.2E+00, \
     1.4E+00, \
     1.6E+00, \
     1.8E+00, \
     2.0E+00, \
     2.2E+00, \
     2.4E+00, \
     2.6E+00, \
     2.8E+00, \
     3.0E+00, \
     3.2E+00, \
     3.4E+00, \
     3.6E+00, \
     3.8E+00, \
     4.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_i0_spherical_values_test ( ):

#*****************************************************************************80
#
## bessel_i0_spherical_values_test() tests bessel_i0_spherical_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    30 December 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_i0_spherical_values_test:' )
  print ( '  bessel_i0_spherical_values: values of the spherical Bessel I function. of order 0.' )
  print ( '' )
  print ( '      X        Spherical I(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_i0_spherical_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_i0_spherical_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_i0_values ( n_data ):

#*****************************************************************************80
#
## bessel_i0_values returns some values of the I0 Bessel function.
#
#  Discussion:
#
#    The modified Bessel functions In(Z) and Kn(Z) are solutions of
#    the differential equation
#
#      Z^2 W'' + Z * W' - ( Z^2 + N^2 ) * W = 0.
#
#    The modified Bessel function I0(Z) corresponds to N = 0.
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselI[0,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    26 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.1010025027795146E+01, \
     0.1040401782229341E+01, \
     0.1092045364317340E+01, \
     0.1166514922869803E+01, \
     0.1266065877752008E+01, \
     0.1393725584134064E+01, \
     0.1553395099731217E+01, \
     0.1749980639738909E+01, \
     0.1989559356618051E+01, \
     0.2279585302336067E+01, \
     0.3289839144050123E+01, \
     0.4880792585865024E+01, \
     0.7378203432225480E+01, \
     0.1130192195213633E+02, \
     0.1748117185560928E+02, \
     0.2723987182360445E+02, \
     0.6723440697647798E+02, \
     0.4275641157218048E+03, \
     0.2815716628466254E+04 ) )

  x_vec = np.array ( ( \
     0.00E+00, \
     0.20E+00, \
     0.40E+00, \
     0.60E+00, \
     0.80E+00, \
     0.10E+01, \
     0.12E+01, \
     0.14E+01, \
     0.16E+01, \
     0.18E+01, \
     0.20E+01, \
     0.25E+01, \
     0.30E+01, \
     0.35E+01, \
     0.40E+01, \
     0.45E+01, \
     0.50E+01, \
     0.60E+01, \
     0.80E+01, \
     0.10E+02  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_i0_values_test ( ):

#*****************************************************************************80
#
## bessel_i0_values_test() tests bessel_i0_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    26 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'bessel_i0_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  bessel_i0_values stores values of the Bessel I function. of order 0.' )
  print ( '' )
  print ( '      X           I(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_i0_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_i0_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_i1_spherical_values ( n_data ):

#*****************************************************************************80
#
## bessel_i1_spherical_values returns some values of the Spherical Bessel function i1.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Sqrt[Pi/(2*x)] * BesselI[3/2,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    LC: QA47.A34,
#    ISBN: 0-486-61272-4.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  fx_vec = np.array ( ( \
    0.03336667857363341E+00, \
    0.06693371456802954E+00, \
    0.1354788933285401E+00, \
    0.2072931911031093E+00, \
    0.2841280857128948E+00, \
    0.3678794411714423E+00, \
    0.4606425870674146E+00, \
    0.5647736480096238E+00, \
    0.6829590627779635E+00, \
    0.8182955028627777E+00, \
    0.9743827435800610E+00, \
    1.155432469636406E+00, \
    1.366396525527973E+00, \
    1.613118767572064E+00, \
    1.902515460838681E+00, \
    2.242790117769266E+00, \
    2.643689828630357E+00, \
    3.116811526884873E+00, \
    3.675968313148932E+00, \
    4.337627987747642E+00, \
    5.121438384183637E+00 ) )

  x_vec = np.array ( ( \
     0.1E+00, \
     0.2E+00, \
     0.4E+00, \
     0.6E+00, \
     0.8E+00, \
     1.0E+00, \
     1.2E+00, \
     1.4E+00, \
     1.6E+00, \
     1.8E+00, \
     2.0E+00, \
     2.2E+00, \
     2.4E+00, \
     2.6E+00, \
     2.8E+00, \
     3.0E+00, \
     3.2E+00, \
     3.4E+00, \
     3.6E+00, \
     3.8E+00, \
     4.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_i1_spherical_values_test ( ):

#*****************************************************************************80
#
## bessel_i1_spherical_values_test() tests bessel_i1_spherical_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 December 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_i1_spherical_values_test:' )
  print ( '  bessel_i1_spherical_values stores values of the spherical Bessel I function. of order 1.' )
  print ( '' )
  print ( '      X        Spherical I(1,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_i1_spherical_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_i1_spherical_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_i1_values ( n_data ):

#*****************************************************************************80
#
## bessel_i1_values returns some values of the I1 Bessel function.
#
#  Discussion:
#
#    The modified Bessel functions In(Z) and Kn(Z) are solutions of
#    the differential equation
#
#      Z^2 W'' + Z * W' - ( Z^2 + N^2 ) * W = 0.
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselI[1,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
     0.0000000000000000E+00, \
     0.1005008340281251E+00, \
     0.2040267557335706E+00, \
     0.3137040256049221E+00, \
     0.4328648026206398E+00, \
     0.5651591039924850E+00, \
     0.7146779415526431E+00, \
     0.8860919814143274E+00, \
     0.1084810635129880E+01, \
     0.1317167230391899E+01, \
     0.1590636854637329E+01, \
     0.2516716245288698E+01, \
     0.3953370217402609E+01, \
     0.6205834922258365E+01, \
     0.9759465153704450E+01, \
     0.1538922275373592E+02, \
     0.2433564214245053E+02, \
     0.6134193677764024E+02, \
     0.3998731367825601E+03, \
     0.2670988303701255E+04 ) )

  x_vec = np.array ( ( \
     0.00E+00, \
     0.20E+00, \
     0.40E+00, \
     0.60E+00, \
     0.80E+00, \
     0.10E+01, \
     0.12E+01, \
     0.14E+01, \
     0.16E+01, \
     0.18E+01, \
     0.20E+01, \
     0.25E+01, \
     0.30E+01, \
     0.35E+01, \
     0.40E+01, \
     0.45E+01, \
     0.50E+01, \
     0.60E+01, \
     0.80E+01, \
     0.10E+02  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_i1_values_test ( ):

#*****************************************************************************80
#
## bessel_i1_values_test() tests bessel_i1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'bessel_i1_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  bessel_i1_values stores values of the Bessel I function. of order 1.' )
  print ( '' )
  print ( '      X           I(1,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_i1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_i1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_in_values ( n_data ):

#*****************************************************************************80
#
## bessel_in_values returns some values of the In Bessel function.
#
#  Discussion:
#
#    The modified Bessel functions In(Z) and Kn(Z) are solutions of
#    the differential equation
#
#      Z^2 W'' + Z * W' - ( Z^2 + N^2 ) * W = 0.
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselI[n,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    02 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer NU, the order of the function.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 28

  fx_vec = np.array ( ( \
     0.5016687513894678E-02, \
     0.1357476697670383E+00, \
     0.6889484476987382E+00, \
     0.1276466147819164E+01, \
     0.2245212440929951E+01, \
     0.1750561496662424E+02, \
     0.2281518967726004E+04, \
     0.3931278522104076E+08, \
     0.2216842492433190E-01, \
     0.2127399592398527E+00, \
     0.1033115016915114E+02, \
     0.1758380716610853E+04, \
     0.2677764138883941E+21, \
     0.2714631559569719E-03, \
     0.9825679323131702E-02, \
     0.2157974547322546E+01, \
     0.7771882864032600E+03, \
     0.2278548307911282E+21, \
     0.2752948039836874E-09, \
     0.3016963879350684E-06, \
     0.4580044419176051E-02, \
     0.2189170616372337E+02, \
     0.1071597159477637E+21, \
     0.3966835985819020E-24, \
     0.4310560576109548E-18, \
     0.5024239357971806E-10, \
     0.1250799735644948E-03, \
     0.5442008402752998E+19 ) )

  nu_vec = np.array ( ( \
     2,  2,  2,  2, \
     2,  2,  2,  2, \
     3,  3,  3,  3, \
     3,  5,  5,  5, \
     5,  5, 10, 10, \
    10, 10, 10, 20, \
    20, 20, 20, 20 ))

  x_vec = np.array ( ( \
     0.2E+00, \
      1.0E+00, \
      2.0E+00, \
      2.5E+00, \
      3.0E+00, \
      5.0E+00, \
     10.0E+00, \
     20.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    nu = 0
    x = 0.0
    fx = 0.0
  else:
    nu = nu_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, nu, x, fx

def bessel_in_values_test ( ):

#*****************************************************************************80
#
## bessel_in_values_test() tests bessel_in_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    02 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_in_values_test:' )
  print ( '  bessel_in_values stores values of the Bessel I function. of order NU.' )
  print ( '' )
  print ( '      NU  X           I(NU,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, nu, x, fx = bessel_in_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4d  %12f  %24.16g' % ( nu, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_in_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_ix_values ( n_data ):

#*****************************************************************************80
#
## bessel_ix_values returns some values of the Ix Bessel function.
#
#  Discussion:
#
#    This set of data considers the less common case in which the
#    index of the Bessel function In is actually not an integer.
#    We may suggest this case by occasionally replacing the symbol
#    "In" by "Ix".
#
#    The modified Bessel functions In(Z) and Kn(Z) are solutions of
#    the differential equation
#
#      Z^2 W'' + Z * W' - ( Z^2 + N^2 ) * W = 0.
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselI[n,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    06 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real NU, the order of the function.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 28

  fx_vec = np.array ( ( \
    0.3592084175833614E+00,  \
    0.9376748882454876E+00,  \
    2.046236863089055E+00,   \
    3.053093538196718E+00,   \
    4.614822903407601E+00,   \
    26.47754749755907E+00,   \
    2778.784603874571E+00,   \
    4.327974627242893E+07,   \
    0.2935253263474798E+00,  \
    1.099473188633110E+00,   \
    21.18444226479414E+00,   \
    2500.906154942118E+00,   \
    2.866653715931464E+20,   \
    0.05709890920304825E+00, \
    0.3970270801393905E+00,  \
    13.76688213868258E+00,   \
    2028.512757391936E+00,   \
    2.753157630035402E+20,   \
    0.4139416015642352E+00,  \
    1.340196758982897E+00,   \
    22.85715510364670E+00,   \
    2593.006763432002E+00,   \
    2.886630075077766E+20,   \
    0.03590910483251082E+00, \
    0.2931108636266483E+00,  \
    11.99397010023068E+00,   \
    1894.575731562383E+00,   \
    2.716911375760483E+20 ) )

  nu_vec = np.array ( ( \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    1.50E+00, \
    1.50E+00, \
    1.50E+00, \
    1.50E+00, \
    1.50E+00, \
    2.50E+00, \
    2.50E+00, \
    2.50E+00, \
    2.50E+00, \
    2.50E+00, \
    1.25E+00, \
    1.25E+00, \
    1.25E+00, \
    1.25E+00, \
    1.25E+00, \
    2.75E+00, \
    2.75E+00, \
    2.75E+00, \
    2.75E+00, \
    2.75E+00 ))

  x_vec = np.array ( ( \
      0.2E+00, \
      1.0E+00, \
      2.0E+00, \
      2.5E+00, \
      3.0E+00, \
      5.0E+00, \
     10.0E+00, \
     20.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    nu = 0
    x = 0.0
    fx = 0.0
  else:
    nu = nu_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, nu, x, fx

def bessel_ix_values_test ( ):

#*****************************************************************************80
#
## bessel_ix_values_test() tests bessel_ix_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    06 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_ix_values_test:' )
  print ( '  bessel_ix_values stores values of the Bessel I function. of real order NU.' )
  print ( '' )
  print ( '      NU          X           I(NU,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, nu, x, fx = bessel_ix_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( nu, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_ix_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_j0_int_values ( n_data ):

#*****************************************************************************80
#
## bessel_j0_int_values returns some values of the Bessel J0 integral.
#
#  Discussion:
#
#    The function is defined by:
#
#      J0_int(x) = Integral ( 0 <= t <= x ) J0(t) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    11 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
      0.97656242238978822427E-03, \
      0.39062450329491108875E-02, \
     -0.62479657927917933620E-01, \
      0.12483733492120479139E+00, \
     -0.48968050664604505505E+00, \
      0.91973041008976023931E+00, \
     -0.14257702931970265690E+01, \
      0.10247341594606064818E+01, \
     -0.12107468348304501655E+01, \
      0.11008652032736190799E+01, \
     -0.10060334829904124192E+01, \
      0.81330572662485953519E+00, \
     -0.10583788214211277585E+01, \
      0.87101492116545875169E+00, \
     -0.88424908882547488420E+00, \
      0.11257761503599914603E+01, \
     -0.90141212258183461184E+00, \
      0.91441344369647797803E+00, \
     -0.94482281938334394886E+00, \
      0.92266255696016607257E+00 ) )

  x_vec = np.array ( ( \
       0.0009765625E+00, \
       0.0039062500E+00, \
      -0.0625000000E+00, \
       0.1250000000E+00, \
      -0.5000000000E+00, \
       1.0000000000E+00, \
      -2.0000000000E+00, \
       4.0000000000E+00, \
      -8.0000000000E+00, \
      16.0000000000E+00, \
     -16.5000000000E+00, \
      18.0000000000E+00, \
     -20.0000000000E+00, \
      25.0000000000E+00, \
     -30.0000000000E+00, \
      40.0000000000E+00, \
     -50.0000000000E+00, \
      75.0000000000E+00, \
     -80.0000000000E+00, \
     100.0000000000E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_j0_int_values_test ( ):

#*****************************************************************************80
#
## bessel_j0_int_values_test() tests bessel_j0_int_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    06 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_j0_int_values_test:' )
  print ( '  bessel_j0_int_values stores values of the Bessel J integral. of order 0.' )
  print ( '' )
  print ( '      X           int_j(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_j0_int_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_j0_int_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_j0_spherical_values ( n_data ):

#*****************************************************************************80
#
## bessel_j0_spherical_values returns some values of the Spherical Bessel function j0.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Sqrt[Pi/(2*x)] * BesselJ[1/2,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    08 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  fx_vec = np.array ( ( \
      0.9983341664682815E+00, \
      0.9933466539753061E+00, \
      0.9735458557716262E+00, \
      0.9410707889917256E+00, \
      0.8966951136244035E+00, \
      0.8414709848078965E+00, \
      0.7766992383060220E+00, \
      0.7038926642774716E+00, \
      0.6247335019009407E+00, \
      0.5410264615989973E+00, \
      0.4546487134128408E+00, \
      0.3674983653725410E+00, \
      0.2814429918963129E+00, \
      0.1982697583928709E+00, \
      0.1196386250556803E+00, \
      0.4704000268662241E-01, \
     -0.1824191982111872E-01, \
     -0.7515914765495039E-01, \
     -0.1229223453596812E+00, \
     -0.1610152344586103E+00, \
     -0.1892006238269821E+00 ) )

  x_vec = np.array ( ( \
     0.1E+00, \
     0.2E+00, \
     0.4E+00, \
     0.6E+00, \
     0.8E+00, \
     1.0E+00, \
     1.2E+00, \
     1.4E+00, \
     1.6E+00, \
     1.8E+00, \
     2.0E+00, \
     2.2E+00, \
     2.4E+00, \
     2.6E+00, \
     2.8E+00, \
     3.0E+00, \
     3.2E+00, \
     3.4E+00, \
     3.6E+00, \
     3.8E+00, \
     4.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_j0_spherical_values_test ( ):

#*****************************************************************************80
#
## bessel_j0_spherical_values_test() tests bessel_j0_spherical_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    08 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_j0_spherical_values_test:' )
  print ( '  bessel_j0_spherical_values stores values of the spherical Bessel J function. of order 0.' )
  print ( '' )
  print ( '      X        Spherical J(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_j0_spherical_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_j0_spherical_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_j0_values ( n_data ):

#*****************************************************************************80
#
## bessel_j0_values returns some values of the J0 Bessel function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselJ[0,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 September 2004
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  n_max = 21;

  fx_vec = [ \
 ];

  x_vec = [ \
 ];
  import numpy as np

  n_max = 21

  fx_vec = np.array ( ( \
     -0.1775967713143383E+00, \
     -0.3971498098638474E+00, \
     -0.2600519549019334E+00, \
      0.2238907791412357E+00, \
      0.7651976865579666E+00, \
      0.1000000000000000E+01, \
      0.7651976865579666E+00, \
      0.2238907791412357E+00, \
     -0.2600519549019334E+00, \
     -0.3971498098638474E+00, \
     -0.1775967713143383E+00, \
      0.1506452572509969E+00, \
      0.3000792705195556E+00, \
      0.1716508071375539E+00, \
     -0.9033361118287613E-01, \
     -0.2459357644513483E+00, \
     -0.1711903004071961E+00, \
      0.4768931079683354E-01, \
      0.2069261023770678E+00, \
      0.1710734761104587E+00, \
     -0.1422447282678077E-01 ) )

  x_vec = np.array ( ( \
     -5.0E+00, \
     -4.0E+00, \
     -3.0E+00, \
     -2.0E+00, \
     -1.0E+00, \
      0.0E+00, \
      1.0E+00, \
      2.0E+00, \
      3.0E+00, \
      4.0E+00, \
      5.0E+00, \
      6.0E+00, \
      7.0E+00, \
      8.0E+00, \
      9.0E+00, \
     10.0E+00, \
     11.0E+00, \
     12.0E+00, \
     13.0E+00, \
     14.0E+00, \
     15.0E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_j0_values_test ( ):

#*****************************************************************************80
#
## bessel_j0_values_test() tests bessel_j0_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 December 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_j0_values_test:' )
  print ( '  bessel_j0_values stores values of the Bessel J function. of order 0.' )
  print ( '' )
  print ( '      X           J(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_j0_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_j0_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_j0_zero_values ( n_data ):

#*****************************************************************************80
#
## bessel_j0_values returns some zeros of the J0 Bessel function.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    04 January 2016
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer K, the index of the zero.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 30

  fx_vec = np.array ( [ \
    2.40482555769577276862163187933E+00, \
    5.52007811028631064959660411281E+00, \
    8.65372791291101221695419871266E+00, \
    11.7915344390142816137430449119E+00, \
    14.9309177084877859477625939974E+00, \
    18.0710639679109225431478829756E+00, \
    21.2116366298792589590783933505E+00, \
    24.3524715307493027370579447632E+00, \
    27.4934791320402547958772882346E+00, \
    30.6346064684319751175495789269E+00, \
    33.7758202135735686842385463467E+00, \
    36.9170983536640439797694930633E+00, \
    40.0584257646282392947993073740E+00, \
    43.1997917131767303575240727287E+00, \
    46.3411883716618140186857888791E+00, \
    49.4826098973978171736027615332E+00, \
    52.6240518411149960292512853804E+00, \
    55.7655107550199793116834927735E+00, \
    58.9069839260809421328344066346E+00, \
    62.0484691902271698828525002646E+00, \
    65.1899648002068604406360337425E+00, \
    68.3314693298567982709923038400E+00, \
    71.4729816035937328250630738561E+00, \
    74.6145006437018378838205404693E+00, \
    77.7560256303880550377393718912E+00, \
    80.8975558711376278637721434909E+00, \
    84.0390907769381901578796383480E+00, \
    87.1806298436411536512618050690E+00, \
    90.3221726372104800557177667775E+00, \
    93.4637187819447741711905915439E+00 ] )

  k_vec = np.array ( [ \
     1, \
     2, \
     3, \
     4, \
     5, \
     6, \
     7, \
     8, \
     9, \
    10, \
    11, \
    12, \
    13, \
    14, \
    15, \
    16, \
    17, \
    18, \
    19, \
    20, \
    21, \
    22, \
    23, \
    24, \
    25, \
    26, \
    27, \
    28, \
    29, \
    30  ] )

  if ( n_data < 0 ):
    n_data = 0

  n_data = n_data + 1

  if ( n_max < n_data ):
    n_data = 0
    k = 0
    fx = 0.0
  else:
    k = k_vec[n_data-1]
    fx = fx_vec[n_data-1]

  return n_data, k, fx

def bessel_j0_zero_values_test ( ):

#*****************************************************************************80
#
## bessel_j0_zero_values_test() tests bessel_j0_zero_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    04 January 2016
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_j0_zero_values_test:' )
  print ( '  bessel_j0_zero_values stores zeros of' )
  print ( '  the Bessel J0 function.' )
  print ( '' )
  print ( '      K            X(K)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, k, fx = bessel_j0_zero_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %24.16g' % ( k, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_j0_zero_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_j1_spherical_values ( n_data ):

#*****************************************************************************80
#
## bessel_j1_spherical_values returns some values of the Spherical Bessel function j1.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Sqrt[Pi/(2*x)] * BesselJ[3/2,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    10 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  fx_vec = np.array ( ( \
     0.3330001190255757E-01, \
     0.6640038067032223E-01, \
     0.1312121544218529E+00, \
     0.1928919568034122E+00, \
     0.2499855053465475E+00, \
     0.3011686789397568E+00, \
     0.3452845698577903E+00, \
     0.3813753724123076E+00, \
     0.4087081401263934E+00, \
     0.4267936423844913E+00, \
     0.4353977749799916E+00, \
     0.4345452193763121E+00, \
     0.4245152947656493E+00, \
     0.4058301968314685E+00, \
     0.3792360591872637E+00, \
     0.3456774997623560E+00, \
     0.3062665174917607E+00, \
     0.2622467779189737E+00, \
     0.2149544641595738E+00, \
     0.1657769677515280E+00, \
     0.1161107492591575E+00 ) )

  x_vec = np.array ( ( \
     0.1E+00, \
     0.2E+00, \
     0.4E+00, \
     0.6E+00, \
     0.8E+00, \
     1.0E+00, \
     1.2E+00, \
     1.4E+00, \
     1.6E+00, \
     1.8E+00, \
     2.0E+00, \
     2.2E+00, \
     2.4E+00, \
     2.6E+00, \
     2.8E+00, \
     3.0E+00, \
     3.2E+00, \
     3.4E+00, \
     3.6E+00, \
     3.8E+00, \
     4.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_j1_spherical_values_test ( ):

#*****************************************************************************80
#
## bessel_j1_spherical_values_test() tests bessel_j1_spherical_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    10 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_j1_spherical_values_test:' )
  print ( '  bessel_j1_spherical_values stores values of the spherical Bessel J function. of order 1.' )
  print ( '' )
  print ( '      X        Spherical J(1,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_j1_spherical_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_j1_spherical_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_j1_values ( n_data ):

#*****************************************************************************80
#
## bessel_j1_values returns some values of the J1 Bessel function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselJ[1,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  fx_vec = np.array ( ( \
      0.3275791375914652E+00, \
      0.6604332802354914E-01, \
     -0.3390589585259365E+00, \
     -0.5767248077568734E+00, \
     -0.4400505857449335E+00, \
      0.0000000000000000E+00, \
      0.4400505857449335E+00, \
      0.5767248077568734E+00, \
      0.3390589585259365E+00, \
     -0.6604332802354914E-01, \
     -0.3275791375914652E+00, \
     -0.2766838581275656E+00, \
     -0.4682823482345833E-02, \
      0.2346363468539146E+00, \
      0.2453117865733253E+00, \
      0.4347274616886144E-01, \
     -0.1767852989567215E+00, \
     -0.2234471044906276E+00, \
     -0.7031805212177837E-01, \
      0.1333751546987933E+00, \
      0.2051040386135228E+00 ) )

  x_vec = np.array ( ( \
     -5.0E+00, \
     -4.0E+00, \
     -3.0E+00, \
     -2.0E+00, \
     -1.0E+00, \
      0.0E+00, \
      1.0E+00, \
      2.0E+00, \
      3.0E+00, \
      4.0E+00, \
      5.0E+00, \
      6.0E+00, \
      7.0E+00, \
      8.0E+00, \
      9.0E+00, \
     10.0E+00, \
     11.0E+00, \
     12.0E+00, \
     13.0E+00, \
     14.0E+00, \
     15.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_j1_values_test ( ):

#*****************************************************************************80
#
## bessel_j1_values_test() tests bessel_j1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 December 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_j1_values_test:' )
  print ( '  bessel_j1_values stores values of the Bessel J function. of order 1.' )
  print ( '' )
  print ( '      X           J(1,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_j1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_j1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_jn_values ( n_data ):

#*****************************************************************************80
#
## bessel_jn_values returns some values of the Jn Bessel function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselJ[n,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    10 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer NU, the order of the function.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
      0.1149034849319005E+00, \
      0.3528340286156377E+00, \
      0.4656511627775222E-01, \
      0.2546303136851206E+00, \
     -0.5971280079425882E-01, \
      0.2497577302112344E-03, \
      0.7039629755871685E-02, \
      0.2611405461201701E+00, \
     -0.2340615281867936E+00, \
     -0.8140024769656964E-01, \
      0.2630615123687453E-09, \
      0.2515386282716737E-06, \
      0.1467802647310474E-02, \
      0.2074861066333589E+00, \
     -0.1138478491494694E+00, \
      0.3873503008524658E-24, \
      0.3918972805090754E-18, \
      0.2770330052128942E-10, \
      0.1151336924781340E-04, \
     -0.1167043527595797E+00 ) )

  nu_vec = np.array ( ( \
     2,  2,  2,  2, \
     2,  5,  5,  5, \
     5,  5, 10, 10, \
    10, 10, 10, 20, \
    20, 20, 20, 20 ))

  x_vec = np.array ( ( \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    nu = 0
    x = 0.0
    fx = 0.0
  else:
    nu = nu_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, nu, x, fx

def bessel_jn_values_test ( ):

#*****************************************************************************80
#
## bessel_jn_values_test() tests bessel_jn_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    10 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_jn_values_test:' )
  print ( '  bessel_jn_values stores values of the Bessel J function. of order NU.' )
  print ( '' )
  print ( '      NU  X           J(NU,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, nu, x, fx = bessel_jn_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4d  %12f  %24.16g' % ( nu, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_jn_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_j_spherical_values ( n_data ):

#*****************************************************************************80
#
## bessel_j_spherical_values returns values of the Spherical Bessel function j.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Sqrt[Pi/(2*x)] * BesselJ[n+1/2,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 January 216
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the index of the function.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 22

  fx_vec = np.array ( [ \
     0.8689780717709105E+00, \
     0.2776712616989048E+00, \
     0.05147914933043151E+00, \
     0.006743927971987495E+00, \
     0.0006838294584220406E+00, \
     0.00005658597917091951E+00, \
     3.955923765931341E-06, \
     2.394450910776484E-07, \
     1.277940110150618E-08, \
     6.099572379372921E-10, \
     2.633096568558721E-11, \
    -0.05440211108893698E+00, \
     0.07846694179875155E+00, \
     0.07794219362856245E+00, \
    -0.03949584498447032E+00, \
    -0.1055892851176917E+00, \
    -0.05553451162145218E+00, \
     0.04450132233409427E+00, \
     0.1133862306557747E+00, \
     0.1255780236495678E+00, \
     0.1000964095484906E+00, \
     0.06460515449256426E+00 ] )

  n_vec = np.array ( [ \
     0, \
     1, \
     2, \
     3, \
     4, \
     5, \
     6, \
     7, \
     8, \
     9, \
    10, \
     0, \
     1, \
     2, \
     3, \
     4, \
     5, \
     6, \
     7, \
     8, \
     9, \
    10 ] )

  x_vec = np.array ( [ \
     0.9050000000000000E+00, \
     0.9050000000000000E+00, \
     0.9050000000000000E+00, \
     0.9050000000000000E+00, \
     0.9050000000000000E+00, \
     0.9050000000000000E+00, \
     0.9050000000000000E+00, \
     0.9050000000000000E+00, \
     0.9050000000000000E+00, \
     0.9050000000000000E+00, \
     0.9050000000000000E+00, \
    10.00000000000000E+00, \
    10.00000000000000E+00, \
    10.00000000000000E+00, \
    10.00000000000000E+00, \
    10.00000000000000E+00, \
    10.00000000000000E+00, \
    10.00000000000000E+00, \
    10.00000000000000E+00, \
    10.00000000000000E+00, \
    10.00000000000000E+00, \
    10.00000000000000E+00 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    fx = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, fx

def bessel_j_spherical_values_test ( ):

#*****************************************************************************80
#
## bessel_j_spherical_values_test() tests bessel_j_spherical_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 January 2016
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_j_spherical_values_test:' )
  print ( '  bessel_j_spherical_values stores values of the spherical Bessel J function. of order N.' )
  print ( '' )
  print ( '     N      X        Spherical J(N,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, fx = bessel_j_spherical_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %2d  %12f  %24.16g' % ( n, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_j_spherical_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_jx_values ( n_data ):

#*****************************************************************************80
#
## bessel_jx_values returns some values of the Jx Bessel function.
#
#  Discussion:
#
#    This set of data considers the less common case in which the
#    index of the Bessel function Jn is actually not an integer.
#    We may suggest this case by occasionally replacing the symbol
#    "Jn" by "Jx".
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselJ[n,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    11 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real NU, the order of the function.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 28

  fx_vec = np.array ( ( \
        0.3544507442114011E+00, \
        0.6713967071418031E+00, \
        0.5130161365618278E+00, \
        0.3020049060623657E+00, \
        0.06500818287737578E+00, \
       -0.3421679847981618E+00, \
       -0.1372637357550505E+00, \
        0.1628807638550299E+00, \
        0.2402978391234270E+00, \
        0.4912937786871623E+00, \
       -0.1696513061447408E+00, \
        0.1979824927558931E+00, \
       -0.1094768729883180E+00, \
        0.04949681022847794E+00, \
        0.2239245314689158E+00, \
        0.2403772011113174E+00, \
        0.1966584835818184E+00, \
        0.02303721950962553E+00, \
        0.3314145508558904E+00, \
        0.5461734240402840E+00, \
       -0.2616584152094124E+00, \
        0.1296035513791289E+00, \
       -0.1117432171933552E+00, \
        0.03142623570527935E+00, \
        0.1717922192746527E+00, \
        0.3126634069544786E+00, \
        0.1340289119304364E+00, \
        0.06235967135106445E+00 ) )

  nu_vec = np.array ( ( \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    1.50E+00, \
    1.50E+00, \
    1.50E+00, \
    1.50E+00, \
    1.50E+00, \
    2.50E+00, \
    2.50E+00, \
    2.50E+00, \
    2.50E+00, \
    2.50E+00, \
    1.25E+00, \
    1.25E+00, \
    1.25E+00, \
    1.25E+00, \
    1.25E+00, \
    2.75E+00, \
    2.75E+00, \
    2.75E+00, \
    2.75E+00, \
    2.75E+00 ))

  x_vec = np.array ( ( \
      0.2E+00, \
      1.0E+00, \
      2.0E+00, \
      2.5E+00, \
      3.0E+00, \
      5.0E+00, \
     10.0E+00, \
     20.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    nu = 0
    x = 0.0
    fx = 0.0
  else:
    nu = nu_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, nu, x, fx

def bessel_jx_values_test ( ):

#*****************************************************************************80
#
## bessel_jx_values_test() tests bessel_jx_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    11 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_jx_values_test:' )
  print ( '  bessel_jx_values stores values of the Bessel J function. of real order NU.' )
  print ( '' )
  print ( '      NU          X           J(NU,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, nu, x, fx = bessel_jx_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( nu, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_jx_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_k0_int_values ( n_data ):

#*****************************************************************************80
#
## bessel_k0_int_values returns some values of the Bessel K0 integral.
#
#  Discussion:
#
#    The function is defined by:
#
#      K0_int(x) = Integral ( 0 <= t <= x ) K0(t) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    11 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#      
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
     0.78587929563466784589E-02, \
     0.26019991617330578111E-01, \
     0.24311842237541167904E+00, \
     0.39999633750480508861E+00, \
     0.92710252093114907345E+00, \
     0.12425098486237782662E+01, \
     0.14736757343168286825E+01, \
     0.15606495706051741364E+01, \
     0.15673873907283660493E+01, \
     0.15696345532693743714E+01, \
     0.15701153443250786355E+01, \
     0.15706574852894436220E+01, \
     0.15707793116159788598E+01, \
     0.15707942066465767196E+01, \
     0.15707962315469192247E+01, \
     0.15707963262340149876E+01, \
     0.15707963267948756308E+01, \
     0.15707963267948966192E+01, \
     0.15707963267948966192E+01, \
     0.15707963267948966192E+01 ) )

  x_vec = np.array ( ( \
       0.0009765625E+00, \
       0.0039062500E+00, \
       0.0625000000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       2.0000000000E+00, \
       4.0000000000E+00, \
       5.0000000000E+00, \
       6.0000000000E+00, \
       6.5000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      12.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00, \
      80.0000000000E+00, \
     100.0000000000E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_k0_int_values_test ( ):

#*****************************************************************************80
#
## bessel_k0_int_values_test() tests bessel_k0_int_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    11 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_k0_int_values_test:' )
  print ( '  bessel_k0_int_values stores values of the Bessel K integral. of order 0.' )
  print ( '' )
  print ( '      X           int_k(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_k0_int_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_k0_int_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_k0_values ( n_data ):

#*****************************************************************************80
#
## bessel_k0_values returns some values of the K0 Bessel function.
#
#  Discussion:
#
#    The modified Bessel functions In(Z) and Kn(Z) are solutions of
#    the differential equation
#
#      Z^2 W'' + Z * W' - ( Z^2 + N^2 ) * W = 0.
#
#    The modified Bessel function K0(Z) corresponds to N = 0.
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselK[0,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    28 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
     0.2427069024702017E+01, \
     0.1752703855528146E+01, \
     0.1114529134524434E+01, \
     0.7775220919047293E+00, \
     0.5653471052658957E+00, \
     0.4210244382407083E+00, \
     0.3185082202865936E+00, \
     0.2436550611815419E+00, \
     0.1879547519693323E+00, \
     0.1459314004898280E+00, \
     0.1138938727495334E+00, \
     0.6234755320036619E-01, \
     0.3473950438627925E-01, \
     0.1959889717036849E-01, \
     0.1115967608585302E-01, \
     0.6399857243233975E-02, \
     0.3691098334042594E-02, \
     0.1243994328013123E-02, \
     0.1464707052228154E-03, \
     0.1778006231616765E-04 ) )

  x_vec = np.array ( ( \
      0.1E+00, \
      0.2E+00, \
      0.4E+00, \
      0.6E+00, \
      0.8E+00, \
      1.0E+00, \
      1.2E+00, \
      1.4E+00, \
      1.6E+00, \
      1.8E+00, \
      2.0E+00, \
      2.5E+00, \
      3.0E+00, \
      3.5E+00, \
      4.0E+00, \
      4.5E+00, \
      5.0E+00, \
      6.0E+00, \
      8.0E+00, \
     10.0E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_k0_values_test ( ):

#*****************************************************************************80
#
## bessel_k0_values_test() tests bessel_k0_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    28 December 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_k0_values_test:' )
  print ( '  bessel_k0_values stores values of the Bessel K function. of order 0.' )
  print ( '' )
  print ( '      X           K(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_k0_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_k0_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_k1_values ( n_data ):

#*****************************************************************************80
#
## bessel_k1_values returns some values of the K1 Bessel function.
#
#  Discussion:
#
#    The modified Bessel functions In(Z) and Kn(Z) are solutions of
#    the differential equation
#
#      Z^2 W'' + Z * W' - ( Z^2 + N^2 ) * W = 0.
#
#    The modified Bessel function K1(Z) corresponds to N = 1.
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselK[1,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    28 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
     0.9853844780870606E+01, \
     0.4775972543220472E+01, \
     0.2184354424732687E+01, \
     0.1302834939763502E+01, \
     0.8617816344721803E+00, \
     0.6019072301972346E+00, \
     0.4345923910607150E+00, \
     0.3208359022298758E+00, \
     0.2406339113576119E+00, \
     0.1826230998017470E+00, \
     0.1398658818165224E+00, \
     0.7389081634774706E-01, \
     0.4015643112819418E-01, \
     0.2223939292592383E-01, \
     0.1248349888726843E-01, \
     0.7078094908968090E-02, \
     0.4044613445452164E-02, \
     0.1343919717735509E-02, \
     0.1553692118050011E-03, \
     0.1864877345382558E-04 ) )

  x_vec = np.array ( ( \
      0.1E+00, \
      0.2E+00, \
      0.4E+00, \
      0.6E+00, \
      0.8E+00, \
      1.0E+00, \
      1.2E+00, \
      1.4E+00, \
      1.6E+00, \
      1.8E+00, \
      2.0E+00, \
      2.5E+00, \
      3.0E+00, \
      3.5E+00, \
      4.0E+00, \
      4.5E+00, \
      5.0E+00, \
      6.0E+00, \
      8.0E+00, \
     10.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_k1_values_test ( ):

#*****************************************************************************80
#
## bessel_k1_values_test() tests bessel_k1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    28 December 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_k1_values_test:' )
  print ( '  bessel_k1_values stores values of the Bessel K function. of order 1.' )
  print ( '' )
  print ( '      X           K(1,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_k1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_k1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_kn_values ( n_data ):

#*****************************************************************************80
#
## bessel_kn_values returns some values of the Kn Bessel function.
#
#  Discussion:
#
#    The modified Bessel functions In(Z) and Kn(Z) are solutions of
#    the differential equation
#
#      Z^2 * W'' + Z * W' - ( Z^2 + N^2 ) * W = 0.
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselK[n,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    11 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer NU, the order of the function.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 28

  fx_vec = np.array ( ( \
     0.4951242928773287E+02, \
     0.1624838898635177E+01, \
     0.2537597545660559E+00, \
     0.1214602062785638E+00, \
     0.6151045847174204E-01, \
     0.5308943712223460E-02, \
     0.2150981700693277E-04, \
     0.6329543612292228E-09, \
     0.7101262824737945E+01, \
     0.6473853909486342E+00, \
     0.8291768415230932E-02, \
     0.2725270025659869E-04, \
     0.3727936773826211E-22, \
     0.3609605896012407E+03, \
     0.9431049100596467E+01, \
     0.3270627371203186E-01, \
     0.5754184998531228E-04, \
     0.4367182254100986E-22, \
     0.1807132899010295E+09, \
     0.1624824039795591E+06, \
     0.9758562829177810E+01, \
     0.1614255300390670E-02, \
     0.9150988209987996E-22, \
     0.6294369360424535E+23, \
     0.5770856852700241E+17, \
     0.4827000520621485E+09, \
     0.1787442782077055E+03, \
     0.1706148379722035E-20 ) )

  nu_vec = np.array ( ( \
     2,  2,  2,  2, \
     2,  2,  2,  2, \
     3,  3,  3,  3, \
     3,  5,  5,  5, \
     5,  5, 10, 10, \
    10, 10, 10, 20, \
    20, 20, 20, 20 ))

  x_vec = np.array ( ( \
      0.2E+00, \
      1.0E+00, \
      2.0E+00, \
      2.5E+00, \
      3.0E+00, \
      5.0E+00, \
     10.0E+00, \
     20.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    nu = 0
    x = 0.0
    fx = 0.0
  else:
    nu = nu_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, nu, x, fx

def bessel_kn_values_test ( ):

#*****************************************************************************80
#
## bessel_kn_values_test() tests bessel_kn_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    11 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_kn_values_test:' )
  print ( '  bessel_kn_values stores values of the Bessel K function. of order NU.' )
  print ( '' )
  print ( '      NU  X           K(NU,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, nu, x, fx = bessel_kn_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4d  %12f  %24.16g' % ( nu, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_kn_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_kx_values ( n_data ):

#*****************************************************************************80
#
## bessel_kx_values returns some values of the Kx Bessel function.
#
#  Discussion:
#
#    This set of data considers the less common case in which the
#    index of the Bessel function Kn is actually not an integer.
#    We may suggest this case by occasionally replacing the symbol
#    "Kn" by "Kx".
#
#    The modified Bessel functions In(Z) and Kn(Z) are solutions of
#    the differential equation
#
#      Z^2 W'' + Z * W' - ( Z^2 + N^2 ) * W = 0.
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselK[n,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    12 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real NU, the order of the function.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 28

  fx_vec = np.array ( ( \
       2.294489339798475E+00, \
       0.4610685044478946E+00, \
       0.1199377719680614E+00, \
       0.06506594315400999E+00, \
       0.03602598513176459E+00, \
       0.003776613374642883E+00, \
       0.00001799347809370518E+00, \
       5.776373974707445E-10, \
       0.9221370088957891E+00, \
       0.1799066579520922E+00, \
       0.004531936049571459E+00, \
       0.00001979282590307570E+00, \
       3.486992497366216E-23, \
       3.227479531135262E+00, \
       0.3897977588961997E+00, \
       0.006495775004385758E+00, \
       0.00002393132586462789E+00, \
       3.627839645299048E-23, \
       0.7311451879202114E+00, \
       0.1567475478393932E+00, \
       0.004257389528177461E+00, \
       0.00001915541065869563E+00, \
       3.463337593569306E-23, \
       4.731184839919541E+00, \
       0.4976876225514758E+00, \
       0.007300864610941163E+00, \
       0.00002546421294106458E+00, \
       3.675275677913656E-23 ) )

  nu_vec = np.array ( ( \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    1.50E+00, \
    1.50E+00, \
    1.50E+00, \
    1.50E+00, \
    1.50E+00, \
    2.50E+00, \
    2.50E+00, \
    2.50E+00, \
    2.50E+00, \
    2.50E+00, \
    1.25E+00, \
    1.25E+00, \
    1.25E+00, \
    1.25E+00, \
    1.25E+00, \
    2.75E+00, \
    2.75E+00, \
    2.75E+00, \
    2.75E+00, \
    2.75E+00 ))

  x_vec = np.array ( ( \
      0.2E+00, \
      1.0E+00, \
      2.0E+00, \
      2.5E+00, \
      3.0E+00, \
      5.0E+00, \
     10.0E+00, \
     20.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    nu = 0
    x = 0.0
    fx = 0.0
  else:
    nu = nu_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, nu, x, fx

def bessel_kx_values_test ( ):

#*****************************************************************************80
#
## bessel_kx_values_test() tests bessel_kx_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    12 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_kx_values_test:' )
  print ( '  bessel_kx_values stores values of the Bessel K function. of real order NU.' )
  print ( '' )
  print ( '      NU          X           K(NU,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, nu, x, fx = bessel_kx_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( nu, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_kx_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_y0_int_values ( n_data ):

#*****************************************************************************80
#
## bessel_y0_int_values returns some values of the Bessel Y0 integral.
#
#  Discussion:
#
#    The function is defined by:
#
#      Y0_int(x) = Integral ( 0 <= t <= x ) Y0(t) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    12 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
     -0.91442642860172110926E-02, \
     -0.29682047390397591290E-01, \
     -0.25391431276585388961E+00, \
     -0.56179545591464028187E+00, \
     -0.63706937660742309754E+00, \
     -0.28219285008510084123E+00, \
      0.38366964785312561103E+00, \
     -0.12595061285798929390E+00, \
      0.24129031832266684828E+00, \
      0.17138069757627037938E+00, \
      0.18958142627134083732E+00, \
      0.17203846136449706946E+00, \
     -0.16821597677215029611E+00, \
     -0.93607927351428988679E-01, \
      0.88229711948036648408E-01, \
     -0.89324662736274161841E-02, \
     -0.54814071000063488284E-01, \
     -0.94958246003466381588E-01, \
     -0.19598064853404969850E-01, \
     -0.83084772357154773468E-02 ) )

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0078125000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       2.0000000000E+00, \
       4.0000000000E+00, \
       6.0000000000E+00, \
      10.0000000000E+00, \
      16.0000000000E+00, \
      16.2500000000E+00, \
      17.0000000000E+00, \
      20.0000000000E+00, \
      25.0000000000E+00, \
      30.0000000000E+00, \
      40.0000000000E+00, \
      50.0000000000E+00, \
      70.0000000000E+00, \
     100.0000000000E+00, \
     125.0000000000E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_y0_int_values_test ( ):

#*****************************************************************************80
#
## bessel_y0_int_values_test() tests bessel_y0_int_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    12 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_y0_int_values_test:' )
  print ( '  bessel_y0_int_values stores values of the Bessel Y integral. of order 0.' )
  print ( '' )
  print ( '      X           int_y(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_y0_int_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_y0_int_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_y0_spherical_values ( n_data ):

#*****************************************************************************80
#
## bessel_y0_spherical_values returns some values of the Spherical Bessel function y0.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Sqrt[Pi/(2*x)] * BesselY[1/2,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    LC: QA47.A34,
#    ISBN: 0-486-61272-4.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  fx_vec = np.array ( ( \
     -0.9950041652780258E+01, \
     -0.4900332889206208E+01, \
     -0.2302652485007213E+01, \
     -0.1375559358182797E+01, \
     -0.8708833866839568E+00, \
     -0.5403023058681397E+00, \
     -0.3019647953972280E+00, \
     -0.1214051020716007E+00, \
      0.1824970143830545E-01, \
      0.1262233859406039E+00, \
      0.2080734182735712E+00, \
      0.2675005078433390E+00, \
      0.3072473814755190E+00, \
      0.3295725974495951E+00, \
      0.3365079788102351E+00, \
      0.3299974988668152E+00, \
      0.3119671174358603E+00, \
      0.2843524095821944E+00, \
      0.2490995600928186E+00, \
      0.2081493978722149E+00, \
      0.1634109052159030E+00 ) )

  x_vec = np.array ( ( \
     0.1E+00, \
     0.2E+00, \
     0.4E+00, \
     0.6E+00, \
     0.8E+00, \
     1.0E+00, \
     1.2E+00, \
     1.4E+00, \
     1.6E+00, \
     1.8E+00, \
     2.0E+00, \
     2.2E+00, \
     2.4E+00, \
     2.6E+00, \
     2.8E+00, \
     3.0E+00, \
     3.2E+00, \
     3.4E+00, \
     3.6E+00, \
     3.8E+00, \
     4.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_y0_spherical_values_test ( ):

#*****************************************************************************80
#
## bessel_y0_spherical_values_test() tests bessel_y0_spherical_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_y0_spherical_values_test:' )
  print ( '  bessel_y0_spherical_values stores values of the spherical Bessel Y function. of order 0.' )
  print ( '' )
  print ( '      X        Spherical Y(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_y0_spherical_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_y0_spherical_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_y0_values ( n_data ):

#*****************************************************************************80
#
## bessel_y0_values returns some values of the Y0 Bessel function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselY[0,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    29 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 16

  fx_vec = np.array ( ( \
     -0.1534238651350367E+01, \
      0.8825696421567696E-01, \
      0.5103756726497451E+00, \
      0.3768500100127904E+00, \
     -0.1694073932506499E-01, \
     -0.3085176252490338E+00, \
     -0.2881946839815792E+00, \
     -0.2594974396720926E-01, \
      0.2235214893875662E+00, \
      0.2499366982850247E+00, \
      0.5567116728359939E-01, \
     -0.1688473238920795E+00, \
     -0.2252373126343614E+00, \
     -0.7820786452787591E-01, \
      0.1271925685821837E+00, \
      0.2054642960389183E+00 ) )

  x_vec = np.array ( ( \
      0.1E+00, \
      1.0E+00, \
      2.0E+00, \
      3.0E+00, \
      4.0E+00, \
      5.0E+00, \
      6.0E+00, \
      7.0E+00, \
      8.0E+00, \
      9.0E+00, \
     10.0E+00, \
     11.0E+00, \
     12.0E+00, \
     13.0E+00, \
     14.0E+00, \
     15.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_y0_values_test ( ):

#*****************************************************************************80
#
## bessel_y0_values_test() tests bessel_y0_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    29 December 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_y0_values_test:' )
  print ( '  bessel_y0_values stores values of the Bessel Y function. of order 0.' )
  print ( '' )
  print ( '      X           Y(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_y0_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_y0_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_y1_spherical_values ( n_data ):

#*****************************************************************************80
#
## bessel_y1_spherical_values returns some values of the Spherical Bessel function y1.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Sqrt[Pi/(2*x)] * BesselY[3/2,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    LC: QA47.A34,
#    ISBN: 0-486-61272-4.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  fx_vec = np.array ( ( \
     -0.1004987506942709E+03, \
     -0.2549501110000635E+02, \
     -0.6730177068289658E+01, \
     -0.3233669719296388E+01, \
     -0.1985299346979349E+01, \
     -0.1381773290676036E+01, \
     -0.1028336567803712E+01, \
     -0.7906105943286149E+00, \
     -0.6133274385019998E+00, \
     -0.4709023582986618E+00, \
     -0.3506120042760553E+00, \
     -0.2459072254437506E+00, \
     -0.1534232496148467E+00, \
     -0.7151106706610352E-01, \
      0.5427959479750482E-03, \
      0.6295916360231598E-01, \
      0.1157316440198251E+00, \
      0.1587922092967723E+00, \
      0.1921166676076864E+00, \
      0.2157913917934037E+00, \
      0.2300533501309578E+00 ) )

  x_vec = np.array ( ( \
     0.1E+00, \
     0.2E+00, \
     0.4E+00, \
     0.6E+00, \
     0.8E+00, \
     1.0E+00, \
     1.2E+00, \
     1.4E+00, \
     1.6E+00, \
     1.8E+00, \
     2.0E+00, \
     2.2E+00, \
     2.4E+00, \
     2.6E+00, \
     2.8E+00, \
     3.0E+00, \
     3.2E+00, \
     3.4E+00, \
     3.6E+00, \
     3.8E+00, \
     4.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_y1_spherical_values_test ( ):

#*****************************************************************************80
#
## bessel_y1_spherical_values_test() tests bessel_y1_spherical_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_y1_spherical_values_test:' )
  print ( '  bessel_y1_spherical_values stores values of the spherical Bessel Y function of order 1.' )
  print ( '' )
  print ( '      X        Spherical Y(1,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_y1_spherical_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_y1_spherical_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_y1_values ( n_data ):

#*****************************************************************************80
#
## bessel_y1_values returns some values of the Y1 Bessel function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselY[1,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    29 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 16

  fx_vec = np.array ( ( \
     -0.6458951094702027E+01, \
     -0.7812128213002887E+00, \
     -0.1070324315409375E+00, \
      0.3246744247918000E+00, \
      0.3979257105571000E+00, \
      0.1478631433912268E+00, \
     -0.1750103443003983E+00, \
     -0.3026672370241849E+00, \
     -0.1580604617312475E+00, \
      0.1043145751967159E+00, \
      0.2490154242069539E+00, \
      0.1637055374149429E+00, \
     -0.5709921826089652E-01, \
     -0.2100814084206935E+00, \
     -0.1666448418561723E+00, \
      0.2107362803687351E-01 ) )

  x_vec = np.array ( ( \
      0.1E+00, \
      1.0E+00, \
      2.0E+00, \
      3.0E+00, \
      4.0E+00, \
      5.0E+00, \
      6.0E+00, \
      7.0E+00, \
      8.0E+00, \
      9.0E+00, \
     10.0E+00, \
     11.0E+00, \
     12.0E+00, \
     13.0E+00, \
     14.0E+00, \
     15.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def bessel_y1_values_test ( ):

#*****************************************************************************80
#
## bessel_y1_values_test() tests bessel_y1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    29 December 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_y1_values_test:' )
  print ( '  bessel_y1_values stores values of the Bessel Y function. of order 1.' )
  print ( '' )
  print ( '      X           Y(1,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = bessel_y1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_y1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_yn_values ( n_data ):

#*****************************************************************************80
#
## bessel_yn_values returns some values of the Kn Bessel function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselY[n,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer NU, the order of the function.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
     -0.1650682606816254E+01, \
     -0.6174081041906827E+00, \
      0.3676628826055245E+00, \
     -0.5868082442208615E-02, \
      0.9579316872759649E-01, \
     -0.2604058666258122E+03, \
     -0.9935989128481975E+01, \
     -0.4536948224911019E+00, \
      0.1354030476893623E+00, \
     -0.7854841391308165E-01, \
     -0.1216180142786892E+09, \
     -0.1291845422080393E+06, \
     -0.2512911009561010E+02, \
     -0.3598141521834027E+00, \
      0.5723897182053514E-02, \
     -0.4113970314835505E+23, \
     -0.4081651388998367E+17, \
     -0.5933965296914321E+09, \
     -0.1597483848269626E+04, \
      0.1644263394811578E-01 ) )

  nu_vec = np.array ( ( \
     2,  2,  2,  2, \
     2,  5,  5,  5, \
     5,  5, 10, 10, \
    10, 10, 10, 20, \
    20, 20, 20, 20 ))

  x_vec = np.array ( ( \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    nu = 0
    x = 0.0
    fx = 0.0
  else:
    nu = nu_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, nu, x, fx

def bessel_yn_values_test ( ):

#*****************************************************************************80
#
## bessel_yn_values_test() tests bessel_yn_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_yn_values_test:' )
  print ( '  bessel_yn_values stores values of the Bessel Y function. of order NU.' )
  print ( '' )
  print ( '      NU  X           Y(NU,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, nu, x, fx = bessel_yn_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4d  %12f  %24.16g' % ( nu, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_yn_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bessel_yx_values ( n_data ):

#*****************************************************************************80
#
## bessel_yx_values returns some values of the Yx Bessel function.
#
#  Discussion:
#
#    This set of data considers the less common case in which the
#    index of the Bessel function Kn is actually not an integer.
#    We may suggest this case by occasionally replacing the symbol
#    "Yn" by "Yx".
#
#    In Mathematica, the function can be evaluated by:
#
#      BesselY[n,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real NU, the order of the function.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 28

  fx_vec = np.array ( ( \
       -1.748560416961876E+00, \
       -0.4310988680183761E+00, \
        0.2347857104062485E+00, \
        0.4042783022390569E+00, \
        0.4560488207946332E+00, \
       -0.1012177091851084E+00, \
        0.2117088663313982E+00, \
       -0.07280690478506185E+00, \
       -1.102495575160179E+00, \
       -0.3956232813587035E+00, \
        0.3219244429611401E+00, \
        0.1584346223881903E+00, \
        0.02742813676191382E+00, \
       -2.876387857462161E+00, \
       -0.8282206324443037E+00, \
        0.2943723749617925E+00, \
       -0.1641784796149411E+00, \
        0.1105304445562544E+00, \
       -0.9319659251969881E+00, \
       -0.2609445010948933E+00, \
        0.2492796362185881E+00, \
        0.2174410301416733E+00, \
       -0.01578576650557229E+00, \
       -4.023453301501028E+00, \
       -0.9588998694752389E+00, \
        0.2264260361047367E+00, \
       -0.2193617736566760E+00, \
        0.09413988344515077E+00 ) )

  nu_vec = np.array ( ( \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    0.50E+00, \
    1.50E+00, \
    1.50E+00, \
    1.50E+00, \
    1.50E+00, \
    1.50E+00, \
    2.50E+00, \
    2.50E+00, \
    2.50E+00, \
    2.50E+00, \
    2.50E+00, \
    1.25E+00, \
    1.25E+00, \
    1.25E+00, \
    1.25E+00, \
    1.25E+00, \
    2.75E+00, \
    2.75E+00, \
    2.75E+00, \
    2.75E+00, \
    2.75E+00 ))

  x_vec = np.array ( ( \
      0.2E+00, \
      1.0E+00, \
      2.0E+00, \
      2.5E+00, \
      3.0E+00, \
      5.0E+00, \
     10.0E+00, \
     20.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00, \
      1.0E+00, \
      2.0E+00, \
      5.0E+00, \
     10.0E+00, \
     50.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    nu = 0
    x = 0.0
    fx = 0.0
  else:
    nu = nu_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, nu, x, fx

def bessel_yx_values_test ( ):

#*****************************************************************************80
#
## bessel_yx_values_test() tests bessel_yx_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bessel_yx_values_test:' )
  print ( '  bessel_yx_values stores values of the Bessel Y function. of real order NU.' )
  print ( '' )
  print ( '      NU          X           Y(NU,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, nu, x, fx = bessel_yx_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( nu, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bessel_yx_values_test:' )
  print ( '  Normal end of execution.' )
  return

def beta_cdf_values ( n_data ):

#*****************************************************************************80
#
## beta_cdf_values returns some values of the Beta CDF.
#
#  Discussion:
#
#    The incomplete Beta function may be written
#
#      beta_inc(A,B,X) = Integral (0 to X) T^(A-1) * (1-T)^(B-1) dT
#                      / Integral (0 to 1) T^(A-1) * (1-T)^(B-1) dT
#
#    Thus,
#
#      beta_inc(A,B,0.0) = 0.0;
#      beta_inc(A,B,1.0) = 1.0
#
#    The incomplete Beta function is also sometimes called the
#    "modified" Beta function, or the "normalized" Beta function
#    or the Beta CDF (cumulative density function).
#
#    In Mathematica, the function can be evaluated by:
#
#      BETA[X,A,B] / BETA[A,B]
#
#    The function can also be evaluated by using the Statistics package:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = BetaDistribution [ a, b ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Karl Pearson,
#    Tables of the Incomplete Beta Function,
#    Cambridge University Press, 1968.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, B, the parameters of the function.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 45

  a_vec = np.array ( ( \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      1.0E+00, \
      1.0E+00, \
      1.0E+00, \
      1.0E+00, \
      1.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      5.5E+00, \
     10.0E+00, \
     10.0E+00, \
     10.0E+00, \
     10.0E+00, \
     20.0E+00, \
     20.0E+00, \
     20.0E+00, \
     20.0E+00, \
     20.0E+00, \
     30.0E+00, \
     30.0E+00, \
     40.0E+00, \
      0.1E+01, \
      0.1E+01, \
      0.1E+01, \
      0.1E+01, \
      0.1E+01, \
      0.1E+01, \
      0.1E+01, \
      0.1E+01, \
      0.2E+01, \
      0.3E+01, \
      0.4E+01, \
      0.5E+01, \
      1.30625, \
      1.30625, \
      1.30625 ))

  b_vec = np.array ( ( \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      1.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      5.0E+00, \
      0.5E+00, \
      5.0E+00, \
      5.0E+00, \
     10.0E+00, \
      5.0E+00, \
     10.0E+00, \
     10.0E+00, \
     20.0E+00, \
     20.0E+00, \
     10.0E+00, \
     10.0E+00, \
     20.0E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     0.2E+01, \
     0.3E+01, \
     0.4E+01, \
     0.5E+01, \
     0.2E+01, \
     0.2E+01, \
     0.2E+01, \
     0.2E+01, \
    11.7562, \
    11.7562, \
    11.7562 ))

  f_vec = np.array ( ( \
     0.6376856085851985E-01, \
     0.2048327646991335E+00, \
     0.1000000000000000E+01, \
     0.0000000000000000E+00, \
     0.5012562893380045E-02, \
     0.5131670194948620E-01, \
     0.2928932188134525E+00, \
     0.5000000000000000E+00, \
     0.2800000000000000E-01, \
     0.1040000000000000E+00, \
     0.2160000000000000E+00, \
     0.3520000000000000E+00, \
     0.5000000000000000E+00, \
     0.6480000000000000E+00, \
     0.7840000000000000E+00, \
     0.8960000000000000E+00, \
     0.9720000000000000E+00, \
     0.4361908850559777E+00, \
     0.1516409096347099E+00, \
     0.8978271484375000E-01, \
     0.1000000000000000E+01, \
     0.5000000000000000E+00, \
     0.4598773297575791E+00, \
     0.2146816102371739E+00, \
     0.9507364826957875E+00, \
     0.5000000000000000E+00, \
     0.8979413687105918E+00, \
     0.2241297491808366E+00, \
     0.7586405487192086E+00, \
     0.7001783247477069E+00, \
     0.5131670194948620E-01, \
     0.1055728090000841E+00, \
     0.1633399734659245E+00, \
     0.2254033307585166E+00, \
     0.3600000000000000E+00, \
     0.4880000000000000E+00, \
     0.5904000000000000E+00, \
     0.6723200000000000E+00, \
     0.2160000000000000E+00, \
     0.8370000000000000E-01, \
     0.3078000000000000E-01, \
     0.1093500000000000E-01, \
     0.918884684620518, \
     0.21052977489419, \
     0.1824130512500673 ) )

  x_vec = np.array ( ( \
     0.01E+00, \
     0.10E+00, \
     1.00E+00, \
     0.00E+00, \
     0.01E+00, \
     0.10E+00, \
     0.50E+00, \
     0.50E+00, \
     0.10E+00, \
     0.20E+00, \
     0.30E+00, \
     0.40E+00, \
     0.50E+00, \
     0.60E+00, \
     0.70E+00, \
     0.80E+00, \
     0.90E+00, \
     0.50E+00, \
     0.90E+00, \
     0.50E+00, \
     1.00E+00, \
     0.50E+00, \
     0.80E+00, \
     0.60E+00, \
     0.80E+00, \
     0.50E+00, \
     0.60E+00, \
     0.70E+00, \
     0.80E+00, \
     0.70E+00, \
     0.10E+00, \
     0.20E+00, \
     0.30E+00, \
     0.40E+00, \
     0.20E+00, \
     0.20E+00, \
     0.20E+00, \
     0.20E+00, \
     0.30E+00, \
     0.30E+00, \
     0.30E+00, \
     0.30E+00, \
     0.225609, \
     0.0335568, \
     0.0295222  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    b = 0.0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, x, f

def beta_cdf_values_test ( ):

#*****************************************************************************80
#
## beta_cdf_values_test() tests beta_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'beta_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  beta_cdf_values stores values of the BETA function.' )
  print ( '' )
  print ( '      A         B         X        beta_cdf(A,B,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, x, f = beta_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16g' % ( a, b, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'beta_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def beta_inc_values ( n_data ):

#*****************************************************************************80
#
## beta_inc_values returns some values of the incomplete Beta function.
#
#  Discussion:
#
#    The incomplete Beta function may be written
#
#      beta_inc(A,B,X) = Integral (0 to X) T^(A-1) * (1-T)^(B-1) dT
#                      / Integral (0 to 1) T^(A-1) * (1-T)^(B-1) dT
#
#    Thus,
#
#      beta_inc(A,B,0.0) = 0.0;
#      beta_inc(A,B,1.0) = 1.0
#
#    The incomplete Beta function is also sometimes called the
#    "modified" Beta function, or the "normalized" Beta function
#    or the Beta CDF (cumulative density function).
#
#    In Mathematica, the function can be evaluated by:
#
#      BETA[X,A,B] / BETA[A,B]
#
#    The function can also be evaluated by using the Statistics package:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = BetaDistribution [ a, b ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Karl Pearson,
#    Tables of the Incomplete Beta Function,
#    Cambridge University Press, 1968.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, B, the parameters of the function.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 45

  a_vec = np.array ( ( \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      1.0E+00, \
      1.0E+00, \
      1.0E+00, \
      1.0E+00, \
      1.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      5.5E+00, \
     10.0E+00, \
     10.0E+00, \
     10.0E+00, \
     10.0E+00, \
     20.0E+00, \
     20.0E+00, \
     20.0E+00, \
     20.0E+00, \
     20.0E+00, \
     30.0E+00, \
     30.0E+00, \
     40.0E+00, \
      0.1E+01, \
      0.1E+01, \
      0.1E+01, \
      0.1E+01, \
      0.1E+01, \
      0.1E+01, \
      0.1E+01, \
      0.1E+01, \
      0.2E+01, \
      0.3E+01, \
      0.4E+01, \
      0.5E+01, \
      1.30625, \
      1.30625, \
      1.30625 ))

  b_vec = np.array ( ( \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      1.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      2.0E+00, \
      5.0E+00, \
      0.5E+00, \
      5.0E+00, \
      5.0E+00, \
     10.0E+00, \
      5.0E+00, \
     10.0E+00, \
     10.0E+00, \
     20.0E+00, \
     20.0E+00, \
     10.0E+00, \
     10.0E+00, \
     20.0E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     0.2E+01, \
     0.3E+01, \
     0.4E+01, \
     0.5E+01, \
     0.2E+01, \
     0.2E+01, \
     0.2E+01, \
     0.2E+01, \
    11.7562, \
    11.7562, \
    11.7562 ))

  f_vec = np.array ( ( \
     0.6376856085851985E-01, \
     0.2048327646991335E+00, \
     0.1000000000000000E+01, \
     0.0000000000000000E+00, \
     0.5012562893380045E-02, \
     0.5131670194948620E-01, \
     0.2928932188134525E+00, \
     0.5000000000000000E+00, \
     0.2800000000000000E-01, \
     0.1040000000000000E+00, \
     0.2160000000000000E+00, \
     0.3520000000000000E+00, \
     0.5000000000000000E+00, \
     0.6480000000000000E+00, \
     0.7840000000000000E+00, \
     0.8960000000000000E+00, \
     0.9720000000000000E+00, \
     0.4361908850559777E+00, \
     0.1516409096347099E+00, \
     0.8978271484375000E-01, \
     0.1000000000000000E+01, \
     0.5000000000000000E+00, \
     0.4598773297575791E+00, \
     0.2146816102371739E+00, \
     0.9507364826957875E+00, \
     0.5000000000000000E+00, \
     0.8979413687105918E+00, \
     0.2241297491808366E+00, \
     0.7586405487192086E+00, \
     0.7001783247477069E+00, \
     0.5131670194948620E-01, \
     0.1055728090000841E+00, \
     0.1633399734659245E+00, \
     0.2254033307585166E+00, \
     0.3600000000000000E+00, \
     0.4880000000000000E+00, \
     0.5904000000000000E+00, \
     0.6723200000000000E+00, \
     0.2160000000000000E+00, \
     0.8370000000000000E-01, \
     0.3078000000000000E-01, \
     0.1093500000000000E-01, \
     0.918884684620518, \
     0.21052977489419, \
     0.1824130512500673 ) )

  x_vec = np.array ( ( \
     0.01E+00, \
     0.10E+00, \
     1.00E+00, \
     0.00E+00, \
     0.01E+00, \
     0.10E+00, \
     0.50E+00, \
     0.50E+00, \
     0.10E+00, \
     0.20E+00, \
     0.30E+00, \
     0.40E+00, \
     0.50E+00, \
     0.60E+00, \
     0.70E+00, \
     0.80E+00, \
     0.90E+00, \
     0.50E+00, \
     0.90E+00, \
     0.50E+00, \
     1.00E+00, \
     0.50E+00, \
     0.80E+00, \
     0.60E+00, \
     0.80E+00, \
     0.50E+00, \
     0.60E+00, \
     0.70E+00, \
     0.80E+00, \
     0.70E+00, \
     0.10E+00, \
     0.20E+00, \
     0.30E+00, \
     0.40E+00, \
     0.20E+00, \
     0.20E+00, \
     0.20E+00, \
     0.20E+00, \
     0.30E+00, \
     0.30E+00, \
     0.30E+00, \
     0.30E+00, \
     0.225609, \
     0.0335568, \
     0.0295222  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    b = 0.0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, x, f

def beta_inc_values_test ( ):

#*****************************************************************************80
#
## beta_inc_values_test() tests beta_inc_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'beta_inc_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  beta_inc_values stores values of the BETA function.' )
  print ( '' )
  print ( '      A         B         X        beta_inc(A,B,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, x, f = beta_inc_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16g' % ( a, b, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'beta_inc_values_test:' )
  print ( '  Normal end of execution.' )
  return

def beta_log_values ( n_data ):

#*****************************************************************************80
#
## beta_log_values returns some values of the logarithm of the Beta function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Log[Beta[x]]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, Y, the arguments of the function.
#
#    real FXY, the value of the function.
#
  import numpy as np

  n_max = 17

  f_vec = np.array ( ( \
      0.1609437912434100E+01, \
      0.9162907318741551E+00, \
      0.5108256237659907E+00, \
      0.2231435513142098E+00, \
      0.1609437912434100E+01, \
      0.9162907318741551E+00, \
      0.0000000000000000E+00, \
     -0.1791759469228055E+01, \
     -0.3401197381662155E+01, \
     -0.4941642422609304E+01, \
     -0.6445719819385578E+01, \
     -0.3737669618283368E+01, \
     -0.5123963979403259E+01, \
     -0.6222576268071369E+01, \
     -0.7138866999945524E+01, \
     -0.7927324360309794E+01, \
     -0.9393661429103221E+01 ) )

  x_vec = np.array ( ( \
     0.2E+00, \
     0.4E+00, \
     0.6E+00, \
     0.8E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     2.0E+00, \
     3.0E+00, \
     4.0E+00, \
     5.0E+00, \
     6.0E+00, \
     6.0E+00, \
     6.0E+00, \
     6.0E+00, \
     6.0E+00, \
     7.0E+00  ) )

  y_vec = np.array ( ( \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     0.2E+00, \
     0.4E+00, \
     1.0E+00, \
     2.0E+00, \
     3.0E+00, \
     4.0E+00, \
     5.0E+00, \
     2.0E+00, \
     3.0E+00, \
     4.0E+00, \
     5.0E+00, \
     6.0E+00, \
     7.0E+00   ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    y = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    y = y_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, y, f

def beta_log_values_test ( ):

#*****************************************************************************80
#
## beta_log_values_test() tests beta_log_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'beta_log_values_test:' )
  print ( '  beta_log_values stores values of the Log(BETA) function.' )
  print ( '' )
  print ( '      X         Y         Log(BETA(X,Y))' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, y, f = beta_log_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( x, y, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'beta_log_values_test:' )
  print ( '  Normal end of execution.' )
  return

def beta_noncentral_cdf_values ( n_data ):

#*****************************************************************************80
#
## beta_noncentral_cdf_values returns some values of the noncentral Beta CDF.
#
#  Discussion:
#
#    The values presented here are taken from the reference, where they
#    were given to a limited number of decimal places.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    R Chattamvelli, R Shanmugam,
#    Algorithm AS 310:
#    Computing the Non-central Beta Distribution Function,
#    Applied Statistics,
#    Volume 46, Number 1, 1997, pages 146-156.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    rea A, B, the shape parameters.
#
#    real LAMDA, the noncentrality parameter.
#    It is necessary to misspell LAMBDA since Python uses it as a keyword.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 25

  a_vec = np.array ( ( \
        5.0, \
        5.0, \
        5.0, \
       10.0, \
       10.0, \
       10.0, \
       20.0, \
       20.0, \
       20.0, \
       10.0, \
       10.0, \
       15.0, \
       20.0, \
       20.0, \
       20.0, \
       30.0, \
       30.0, \
       10.0, \
       10.0, \
       10.0, \
       15.0, \
       10.0, \
       12.0, \
       30.0, \
       35.0  ))

  b_vec = np.array ( ( \
        5.0, \
        5.0, \
        5.0, \
       10.0, \
       10.0, \
       10.0, \
       20.0, \
       20.0, \
       20.0, \
       20.0, \
       10.0, \
        5.0, \
       10.0, \
       30.0, \
       50.0, \
       20.0, \
       40.0, \
        5.0, \
       10.0, \
       30.0, \
       20.0, \
        5.0, \
       17.0, \
       30.0, \
       30.0 ))

  f_vec = np.array ( ( \
       0.4563021, \
       0.1041337, \
       0.6022353, \
       0.9187770, \
       0.6008106, \
       0.0902850, \
       0.9998655, \
       0.9925997, \
       0.9641112, \
       0.9376626573, \
       0.7306817858, \
       0.1604256918, \
       0.1867485313, \
       0.6559386874, \
       0.9796881486, \
       0.1162386423, \
       0.9930430054, \
       0.0506899273, \
       0.1030959706, \
       0.9978417832, \
       0.2555552369, \
       0.0668307064, \
       0.0113601067, \
       0.7813366615, \
       0.8867126477 ) )

  lamda_vec = np.array ( ( \
        54.0, \
       140.0, \
       170.0, \
        54.0, \
       140.0, \
       250.0, \
        54.0, \
       140.0, \
       250.0, \
       150.0, \
       120.0, \
        80.0, \
       110.0, \
        65.0, \
       130.0, \
        80.0, \
       130.0, \
        20.0, \
        54.0, \
        80.0, \
       120.0, \
        55.0, \
        64.0, \
       140.0, \
        20.0 ))

  x_vec = np.array ( ( \
       0.8640, \
       0.9000, \
       0.9560, \
       0.8686, \
       0.9000, \
       0.9000, \
       0.8787, \
       0.9000, \
       0.9220, \
       0.868, \
       0.900, \
       0.880, \
       0.850, \
       0.660, \
       0.720, \
       0.720, \
       0.800, \
       0.644, \
       0.700, \
       0.780, \
       0.760, \
       0.795, \
       0.560, \
       0.800, \
       0.670   ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    b = 0.0
    lamda = 0.0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    lamda = lamda_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, lamda, x, f

def beta_noncentral_cdf_values_test ( ):

#*****************************************************************************80
#
## beta_noncentral_cdf_values_test() tests beta_noncentral_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'beta_noncentral_cdf_values_test:' )
  print ( '  beta_noncentral_cdf_values stores values of the noncentral BETA CDF.' )
  print ( '' )
  print ( '      A         B         LAMDA     X        beta_noncentral_cdf(A,B,LAMDA,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, lamda, x, f = beta_noncentral_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %12f  %24.16g' % ( a, b, lamda, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'beta_noncentral_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def beta_pdf_values ( n_data ):

#*****************************************************************************80
#
## beta_pdf_values returns some values of the Beta PDF.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    30 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real ALPHA, BETA, the parameters of the function.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 10

  alpha_vec = np.array ( ( \
       1.092091484911879, \
       2.808477213834471, \
       1.287888961910225, \
       3.169828561512062, \
       2.006531407488083, \
    0.009191855792026001, \
       0.472723751058401, \
       4.204237253278341, \
       1.301514988836825, \
       1.758143299519481 ))

  beta_vec = np.array ( ( \
       4.781587882544648, \
       2.076535407379806, \
       0.549783967662353, \
      0.3086361453280091, \
       3.773367432107051, \
       4.487520304498656, \
     0.06808445791730976, \
      0.6155195788227712, \
       4.562418534907164, \
       4.114436583429598 ))

  f_vec = np.array ( ( \
    0.002826137156803199, \
     0.04208950342768649, \
      0.2184064957817208, \
      0.1335142301445414, \
      0.1070571849830009, \
    0.005796394377470491, \
      0.5518796772414584, \
                     0.0, \
        2.87907465409348, \
       2.126992854611924 ) )

  x_vec = np.array ( ( \
      0.8667224264776531, \
     0.04607764003473368, \
     0.02211617261254013, \
      0.4582543823302144, \
      0.8320834756642252, \
      0.3520587633290876, \
       0.898529119425846, \
    -0.01692420862048847, \
     0.09718884992568674, \
      0.2621671905296927 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    alpha = 0.0
    beta = 0.0
    x = 0.0
    f = 0.0
  else:
    alpha = alpha_vec[n_data]
    beta = beta_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, alpha, beta, x, f

def beta_pdf_values_test ( ):

#*****************************************************************************80
#
## beta_pdf_values_test() tests beta_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    30 July 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'beta_pdf_values_test:' )
  print ( '  beta_pdf_values stores values of the BETA function.' )
  print ( '' )
  print ( '      ALPHA     BETA      X        PDF()' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, alpha, beta, x, f = beta_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %12g  %24.16g' % ( alpha, beta, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'beta_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def beta_values ( n_data ):

#*****************************************************************************80
#
## beta_values returns some values of the Beta function.
#
#  Discussion:
#
#    Beta(X,Y) = ( Gamma(X) * Gamma(Y) ) / Gamma(X+Y)
#
#    Both X and Y must be greater than 0.
#
#    In Mathematica, the function can be evaluated by:
#
#      Beta[X,Y]
#
#  Properties:
#
#    Beta(X,Y) = Beta(Y,X).
#    Beta(X,Y) = Integral ( 0 <= T <= 1 ) T^(X-1) (1-T)^(Y-1) dT.
#    Beta(X,Y) = Gamma(X) * Gamma(Y) / Gamma(X+Y)
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    01 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, Y, the arguments of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 17

  f_vec = np.array ( ( \
     0.5000000000000000E+01, \
     0.2500000000000000E+01, \
     0.1666666666666667E+01, \
     0.1250000000000000E+01, \
     0.5000000000000000E+01, \
     0.2500000000000000E+01, \
     0.1000000000000000E+01, \
     0.1666666666666667E+00, \
     0.3333333333333333E-01, \
     0.7142857142857143E-02, \
     0.1587301587301587E-02, \
     0.2380952380952381E-01, \
     0.5952380952380952E-02, \
     0.1984126984126984E-02, \
     0.7936507936507937E-03, \
     0.3607503607503608E-03, \
     0.8325008325008325E-04 ) )

  x_vec = np.array ( ( \
     0.2E+00, \
     0.4E+00, \
     0.6E+00, \
     0.8E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     2.0E+00, \
     3.0E+00, \
     4.0E+00, \
     5.0E+00, \
     6.0E+00, \
     6.0E+00, \
     6.0E+00, \
     6.0E+00, \
     6.0E+00, \
     7.0E+00  ) )

  y_vec = np.array ( ( \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     0.2E+00, \
     0.4E+00, \
     1.0E+00, \
     2.0E+00, \
     3.0E+00, \
     4.0E+00, \
     5.0E+00, \
     2.0E+00, \
     3.0E+00, \
     4.0E+00, \
     5.0E+00, \
     6.0E+00, \
     7.0E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    y = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    y = y_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, y, f

def beta_values_test ( ):

#*****************************************************************************80
#
## beta_values_test() tests beta_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    24 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'beta_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  beta_values stores values of the BETA function.' )
  print ( '' )
  print ( '      X         Y         BETA(X,Y)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, y, f = beta_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( x, y, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'beta_values_test:' )
  print ( '  Normal end of execution.' )
  return

def binomial_cdf_values ( n_data ):

#*****************************************************************************80
#
## binomial_cdf_values returns some values of the binomial CDF.
#
#  Discussion:
#
#    CDF(X)(A,B) is the probability of at most X successes in A trials,
#    given that the probability of success on a single trial is B.
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`DiscreteDistributions`]
#      dist = BinomialDistribution [ n, p ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#    Daniel Zwillinger,
#    CRC Standard Mathematical Tables and Formulae,
#    30th Edition, CRC Press, 1996, pages 651-652.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer A, a parameter of the function.
#
#    real B, a parameter of the function.
#
#    integer X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 17

  a_vec = np.array ( ( \
     2,  2,  2,  2, \
     2,  4,  4,  4, \
     4, 10, 10, 10, \
    10, 10, 10, 10, \
    10 ))

  b_vec = np.array ( ( \
     0.05E+00, \
     0.05E+00, \
     0.05E+00, \
     0.50E+00, \
     0.50E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.05E+00, \
     0.10E+00, \
     0.15E+00, \
     0.20E+00, \
     0.25E+00, \
     0.30E+00, \
     0.40E+00, \
     0.50E+00 ))

  f_vec = np.array ( ( \
     0.9025000000000000E+00, \
     0.9975000000000000E+00, \
     0.1000000000000000E+01, \
     0.2500000000000000E+00, \
     0.7500000000000000E+00, \
     0.3164062500000000E+00, \
     0.7382812500000000E+00, \
     0.9492187500000000E+00, \
     0.9960937500000000E+00, \
     0.9999363101685547E+00, \
     0.9983650626000000E+00, \
     0.9901259090013672E+00, \
     0.9672065024000000E+00, \
     0.9218730926513672E+00, \
     0.8497316674000000E+00, \
     0.6331032576000000E+00, \
     0.3769531250000000E+00 ) )

  x_vec = np.array ( ( \
     0, 1, 2, 0, \
     1, 0, 1, 2, \
     3, 4, 4, 4, \
     4, 4, 4, 4, \
     4  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    b = 0.0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, x, f

def binomial_cdf_values_test ( ):

#*****************************************************************************80
#
## binomial_cdf_values_test() tests binomial_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'binomial_cdf_values_test:' )
  print ( '  binomial_cdf_values stores values of the BINOMIAL CDF.' )
  print ( '' )
  print ( '      A         B         X        binomial_cdf(A,B,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, x, f = binomial_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12d  %24.16g' % ( a, b, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'binomial_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def binomial_pdf_values ( n_data ):

#*****************************************************************************80
#
## binomial_pdf_values returns some values of the binomial PDF.
#
#  Discussion:
#
#    PDF(X)(A,B) is the probability of X successes in A trials,
#    given that the probability of success on a single trial is B.
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`DiscreteDistributions`]
#      dist = BinomialDistribution [ n, p ]
#      PDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#    Daniel Zwillinger,
#    CRC Standard Mathematical Tables and Formulae,
#    30th Edition, CRC Press, 1996, pages 651-652.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer A, a parameter of the function.
#
#    real B, a parameter of the function.
#
#    integer X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 10

  a_vec = np.array ( ( \
     5, 12,  6, 13,  9, \
     1,  2, 17,  6,  8 ))

  b_vec = np.array ( ( \
    0.8295092339327006, \
    0.06611873491603133, \
    0.0438289977791071, \
    0.4495389603071763, \
    0.7972869541062562, \
    0.3507523379805466, \
    0.8590968552798568, \
    0.007512364073964213, \
    0.1136640464424993, \
    0.2671322702601793 ))

  f_vec = np.array ( ( \
    0.3927408939646697, \
    0.0006199968732461383, \
    0.764211224733124, \
    0.0004260353334364943, \
    0.302948289145794, \
    0.3507523379805466, \
    0.01985369619202562, \
    0.006854388879646552, \
    0.000002156446446382985, \
    0.0005691150511772053 ) )

  x_vec = np.array ( ( \
     5, 5, 0, 0, 7, \
     1, 0, 2, 6, 7 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    b = 0.0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, x, f

def binomial_pdf_values_test ( ):

#*****************************************************************************80
#
## binomial_pdf_values_test() tests binomial_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 July 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'binomial_pdf_values_test:' )
  print ( '  binomial_pdf_values stores values of the BINOMIAL PDF.' )
  print ( '' )
  print ( '   A          B                  X        binomial_pdf(A,B,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, x, f = binomial_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %2d  %24.16g  %2d  %24.16g' % ( a, b, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'binomial_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def binomial_values ( n_data ):

#*****************************************************************************80
#
## binomial_values returns some values of the binomial coefficients.
#
#  Discussion:
#
#    The formula for the binomial coefficient is
#
#      C(N,K) = N! / ( K! * (N-K)! )
#
#    In Mathematica, the function can be evaluated by:
#
#      Binomial[n,k]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer A, B, the arguments of the function.
#
#    integer F, the value of the function.
#
  import numpy as np

  n_max = 20

  a_vec = np.array ( ( \
     1,  6,  6,  6, 15, \
    15, 15, 15, 15, 15, \
    15, 25, 25, 25, 25, \
    25, 25, 25, 25, 25  ) )

  b_vec = np.array ( ( \
     0,  1,  3,  5,  1, \
     3,  5,  7,  9, 11, \
    13,  1,  3,  5,  7, \
     9, 11, 13, 15, 17  ) )

  f_vec = np.array ( ( \
           1, \
           6, \
          20, \
           6, \
          15, \
         455, \
        3003, \
        6435, \
        5005, \
        1365, \
         105, \
          25, \
        2300, \
       53130, \
      480700, \
     2042975, \
     4457400, \
     5200300, \
     3268760, \
     1081575 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0
    b = 0
    f = 0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, f

def binomial_values_test ( ):

#*****************************************************************************80
#
## binomial_values_test() tests binomial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'binomial_values_test:' )
  print ( '  binomial_values stores values of the BINOMIAL function.' )
  print ( '' )
  print ( '      A         B         BINOMIAL(A,B)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, f = binomial_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12d  %12d' % ( a, b, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'binomial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def bivariate_normal_cdf_values ( n_data ):

#*****************************************************************************80
#
## bivariate_normal_cdf_values returns some values of the bivariate normal CDF.
#
#  Discussion:
#
#    FXY is the probability that two variables A and B, which are
#    related by a bivariate normal distribution with correlation R,
#    respectively satisfy A <= X and B <= Y.
#
#    Mathematica can evaluate the bivariate normal CDF via the commands:
#
#      <<MultivariateStatistics`
#      cdf = CDF[MultinormalDistribution[{0,0}{{1,r},{r,1}}],{x,y}]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    National Bureau of Standards,
#    Tables of the Bivariate Normal Distribution and Related Functions,
#    NBS, Applied Mathematics Series, Number 50, 1959.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, Y, the parameters of the function.
#
#    real R, the correlation value.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 41

  f_vec = np.array ( ( \
  0.02260327218569867, \
  0.1548729518584100, \
  0.4687428083352184, \
  0.7452035868929476, \
  0.8318608306874188, \
  0.8410314261134202, \
  0.1377019384919464, \
  0.1621749501739030, \
  0.1827411243233119, \
  0.2010067421506235, \
  0.2177751155265290, \
  0.2335088436446962, \
  0.2485057781834286, \
  0.2629747825154868, \
  0.2770729823404738, \
  0.2909261168683812, \
  0.3046406378726738, \
  0.3183113449213638, \
  0.3320262544108028, \
  0.3458686754647614, \
  0.3599150462310668, \
  0.3742210899871168, \
  0.3887706405282320, \
  0.4032765198361344, \
  0.4162100291953678, \
  0.6508271498838664, \
  0.8318608306874188, \
  0.0000000000000000, \
  0.1666666666539970, \
  0.2500000000000000, \
  0.3333333333328906, \
  0.5000000000000000, \
  0.7452035868929476, \
  0.1548729518584100, \
  0.1548729518584100, \
  0.06251409470431653, \
  0.7452035868929476, \
  0.1548729518584100, \
  0.1548729518584100, \
  0.06251409470431653, \
  0.6337020457912916 ) )

  r_vec = np.array ( ( \
     0.500,  0.500,  0.500,  0.500,  0.500, \
     0.500, -0.900, -0.800, -0.700, -0.600, \
    -0.500, -0.400, -0.300, -0.200, -0.100, \
     0.000,  0.100,  0.200,  0.300,  0.400, \
     0.500,  0.600,  0.700,  0.800,  0.900, \
     0.673,  0.500, -1.000, -0.500,  0.000, \
     0.500,  1.000,  0.500,  0.500,  0.500, \
     0.500,  0.500,  0.500,  0.500,  0.500, \
     0.500  ) )

  x_vec = np.array ( ( \
    -2.0, -1.0,  0.0,  1.0,  2.0, \
     3.0, -0.2, -0.2, -0.2, -0.2, \
    -0.2, -0.2, -0.2, -0.2, -0.2, \
    -0.2, -0.2, -0.2, -0.2, -0.2, \
    -0.2, -0.2, -0.2, -0.2, -0.2, \
     1.0,  2.0,  0.0,  0.0,  0.0, \
     0.0,  0.0,  1.0,  1.0, -1.0, \
    -1.0,  1.0,  1.0, -1.0, -1.0, \
     0.7071067811865475 ))

  y_vec = np.array ( ( \
     1.0,  1.0,  1.0,  1.0,  1.0, \
     1.0,  0.5,  0.5,  0.5,  0.5, \
     0.5,  0.5,  0.5,  0.5,  0.5, \
     0.5,  0.5,  0.5,  0.5,  0.5, \
     0.5,  0.5,  0.5,  0.5,  0.5, \
     0.5,  1.0,  0.0,  0.0,  0.0, \
     0.0,  0.0,  1.0, -1.0,  1.0, \
    -1.0,  1.0, -1.0,  1.0, -1.0, \
     0.7071067811865475 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    y = 0.0
    r = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    y = y_vec[n_data]
    r = r_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, y, r, f

def bivariate_normal_cdf_values_test ( ):

#*****************************************************************************80
#
## bivariate_normal_cdf_values_test() tests bivariate_normal_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 January 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'bivariate_normal_cdf_values_test:' )
  print ( '  bivariate_normal_cdf_values stores values of the bivariate normal CDF.' )
  print ( '' )
  print ( '      X         Y         R        bivariate_normal_cdf(X,Y,R)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, y, r, f = bivariate_normal_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16g' % ( x, y, r, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'bivariate_normal_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def c8_log_values ( n_data ):

#*****************************************************************************80
#
## c8_log_values returns values of the complex logarithm function.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    04 January 2019
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    David Collens,
#    Algorithm 243: Logarithm of a Complex Number,
#    Communications of the Association for Computing Machinery,
#    Volume 7, Number 11, November 1964, page 660.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    complex X, the argument of the function.
#
#    complex CAI, the value of the function.
#
  import numpy as np

  n_max = 12

  fz_vec = np.array ( [ \
  1.039720770839918 - 2.356194490192345j, \
  0.804718956217050 + 2.677945044588987j, \
  0.346573590279973 - 2.356194490192345j, \
  0.000000000000000 + 3.141592653589793j, \
  0.693147180559945 - 1.570796326794897j, \
  0.000000000000000 - 1.570796326794897j, \
  0.000000000000000 + 1.570796326794897j, \
  0.693147180559945 + 1.570796326794897j, \
  0.346573590279973 - 0.785398163397448j, \
  0.000000000000000 + 0.000000000000000j, \
  1.039720770839918 - 0.785398163397448j, \
  0.804718956217050 + 0.463647609000806j ] )

  z_vec = np.array ( [ \
    -2.0 - 2.0j, \
    -2.0 + 1.0j, \
    -1.0 - 1.0j, \
    -1.0 + 0.0j, \
     0.0 - 2.0j, \
     0.0 - 1.0j, \
     0.0 + 1.0j, \
     0.0 + 2.0j, \
     1.0 - 1.0j, \
     1.0 + 0.0j, \
     2.0 - 2.0j, \
     2.0 + 1.0j ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    z = 0.0 + 0.0j
    fz = 0.0 + 0.0j
  else:
    z = z_vec[n_data]
    fz = fz_vec[n_data]
    n_data = n_data + 1

  return n_data, z, fz

def c8_log_values_test ( ):

#*****************************************************************************80
#
## c8_log_values_test() tests c8_log_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    04 January 2019
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'c8_log_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  c8_log_values stores values of' )
  print ( '  the complex logarithm function.' )
  print ( '' )
  print ( '        Z.real        Z.imag          FZ.real                FZ.imag' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, z, fz = c8_log_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %24.16g  %24.16g' \
      % ( z.real, z.imag, fz.real, fz.imag ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'c8_log_values_test:' )
  print ( '  Normal end of execution.' )
  return

def catalan_values ( n_data ):

#*****************************************************************************80
#
## catalan_values returns some values of the Catalan numbers.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Binomial[2*n,n] / ( n + 1 )
#
#  First values:
#
#     C(0)     1
#     C(1)     1
#     C(2)     2
#     C(3)     5
#     C(4)    14
#     C(5)    42
#     C(6)   132
#     C(7)   429
#     C(8)  1430
#     C(9)  4862
#    C(10) 16796
#
#  Formula:
#
#    C(N) = (2*N)! / ( (N+1) * (N!) * (N!) ) 
#         = 1 / (N+1) * COMB ( 2N, N )
#         = 1 / (2N+1) * COMB ( 2N+1, N+1).
#
#  Recursion:
#
#    C(N) = 2 * (2*N-1) * C(N-1) / (N+1)
#    C(N) = sum ( 1 <= I <= N-1 ) C(I) * C(N-I)
#
#  Discussion:
#
#    The Catalan number C(N) counts:
#
#    1) the number of binary trees on N vertices;
#    2) the number of ordered trees on N+1 vertices;
#    3) the number of full binary trees on 2N+1 vertices;
#    4) the number of well formed sequences of 2N parentheses;
#    5) the number of ways 2N ballots can be counted, in order,
#       with N positive and N negative, so that the running sum
#       is never negative;
#    6) the number of standard tableaus in a 2 by N rectangular Ferrers diagram;
#    7) the number of monotone functions from [1..N} to [1..N} which 
#       satisfy f(i) <= i for all i;
#    8) the number of ways to triangulate a polygon with N+2 vertices.
#
#  Example:
#
#    N = 3
#
#    ()()()
#    ()(())
#    (()())
#    (())()
#    ((()))
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 September 2004
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the Catalan number.
#
#    integer C, the value of the Catalan number.
#
  import numpy as np

  n_max = 11

  c_vec = np.array ( ( 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796 ) )

  n_vec = np.array ( ( 0,  1,  2,  3,  4, 5,  6,  7,  8,  9,  10 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    c = 0
  else:
    n = n_vec[n_data]
    c = c_vec[n_data]
    n_data = n_data + 1

  return n_data, n, c

def catalan_values_test ( ):

#*****************************************************************************80
#
## catalan_values_test() tests catalan_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    02 February 2009
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'catalan_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  catalan_values returns values of' )
  print ( '  the Catalan numbers.' )
  print ( '' )
  print ( '     N        C(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, c = catalan_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4d  %10d' % ( n, c ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'catalan_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cauchy_cdf_values ( n_data ):

#*****************************************************************************80
#
## cauchy_cdf_values returns some values of the Cauchy CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = CauchyDistribution [ mu, sigma ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real MU, the mean of the distribution.
#
#    real SIGMA, the standard deviation of the distribution.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 12

  f_vec = np.array ( ( \
     0.5000000000000000E+00, \
     0.8524163823495667E+00, \
     0.9220208696226307E+00, \
     0.9474315432887466E+00, \
     0.6475836176504333E+00, \
     0.6024163823495667E+00, \
     0.5779791303773693E+00, \
     0.5628329581890012E+00, \
     0.6475836176504333E+00, \
     0.5000000000000000E+00, \
     0.3524163823495667E+00, \
     0.2500000000000000E+00 ) )

  mu_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01  ) )

  sigma_vec = np.array ( ( \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01 ))

  x_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    mu = 0.0
    sigma = 0.0
    x = 0.0
    f = 0.0
  else:
    mu = mu_vec[n_data]
    sigma = sigma_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, mu, sigma, x, f

def cauchy_cdf_values_test ( ):

#*****************************************************************************80
#
## cauchy_cdf_values_test() tests cauchy_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cauchy_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cauchy_cdf_values stores values of the Cauchy CDF.' )
  print ( '' )
  print ( '      MU      SIGMA       X        cauchy_cdf(MU,SIGMA,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, mu, sigma, x, f = cauchy_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16g' % ( mu, sigma, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cauchy_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cbrt_values ( n_data ):

#*****************************************************************************80
#
## cbrt_values returns some values of the cube root function.
#
#  Discussion:
#
#    CBRT(X) = real number Y such that Y * Y * Y = X.
#
#    In Mathematica, the function can be evaluated by:
#
#      Sign[x] * ( Abs[x] )^(1/3)
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 14

  fx_vec = np.array ( ( \
    0.0000000000000000E+00, \
   -0.0020082988563383484484E+00, \
    0.44814047465571647087E+00, \
   -0.46415888336127788924E+00, \
    0.73680629972807732116E+00, \
   -1.0000000000000000000E+00, \
    1.2599210498948731648E+00, \
   -1.4422495703074083823E+00, \
    1.4645918875615232630E+00, \
   -2.6684016487219448673E+00, \
    3.0723168256858472933E+00, \
   -4.1408177494228532500E+00, \
    4.5947008922070398061E+00, \
   -497.93385921817447440E+00 ) )

  x_vec = np.array ( ( \
     0.0000000000000000E+00, \
    -0.8100000073710001E-08, \
     0.9000000000000000E-01, \
    -0.1000000000000000E+00, \
     0.4000000000000000E+00, \
    -0.1000000000000000E+01, \
     0.2000000000000000E+01, \
    -0.3000000000000000E+01, \
     0.3141592653589793E+01, \
    -0.1900000000000000E+02, \
     0.2900000000000000E+02, \
    -0.7100000000000000E+02, \
     0.9700000000000000E+02, \
    -0.1234567890000000E+09 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def cbrt_values_test ( ):

#*****************************************************************************80
#
## cbrt_values_test() tests cbrt_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cbrt_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cbrt_values stores values of the cube root function.' )
  print ( '' )
  print ( '      X         CBRT(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = cbrt_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cbrt_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cheby_t01_poly_values ( n_data ):

#*****************************************************************************80
#
## cheby_t01_poly_values: values of shifted Chebyshev polynomials T01(n,x).
#
#  Discussion:
#
#    T01(n,x) = T(n,2*x-1)
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 25

  fx_vec = np.array ( ( \
     0.0000000000000000, \
     1.0000000000000000, \
     0.7000000000000000, \
    -0.0200000000000000, \
    -0.7280000000000000, \
    -0.9992000000000000, \
    -0.6708800000000000, \
     0.0599680000000000, \
     0.7548352000000000, \
     0.9968012800000000, \
     0.6406865920000000, \
    -0.0998400512000000, \
    -0.7804626636800000, \
    -0.9928076779520000, \
    -1.0000000000000000, \
     0.2063872000000000, \
    -0.9784704000000000, \
     0.2580224000000000, \
     0.9870208000000000, \
     0.0000000000000000, \
    -0.9870208000000000, \
    -0.2580224000000000, \
     0.9784704000000000, \
    -0.2063872000000000, \
     1.0000000000000000 ) )

  n_vec = np.array ( ( \
    -1, \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10, 11, \
    12,  7,  7, \
     7,  7,  7, \
     7,  7,  7, \
     7,  7,  7 ))

  x_vec = np.array ( ( \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.00, \
    0.10, \
    0.20, \
    0.30, \
    0.40, \
    0.50, \
    0.60, \
    0.70, \
    0.80, \
    0.90, \
    1.00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    fx = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, fx

def cheby_t01_poly_values_test ( ):

#*****************************************************************************80
#
## cheby_t01_poly_values_test() tests cheby_t01_poly_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 July 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cheby_t01_poly_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cheby_t01_poly_values: values of the shifted Chebyshev T polynomials.' )
  print ( '' )
  print ( '      N            X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, fx = cheby_t01_poly_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cheby_t01_poly_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cheby_t_poly_values ( n_data ):

#*****************************************************************************80
#
## cheby_t_poly_values returns values of Chebyshev polynomials T(n,x).
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      ChebyshevT[n,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real FX, the value of the function.
#
  n_max = 13;

  fx_vec = [ \
 ];

  n_vec = [ \
 ];

  x_vec = [ \
 ];

  import numpy as np

  n_max = 13

  fx_vec = np.array ( ( \
      0.1000000000000000E+01, \
      0.8000000000000000E+00, \
      0.2800000000000000E+00, \
     -0.3520000000000000E+00, \
     -0.8432000000000000E+00, \
     -0.9971200000000000E+00, \
     -0.7521920000000000E+00, \
     -0.2063872000000000E+00, \
      0.4219724800000000E+00, \
      0.8815431680000000E+00, \
      0.9884965888000000E+00, \
      0.7000513740800000E+00, \
      0.1315856097280000E+00 ) )

  n_vec = np.array ( ( \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10, 11, \
    12 ))

  x_vec = np.array ( ( \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    fx = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, fx

def cheby_t_poly_values_test ( ):

#*****************************************************************************80
#
## cheby_t_poly_values_test() tests cheby_t_poly_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cheby_t_poly_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cheby_t_poly_values stores values of the Bernoulli polynomials.' )
  print ( '' )
  print ( '      N            X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, fx = cheby_t_poly_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cheby_t_poly_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cheby_u01_poly_values ( n_data ):

#*****************************************************************************80
#
## cheby_u01_poly_values: values of shifted Chebyshev polynomials U01(n,x).
#
#  Discussion:
#
#    U01(n,x) = U(n,2*x-1)
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 25

  fx_vec = np.array ( ( \
     0.000000000000000, \
     1.000000000000000, \
     1.400000000000000, \
     0.9600000000000000, \
    -0.05600000000000000, \
    -1.038400000000000, \
    -1.397760000000000, \
    -0.9184640000000000, \
     0.1119104000000000, \
     1.075138560000000, \
     1.393283584000000, \
     0.8754584576000000, \
    -0.1676417433600000, \
    -1.110156898304000, \
    -8.000000000000000, \
     1.511014400000000, \
    -1.133260800000000, \
    -0.1636352000000000, \
     1.019801600000000, \
     0.000000000000000, \
    -1.019801600000000, \
     0.1636352000000000, \
     1.133260800000000, \
    -1.511014400000000, \
     8.000000000000000  ) )

  n_vec = np.array ( ( \
    -1, \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10, 11, \
    12,  7,  7, \
     7,  7,  7, \
     7,  7,  7, \
     7,  7,  7 ))

  x_vec = np.array ( ( \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.00, \
    0.10, \
    0.20, \
    0.30, \
    0.40, \
    0.50, \
    0.60, \
    0.70, \
    0.80, \
    0.90, \
    1.00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    fx = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, fx

def cheby_u01_poly_values_test ( ):

#*****************************************************************************80
#
## cheby_u01_poly_values_test() tests cheby_u01_poly_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 July 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cheby_u01_poly_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cheby_u01_poly_values: values of the shifted Chebyshev U polynomials.' )
  print ( '' )
  print ( '      N            X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, fx = cheby_u01_poly_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cheby_u01_poly_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cheby_u_poly_values ( n_data ):

#*****************************************************************************80
#
## cheby_u_poly_values returns values of Chebyshev polynomials U(n,x).
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      ChebyshevU[n,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    09 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 13

  fx_vec = np.array ( ( \
      0.1000000000000000E+01, \
      0.1600000000000000E+01, \
      0.1560000000000000E+01, \
      0.8960000000000000E+00, \
     -0.1264000000000000E+00, \
     -0.1098240000000000E+01, \
     -0.1630784000000000E+01, \
     -0.1511014400000000E+01, \
     -0.7868390400000000E+00, \
      0.2520719360000000E+00, \
      0.1190154137600000E+01, \
      0.1652174684160000E+01, \
      0.1453325357056000E+01 ) )

  n_vec = np.array ( ( \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10, 11, \
    12 ))

  x_vec = np.array ( ( \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    fx = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, fx

def cheby_u_poly_values_test ( ):

#*****************************************************************************80
#
## cheby_u_poly_values_test() tests cheby_u_poly_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    09 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cheby_u_poly_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cheby_u_poly_values stores values of the Chebyshev U polynomials.' )
  print ( '' )
  print ( '      N            X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, fx = cheby_u_poly_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cheby_u_poly_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cheby_v01_poly_values ( n_data ):

#*****************************************************************************80
#
## cheby_v01_poly_values: values of shifted Chebyshev polynomials V01(n,x).
#
#  Discussion:
#
#    V01(n,x) = V(n,2*x-1)
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 25

  fx_vec = np.array ( ( \
     0.0000000000000000, \
     1.0000000000000000, \
     0.4000000000000000, \
    -0.4400000000000000, \
    -1.0160000000000000, \
    -0.9824000000000000, \
    -0.3593600000000000, \
     0.4792960000000000, \
     1.0303744000000000, \
     0.9632281600000000, \
     0.3181450240000000, \
    -0.5178251264000000, \
    -1.0431002009600000, \
    -0.9425151549440000, \
    -15.000000000000000, \
     3.1417984000000000, \
    -1.3912448000000000, \
    -1.2177792000000000, \
     1.1837056000000000, \
     1.0000000000000000, \
    -0.8558976000000000, \
    -0.8905088000000000, \
     0.8752768000000000, \
     0.1197696000000000, \
     1.0000000000000000 ) )

  n_vec = np.array ( ( \
    -1, \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10, 11, \
    12,  7,  7, \
     7,  7,  7, \
     7,  7,  7, \
     7,  7,  7 ))

  x_vec = np.array ( ( \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.00, \
    0.10, \
    0.20, \
    0.30, \
    0.40, \
    0.50, \
    0.60, \
    0.70, \
    0.80, \
    0.90, \
    1.00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    fx = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, fx

def cheby_v01_poly_values_test ( ):

#*****************************************************************************80
#
## cheby_v01_poly_values_test() tests cheby_v01_poly_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 July 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cheby_v01_poly_values_test:' )
  print ( '  cheby_v01_poly_values: values of the shifted Chebyshev V polynomials.' )
  print ( '' )
  print ( '      N            X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, fx = cheby_v01_poly_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cheby_v01_poly_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cheby_v_poly_values ( n_data ):

#*****************************************************************************80
#
## cheby_v_poly_values returns values of Chebyshev polynomials V(n,x).
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      u = Sqrt[(x+1)/2],
#      ChebyshevT[2*n+1,u] / u
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    10 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 14

  fx_vec = np.array ( ( \
     0.0000000000000000E+00, \
     1.0000000000000000E+00, \
     0.6000000000000000E+00, \
    -0.0400000000000000E+00, \
    -0.6640000000000000E+00, \
    -1.0224000000000000E+00, \
    -0.9718400000000000E+00, \
    -0.5325440000000000E+00, \
     0.1197696000000000E+00, \
     0.7241753600000000E+00, \
     1.0389109760000000E+00, \
     0.9380822016000000E+00, \
     0.4620205465600000E+00, \
    -0.1988493271040000E+00 ) )

  n_vec = np.array ( ( \
    -1, \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10, 11, \
    12 ))

  x_vec = np.array ( ( \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    fx = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, fx

def cheby_v_poly_values_test ( ):

#*****************************************************************************80
#
## cheby_v_poly_values_test() tests cheby_v_poly_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cheby_v_poly_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cheby_v_poly_values stores values of the Chebyshev V polynomials.' )
  print ( '' )
  print ( '      N            X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, fx = cheby_v_poly_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cheby_v_poly_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cheby_w01_poly_values ( n_data ):

#*****************************************************************************80
#
## cheby_w01_poly_values: values of shifted Chebyshev polynomials W01(n,x).
#
#  Discussion:
#
#    W01(n,x) = W(n,2*x-1)
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 25

  fx_vec = np.array ( ( \
     0.000000000000000, \
     1.000000000000000, \
     2.400000000000000, \
     2.360000000000000, \
     0.904000000000000, \
    -1.094400000000000, \
    -2.436160000000000, \
    -2.316224000000000, \
    -0.806553600000000, \
     1.187048960000000, \
     2.468422144000000, \
     2.268742041600000, \
     0.707816714240000, \
    -1.277798641664000, \
    -1.000000000000000, \
    -0.119769600000000, \
    -0.875276800000000, \
     0.890508800000000, \
     0.855897600000000, \
    -1.000000000000000, \
    -1.183705600000000, \
     1.217779200000000, \
     1.391244800000000, \
    -3.141798400000000, \
     15.00000000000000 ) )

  n_vec = np.array ( ( \
    -1, \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10, 11, \
    12,  7,  7, \
     7,  7,  7, \
     7,  7,  7, \
     7,  7,  7 ))

  x_vec = np.array ( ( \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.00, \
    0.10, \
    0.20, \
    0.30, \
    0.40, \
    0.50, \
    0.60, \
    0.70, \
    0.80, \
    0.90, \
    1.00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    fx = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, fx

def cheby_w01_poly_values_test ( ):

#*****************************************************************************80
#
## cheby_w01_poly_values_test() tests cheby_w01_poly_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 July 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cheby_w01_poly_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cheby_w01_poly_values: values of the shifted Chebyshev W polynomials.' )
  print ( '' )
  print ( '      N            X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, fx = cheby_w01_poly_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cheby_w01_poly_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cheby_w_poly_values ( n_data ):

#*****************************************************************************80
#
## cheby_w_poly_values returns values of Chebyshev polynomials W(n,x).
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      u = Sqrt[(x+1)/2],
#      ChebyshevU[2*n,u]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    10 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 14

  fx_vec = np.array ( ( \
     0.000000000000000E+00, \
     1.000000000000000E+00, \
     2.600000000000000E+00, \
     3.160000000000000E+00, \
     2.456000000000000E+00, \
     0.769600000000000E+00, \
    -1.224640000000000E+00, \
    -2.729024000000000E+00, \
    -3.141798400000000E+00, \
    -2.297853440000000E+00, \
    -0.534767104000000E+00, \
     1.442226073600000E+00, \
     2.842328821760000E+00, \
     3.105500041216000E+00 ) )

  n_vec = np.array ( ( \
    -1, \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10, 11, \
    12 ))

  x_vec = np.array ( ( \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00, \
     0.8E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    fx = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, fx

def cheby_w_poly_values_test ( ):

#*****************************************************************************80
#
## cheby_w_poly_values_test() tests cheby_w_poly_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cheby_w_poly_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cheby_w_poly_values stores values of the Chebyshev W polynomials.' )
  print ( '' )
  print ( '      N            X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, fx = cheby_w_poly_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cheby_w_poly_values_test:' )
  print ( '  Normal end of execution.' )
  return

def chi_square_cdf_values ( n_data ):

#*****************************************************************************80
#
## chi_square_cdf_values returns some values of the Chi-Square CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = ChiSquareDistribution [ df ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer A, the parameter of the function.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  a_vec = np.array ( ( \
     1,  2,  1,  2, \
     1,  2,  3,  4, \
     1,  2,  3,  4, \
     5,  3,  3,  3, \
     3,  3, 10, 10, \
    10  ) )

  f_vec = np.array ( ( \
     0.7965567455405796E-01, \
     0.4987520807317687E-02, \
     0.1124629160182849E+00, \
     0.9950166250831946E-02, \
     0.4729107431344619E+00, \
     0.1812692469220181E+00, \
     0.5975750516063926E-01, \
     0.1752309630642177E-01, \
     0.6826894921370859E+00, \
     0.3934693402873666E+00, \
     0.1987480430987992E+00, \
     0.9020401043104986E-01, \
     0.3743422675270363E-01, \
     0.4275932955291202E+00, \
     0.6083748237289110E+00, \
     0.7385358700508894E+00, \
     0.8282028557032669E+00, \
     0.8883897749052874E+00, \
     0.1721156299558408E-03, \
     0.3659846827343712E-02, \
     0.1857593622214067E-01 ) )

  x_vec = np.array ( ( \
     0.01E+00, \
     0.01E+00, \
     0.02E+00, \
     0.02E+00, \
     0.40E+00, \
     0.40E+00, \
     0.40E+00, \
     0.40E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     2.00E+00, \
     3.00E+00, \
     4.00E+00, \
     5.00E+00, \
     6.00E+00, \
     1.00E+00, \
     2.00E+00, \
     3.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, x, f

def chi_square_cdf_values_test ( ):

#*****************************************************************************80
#
## chi_square_cdf_values_test() tests chi_square_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'chi_square_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  chi_square_cdf_values stores values of the Chi Square CDF.' )
  print ( '' )
  print ( '      A       X        chi_square_cdf' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, x, f = chi_square_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12f  %24.16g' % ( a, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'chi_square_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def chi_square_noncentral_cdf_values ( n_data ):

#*****************************************************************************80
#
## chi_square_noncentral_cdf_values returns values of the noncentral chi CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = NoncentralChiSquareDistribution [ df, lambda ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    24 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer DF, the number of degrees of freedom.
#
#    real LAMBDA, the noncentrality parameter.
#
#    real X, the argument of the function.
#
#    real F, the noncentral chi CDF.
#
  import numpy as np

  n_max = 28

  df_vec = np.array ( ( \
      1,   2,   3, \
      1,   2,   3, \
      1,   2,   3, \
      1,   2,   3, \
     60,  80, 100, \
      1,   2,   3, \
     10,  10,  10, \
     10,  10,  10, \
     10,  10,  10, \
      8 ) )

  f_vec = np.array ( ( \
     0.8399444269398261E+00, \
     0.6959060300435139E+00, \
     0.5350879697078847E+00, \
     0.7647841496310313E+00, \
     0.6206436532195436E+00, \
     0.4691667375373180E+00, \
     0.3070884345937569E+00, \
     0.2203818092990903E+00, \
     0.1500251895581519E+00, \
     0.3071163194335791E-02, \
     0.1763982670131894E-02, \
     0.9816792594625022E-03, \
     0.1651753140866208E-01, \
     0.2023419573950451E-03, \
     0.4984476352854074E-06, \
     0.1513252400654827E-01, \
     0.2090414910614367E-02, \
     0.2465021206048452E-03, \
     0.2636835050342939E-01, \
     0.1857983220079215E-01, \
     0.1305736595486640E-01, \
     0.5838039534819351E-01, \
     0.4249784402463712E-01, \
     0.3082137716021596E-01, \
     0.1057878223400849E+00, \
     0.7940842984598509E-01, \
     0.5932010895599639E-01, \
     0.2110395656918684E+00 ) )

  lam_vec = np.array ( ( \
       0.5E+00, \
       0.5E+00, \
       0.5E+00, \
       1.0E+00, \
       1.0E+00, \
       1.0E+00, \
       5.0E+00, \
       5.0E+00, \
       5.0E+00, \
      20.0E+00, \
      20.0E+00, \
      20.0E+00, \
      30.0E+00, \
      30.0E+00, \
      30.0E+00, \
       5.0E+00, \
       5.0E+00, \
       5.0E+00, \
       2.0E+00, \
       3.0E+00, \
       4.0E+00, \
       2.0E+00, \
       3.0E+00, \
       4.0E+00, \
       2.0E+00, \
       3.0E+00, \
       4.0E+00, \
       0.5E+00 ) )

  x_vec = np.array ( ( \
      3.000E+00, \
      3.000E+00, \
      3.000E+00, \
      3.000E+00, \
      3.000E+00, \
      3.000E+00, \
      3.000E+00, \
      3.000E+00, \
      3.000E+00, \
      3.000E+00, \
      3.000E+00, \
      3.000E+00, \
     60.000E+00, \
     60.000E+00, \
     60.000E+00, \
      0.050E+00, \
      0.050E+00, \
      0.050E+00, \
      4.000E+00, \
      4.000E+00, \
      4.000E+00, \
      5.000E+00, \
      5.000E+00, \
      5.000E+00, \
      6.000E+00, \
      6.000E+00, \
      6.000E+00, \
      5.000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    df = 0
    lam = 0.0
    x = 0.0
    f = 0.0
  else:
    df = df_vec[n_data]
    lam = lam_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, df, lam, x, f

def chi_square_noncentral_cdf_values_test ( ):

#*****************************************************************************80
#
## chi_square_noncentral_cdf_values_test() tests chi_square_noncentral_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'chi_square_noncentral_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  chi_square_noncentral_cdf_values: values of the noncentral Chi Square CDF.' )
  print ( '' )
  print ( '      DF      LAM      X        chi_square_noncentral_cdf' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, df, lam, x, f = chi_square_noncentral_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12f  %12f  %24.16g' % ( df, lam, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'chi_square_noncentral_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def chi_square_pdf_values ( n_data ):

#*****************************************************************************80
#
## chi_square_pdf_values returns some values of the Chi-Square PDF.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real DF, the degrees of freedom.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  df_vec = np.array ( ( \
     1.0,  2.0,  1.0,  2.0,  1.0,  \
     2.0,  3.0,  4.0,  1.0,  2.0,  \
     3.0,  4.0,  5.0,  3.0,  3.0,  \
     3.0,  3.0,  3.0, 10.0, 10.0, \
    10.0 ))

  f_vec = np.array ( ( \
         3.969525474770117, \
        0.4975062395963412, \
         2.792879016972342, \
        0.4950249168745841, \
        0.5164415474672784, \
        0.4093653765389909, \
        0.2065766189869113, \
       0.08187307530779819, \
        0.2419707245191434, \
        0.3032653298563167, \
        0.2419707245191434, \
        0.1516326649281584, \
       0.08065690817304777, \
        0.2075537487102974, \
        0.1541803298037693, \
        0.1079819330263761, \
       0.07322491280963248, \
       0.04865217332964145, \
     0.0007897534631674914, \
       0.00766415502440505, \
       0.02353325907815472 ))

  x_vec = np.array ( ( \
     0.01E+00, \
     0.01E+00, \
     0.02E+00, \
     0.02E+00, \
     0.40E+00, \
     0.40E+00, \
     0.40E+00, \
     0.40E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     2.00E+00, \
     3.00E+00, \
     4.00E+00, \
     5.00E+00, \
     6.00E+00, \
     1.00E+00, \
     2.00E+00, \
     3.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    df = 0.0
    x = 0.0
    f = 0.0
  else:
    df = df_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, df, x, f

def chi_square_pdf_values_test ( ):

#*****************************************************************************80
#
## chi_square_pdf_values_test() tests chi_square_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 July 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'chi_square_pdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  chi_square_pdf_values stores values of the Chi Square PDF.' )
  print ( '' )
  print ( '      DF      X        chi_square_pdf' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, df, x, f = chi_square_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %24.16g' % ( df, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'chi_square_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def chi_values ( n_data ):

#*****************************************************************************80
#
## chi_values returns some values of the hyperbolic cosine integral function.
#
#  Discussion:
#
#      CHI(X) = gamma + log ( x ) 
#        + integral ( 0 <= T < X ) ( cosh ( T ) - 1 ) / T  dT
#
#    where gamma is Euler's constant.
#
#    In Mathematica, the function can be evaluated by:
#
#      CoshIntegral[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    25 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 16

  fx_vec = np.array ( ( \
    -0.05277684495649362, \
     0.1577508933739787, \
     0.3455691756953907, \
     0.5183999848333915, \
     0.6813138871854339, \
     0.8378669409802082, \
     1.141841924170595, \
     1.445494075789644, \
     1.759505807660965, \
     2.092577214062032, \
     2.452666922646915, \
     3.524425488354165, \
     4.960392094765610, \
     6.959191927647393, \
     9.813547558823186, \
    13.96581164859243 ) )

  x_vec = np.array ( ( \
      0.5E+00, \
      0.6E+00, \
      0.7E+00, \
      0.8E+00, \
      0.9E+00, \
      1.0E+00, \
      1.2E+00, \
      1.4E+00, \
      1.6E+00, \
      1.8E+00, \
      2.0E+00, \
      2.5E+00, \
      3.0E+00, \
      3.5E+00, \
      4.0E+00, \
      4.5E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def chi_values_test ( ):

#*****************************************************************************80
#
## chi_values_test() tests chi_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    25 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'chi_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  chi_values stores values of the hyperbolic cosine integral function.' )
  print ( '' )
  print ( '      X         CHI(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = chi_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'chi_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cinh_values ( n_data ):

#*****************************************************************************80
#
## cinh_values returns some values of the alternate hyperbolic cosine integral function.
#
#  Discussion:
#
#    The alternate hyperbolic cosine integral is defined by
#
#      CINH(X) =integral ( 0 <= T < X ) ( cosh ( T ) - 1 ) / T  dT
#
#    In Mathematica, the function can be evaluated by:
#
#      Integrate [ ( Cosh[t] - 1 ) / t, { t, 0, x } ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    26 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 17

  fx_vec = np.array ( ( \
     0.00000000000000000, \
     0.06315467070191883, \
     0.09136085223843649, \
     0.1250284547325902, \
     0.1643278712460683, \
     0.2094587379417273, \
     0.2606512760786754, \
     0.3823047024751071, \
     0.5318061742668980, \
     0.7122865135136963, \
     0.9275748842583805, \
     1.182304077185436, \
     2.030919091578478, \
     3.284564141195967, \
     5.129213294250493, \
     7.850037532801762, \
    11.88451858691463 ) )

  x_vec = np.array ( ( \
     0.0, \
     0.5, \
     0.6, \
     0.7, \
     0.8, \
     0.9, \
     1.0, \
     1.2, \
     1.4, \
     1.6, \
     1.8, \
     2.0, \
     2.5, \
     3.0, \
     3.5, \
     4.0, \
     4.5 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def cinh_values_test ( ):

#*****************************************************************************80
#
## cinh_values_test() tests cinh_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    26 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cinh_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cinh_values: values of the alternate hyperbolic cosine integral function.' )
  print ( '' )
  print ( '      X         CINH(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = cinh_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cinh_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cin_values ( n_data ):

#*****************************************************************************80
#
## cin_values returns some values of the alternate cosine integral function.
#
#  Discussion:
#
#    The alternate cosine integral is defined by
#
#      CIN(X) = gamma + log(X) + integral ( 0 <= T <= X ) ( cos ( T ) - 1 ) / T  dT
#
#    In Mathematica, the function can be evaluated by:
#
#      EulerGamma + Log[x] - CosIntegral[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    28 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 16

  fx_vec = np.array ( ( \
     0.6185256314820045E-01, \
     0.8866074809482194E-01, \
     0.1200260139539026E+00, \
     0.1557934976348559E+00, \
     0.1957873187759337E+00, \
     0.2398117420005647E+00, \
     0.3390780388012470E+00, \
     0.4516813164280685E+00, \
     0.5754867772153906E+00, \
     0.7081912003853150E+00, \
     0.8473820166866132E+00, \
     0.1207635200410304E+01, \
     0.1556198167561642E+01, \
     0.1862107181909382E+01, \
     0.2104491723908354E+01, \
     0.2274784183779546E+01 ) )

  x_vec = np.array ( ( \
     0.5E+00, \
     0.6E+00, \
     0.7E+00, \
     0.8E+00, \
     0.9E+00, \
     1.0E+00, \
     1.2E+00, \
     1.4E+00, \
     1.6E+00, \
     1.8E+00, \
     2.0E+00, \
     2.5E+00, \
     3.0E+00, \
     3.5E+00, \
     4.0E+00, \
     4.5E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def cin_values_test ( ):

#*****************************************************************************80
#
## cin_values_test() tests cin_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    28 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cin_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cin_values stores values of the alternate cosine integral function.' )
  print ( '' )
  print ( '      X         CIN(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = cin_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cin_values_test:' )
  print ( '  Normal end of execution.' )
  return

def ci_values ( n_data ):

#*****************************************************************************80
#
## ci_values returns some values of the cosine integral function.
#
#  Discussion:
#
#    The cosine integral is defined by
#
#      CI(X) = - integral ( X <= T < Infinity ) ( cos ( T ) ) / T  dT
#
#    In Mathematica, the function can be evaluated by:
#
#      CosIntegral[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    29 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 16

  fx_vec = np.array ( ( \
     -0.1777840788066129E+00, \
     -0.2227070695927976E-01, \
      0.1005147070088978E+00, \
      0.1982786159524672E+00, \
      0.2760678304677729E+00, \
      0.3374039229009681E+00, \
      0.4204591828942405E+00, \
      0.4620065850946773E+00, \
      0.4717325169318778E+00, \
      0.4568111294183369E+00, \
      0.4229808287748650E+00, \
      0.2858711963653835E+00, \
      0.1196297860080003E+00, \
     -0.3212854851248112E-01, \
     -0.1409816978869304E+00, \
     -0.1934911221017388E+00 ) )

  x_vec = np.array ( ( \
      0.5E+00, \
      0.6E+00, \
      0.7E+00, \
      0.8E+00, \
      0.9E+00, \
      1.0E+00, \
      1.2E+00, \
      1.4E+00, \
      1.6E+00, \
      1.8E+00, \
      2.0E+00, \
      2.5E+00, \
      3.0E+00, \
      3.5E+00, \
      4.0E+00, \
      4.5E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def ci_values_test ( ):

#*****************************************************************************80
#
## ci_values_test() tests ci_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    29 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'ci_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  ci_values stores values of the cosine integral function.' )
  print ( '' )
  print ( '      X         CI(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = ci_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'ci_values_test:' )
  print ( '  Normal end of execution.' )
  return

def clausen_values ( n_data ):

#*****************************************************************************80
#
## clausen_values returns some values of the Clausen's integral.
#
#  Discussion:
#
#    The function is defined by:
#
#      CLAUSEN(x) = Integral ( 0 <= t <= x ) -ln ( 2 * sin ( t / 2 ) ) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    30 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964, page 1006.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
      0.14137352886760576684E-01, \
      0.13955467081981281934E+00, \
     -0.38495732156574238507E+00, \
      0.84831187770367927099E+00, \
      0.10139591323607685043E+01, \
     -0.93921859275409211003E+00, \
      0.72714605086327924743E+00, \
      0.43359820323553277936E+00, \
     -0.98026209391301421161E-01, \
     -0.56814394442986978080E+00, \
     -0.70969701784448921625E+00, \
      0.99282013254695671871E+00, \
     -0.98127747477447367875E+00, \
     -0.64078266570172320959E+00, \
      0.86027963733231192456E+00, \
      0.39071647608680211043E+00, \
      0.47574793926539191502E+00, \
      0.10105014481412878253E+01, \
      0.96332089044363075154E+00, \
     -0.61782699481929311757E+00 ) )

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
      -0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
      -1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
      -3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
      -5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
     -10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
     -30.0000000000E+00, \
      50.0000000000E+00  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def clausen_values_test ( ):

#*****************************************************************************80
#
## clausen_values_test() tests clausen_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    30 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'clausen_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  clausen_values stores values of the Clausen integral function.' )
  print ( '' )
  print ( '      X         F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = clausen_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'clausen_values_test:' )
  print ( '  Normal end of execution.' )
  return

def clebsch_gordan_values ( n_data ):

#*****************************************************************************80
#
## clebsch_gordan_values returns some values of the Clebsch-Gordan function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      ClebschGordan[{j1,m1},{j2,m2},{j3,m3}]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real J1, J2, J3, M1, M2, M3, the arguments
#    of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 12

  f_vec = np.array ( ( \
     0.7071067811865475, \
     1.000000000000000, \
     0.5773502691896258, \
    -0.2581988897471611, \
    -0.6324555320336759, \
    -0.7745966692414834, \
     0.4082482904638630, \
     0.8164965809277260, \
     0.5345224838248488, \
     0.2672612419124244, \
     0.8944271909999159, \
     0.3380617018914066 ))
  j1_vec = np.array ( ( \
    0.5, \
    0.5, \
    0.5, \
    1.0, \
    1.0, \
    1.0, \
    1.0, \
    1.0, \
    2.0, \
    2.0, \
    1.5, \
    1.5 ))
  j2_vec = np.array ( ( \
    0.5, \
    0.5, \
    1.0, \
    1.5, \
    1.5, \
    1.5, \
    1.0, \
    1.0, \
    2.0, \
    2.0, \
    2.0, \
    2.0 ))
  j3_vec = np.array ( ( \
    1.0, \
    1.0, \
    1.5, \
    1.5, \
    1.5, \
    1.5, \
    2.0, \
    2.0, \
    2.0, \
    2.0, \
    2.5, \
    3.5 ))
  m1_vec = np.array ( ( \
    0.5, \
    0.5, \
   -0.5, \
    0.0, \
   -1.0, \
    0.0, \
    1.0, \
    0.0, \
    2.0, \
    1.0, \
    0.5, \
    1.5 ))
  m2_vec = np.array ( ( \
   -0.5, \
    0.5, \
    1.0, \
    0.5, \
    1.5, \
    1.5, \
   -1.0, \
    0.0, \
   -2.0, \
   -1.0, \
    1.0, \
   -1.0 ))
  m3_vec = np.array ( ( \
    0.0, \
    1.0, \
    0.5, \
    0.5, \
    0.5, \
    1.5, \
    0.0, \
    0.0, \
    0.0, \
    0.0, \
    1.5, \
    0.5 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    j1 = 0
    j2 = 0
    j3 = 0
    m1 = 0
    m2 = 0
    m3 = 0
    f = 0.0
  else:
    j1 = j1_vec[n_data]
    j2 = j2_vec[n_data]
    j3 = j3_vec[n_data]
    m1 = m1_vec[n_data]
    m2 = m2_vec[n_data]
    m3 = m3_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, j1, j2, j3, m1, m2, m3, f

def clebsch_gordan_values_test ( ):

#*****************************************************************************80
#
## clebsch_gordan_values_test() tests clebsch_gordan_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'clebsch_gordan_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  clebsch_gordan_values returns value of the Clebsch-Gordan coefficient.' )
  print ( '' )
  print ( '      J1      J2      J3      M1      M2      M3        CG' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, j1, j2, j3, m1, m2, m3, f = clebsch_gordan_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6.2f  %6.2f  %6.2f  %6.2f  %6.2f  %6.2f  %24.16f' \
      % ( j1, j2, j3, m1, m2, m3, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'clebsch_gordan_values_test:' )
  print ( '  Normal end of execution.' )
  return

def collatz_count_values ( n_data ):

#*****************************************************************************80
#
## collatz_count_values returns some values of the Collatz count function.
#
#  Discussion:
#
#    The rules for generation of the Collatz sequence are recursive.
#    If T is the current entry of the sequence, (T is
#    assumed to be a positive integer), then the next
#    entry, U is determined as follows:
#
#      if T is 1 (or less)
#        terminate the sequence;
#      else if T is even
#        U = T/2.
#      else (if T is odd and not 1)
#        U = 3*T+1;
#
#    The Collatz count is the length of the Collatz sequence for a given
#    starting value.  By convention, we include the initial value in the
#    count, so the minimum value of the count is 1.
#
#     N  Sequence                                                 Count
#
#     1                                                               1
#     2   1                                                           2
#     3  10,  5, 16,  8,  4,  2,  1                                   8
#     4   2   1                                                       3
#     5  16,  8,  4,  2,  1                                           6
#     6   3, 10,  5, 16,  8,  4,  2,  1                               9
#     7  22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1   17
#     8   4,  2,  1                                                   4
#     9  28, 14,  7, ...                                             20
#    10   5, 16,  8,  4,  2,  1                                       7
#    11  34, 17, 52, 26, 13, 40, 20, 10,  5, 16, 8, 4, 2, 1          15
#    12   6,  3, 10,  5, 16,  8,  4,  2,  1                          10
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    24 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Eric Weisstein,
#    "The Collatz Problem",
#    CRC Concise Encyclopedia of Mathematics,
#    CRC 1998.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the initial value of a Collatz sequence.
#
#    integer COUNT, the length of the Collatz sequence starting
#    with N.
#
  import numpy as np

  n_max = 20

  count_vec = np.array ( ( \
      1,   2,   8,   3,   6,   9,   17,   4,  20,   7, \
    112,  25,  26,  27,  17,  28,  111,  18,  83,  29 ) )

  n_vec = np.array ( ( \
      1,   2,   3,   4,   5,   6,   7,   8,   9,  10, \
     27,  50, 100, 200, 300, 400, 500, 600, 700, 800 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    count = 0
  else:
    n = n_vec[n_data]
    count = count_vec[n_data]
    n_data = n_data + 1

  return n_data, n, count

def collatz_count_values_test ( ):

#*****************************************************************************80
#
## collatz_count_values_test() tests collatz_count_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    24 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'collatz_count_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  collatz_count_values returns values of' )
  print ( '  the length of the Collatz sequence that starts at N.' )
  print ( '' )
  print ( '     N        Count' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, count = collatz_count_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4d  %10d' % ( n, count ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'collatz_count_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cos_degree_values ( n_data ):

#*****************************************************************************80
#
## cos_degree_values: the cosine function with argument in degrees.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Cos[x Degree]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 22

  fx_vec = np.array ( ( \
     0.99619469809174553230, \
     1.0000000000000000000, \
     0.99984769515639123916, \
     0.99939082701909573001, \
     0.99862953475457387378, \
     0.99756405025982424761, \
     0.99619469809174553230, \
     0.98480775301220805937, \
     0.96592582628906828675, \
     0.86602540378443864676, \
     0.70710678118654752440, \
     0.50000000000000000000, \
     0.25881904510252076235, \
     0.087155742747658173558, \
     0.069756473744125300776, \
     0.052335956242943832722, \
     0.034899496702500971646, \
     0.017452406437283512819, \
     0.000000000000000000000, \
    -0.017452406437283512819, \
    -0.25881904510252076235, \
    -1.0000000000000000000 ))

  x_vec = np.array ( ( \
     -5.0, \
      0.0, \
      1.0, \
      2.0, \
      3.0, \
      4.0, \
      5.0, \
     10.0, \
     15.0, \
     30.0, \
     45.0, \
     60.0, \
     75.0, \
     85.0, \
     86.0, \
     87.0, \
     88.0, \
     89.0, \
     90.0, \
     91.0, \
    105.0, \
    180.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def cos_degree_values_test ( ):

#*****************************************************************************80
#
## cos_degree_values_test() tests cos_degree_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cos_degree_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cos_degree_values stores values of the cosine function.' )
  print ( '' )
  print ( '      X         COS(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = cos_degree_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cos_degree_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cosh_values ( n_data ):

#*****************************************************************************80
#
## cosh_values() returns some values of the hyperbolic cosine function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Cosh[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 18

  fx_vec = np.array ( ( \
      74.209948524787844444, \
       1.5430806348152437785, \
       1.0000000000000000000, \
       1.0050041680558035990, \
       1.0200667556190758463, \
       1.0453385141288604850, \
       1.0810723718384548093, \
       1.1276259652063807852, \
       1.1854652182422677038, \
       1.2551690056309430182, \
       1.3374349463048445980, \
       1.4330863854487743878, \
       1.5430806348152437785, \
       3.7621956910836314596, \
      10.067661995777765842, \
      27.308232836016486629, \
      74.209948524787844444, \
   11013.232920103323140 ))

  x_vec = np.array ( ( \
   -5.0, \
   -1.0, \
    0.0, \
    0.1, \
    0.2, \
    0.3, \
    0.4, \
    0.5, \
    0.6, \
    0.7, \
    0.8, \
    0.9, \
    1.0, \
    2.0, \
    3.0, \
    4.0, \
    5.0, \
   10.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def cosh_values_test ( ):

#*****************************************************************************80
#
## cosh_values_test() tests cosh_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cosh_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cosh_values stores values of the hyperbolic cosine function.' )
  print ( '' )
  print ( '      X         COSH(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = cosh_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cosh_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cos_power_int_values ( n_data ):

#*****************************************************************************80
#
## cos_power_int_values returns some values of the cosine power integral.
#
#  Discussion:
#
#    The function has the form
#
#      cos_power_int(A,B,N) = Integral ( A <= T <= B ) ( cos(T) )^N dt
#
#    In Mathematica, the function can be evaluated by:
#
#      Integrate [ ( Cos[x] )^n, { x, a, b } ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, B, the limits of integration.
#
#    integer N, the power.
#
#    real F, the function value.
#
  import numpy as np

  n_max = 11

  a_vec = np.array ( ( \
     0.00, \
     0.00, \
     0.00, \
     0.00, \
     0.00, \
     0.00, \
     0.00, \
     0.00, \
     0.00, \
     0.00, \
     0.00 ))

  b_vec = np.array ( ( \
     3.141592653589793, \
     3.141592653589793, \
     3.141592653589793, \
     3.141592653589793, \
     3.141592653589793, \
     3.141592653589793, \
     3.141592653589793, \
     3.141592653589793, \
     3.141592653589793, \
     3.141592653589793, \
     3.141592653589793  ) )

  f_vec = np.array ( ( \
     3.141592653589793, \
     0.0, \
     1.570796326794897, \
     0.0, \
     1.178097245096172, \
     0.0, \
     0.9817477042468104, \
     0.0, \
     0.8590292412159591, \
     0.0, \
     0.7731263170943632 ) )

  n_vec = np.array ( ( \
     0, \
     1, \
     2, \
     3, \
     4, \
     5, \
     6, \
     7, \
     8, \
     9, \
    10  ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    b = 0.0
    f = 0.0
    n = 0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    f = f_vec[n_data]
    n = n_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, n, f

def cos_power_int_values_test ( ):

#*****************************************************************************80
#
## cos_power_int_values_test() tests cos_power_int_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cos_power_int_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cos_power_int_values stores values of the cosine power integral.' )
  print ( '' )
  print ( '        A             B            N           F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, n, f = cos_power_int_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %6d  %24.16g' % ( a, b, n, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cos_power_int_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cos_values ( n_data ):

#*****************************************************************************80
#
## cos_values returns some values of the cosine function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Cos[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    12 June 2007
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 13

  fx_vec = np.array ( ( \
     1.0000000000000000000, \
     0.96592582628906828675, \
     0.87758256189037271612, \
     0.86602540378443864676, \
     0.70710678118654752440, \
     0.54030230586813971740, \
     0.50000000000000000000, \
     0.00000000000000000000, \
    -0.41614683654714238700, \
    -0.98999249660044545727, \
    -1.0000000000000000000, \
    -0.65364362086361191464, \
     0.28366218546322626447 ))

  x_vec = np.array ( ( \
    0.0000000000000000000, \
    0.26179938779914943654, \
    0.50000000000000000000, \
    0.52359877559829887308, \
    0.78539816339744830962, \
    1.0000000000000000000, \
    1.0471975511965977462, \
    1.5707963267948966192, \
    2.0000000000000000000, \
    3.0000000000000000000, \
    3.1415926535897932385, \
    4.0000000000000000000, \
    5.0000000000000000000 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def cos_values_test ( ):

#*****************************************************************************80
#
## cos_values_test() tests cos_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cos_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cos_values stores values of the cosine function.' )
  print ( '' )
  print ( '      X         COS(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = cos_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cos_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cot_values ( n_data ):

#*****************************************************************************80
#
## cot_values returns some values of the cotangent function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Cot[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 15

  fx_vec = np.array ( ( \
   11.972209353628661620, \
    3.7320508075688772935, \
    1.8304877217124519193, \
    1.7320508075688772935, \
    1.0000000000000000000, \
    0.64209261593433070301, \
    0.57735026918962576451, \
    0.26794919243112270647, \
    0.00000000000000000000, \
    0.13165249758739585347, \
    0.065543462815238228565, \
   -0.45765755436028576375, \
   -7.0152525514345334694, \
    0.86369115445061661395, \
   -0.29581291553274554043 ))

  x_vec = np.array ( ( \
   0.083333333333333333333, \
   0.26179938779914943654, \
   0.50000000000000000000, \
   0.52359877559829887308, \
   0.78539816339744830962, \
   1.0000000000000000000, \
   1.0471975511965977462, \
   1.3089969389957471827, \
   1.5707963267948966192, \
   1.4398966328953219010, \
   1.5053464798451092601, \
   2.0000000000000000000, \
   3.0000000000000000000, \
   4.0000000000000000000, \
   5.0000000000000000000 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def cot_values_test ( ):

#*****************************************************************************80
#
## cot_values_test() tests cot_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cot_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cot_values stores values of the cotangent function.' )
  print ( '' )
  print ( '      X         COT(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = cot_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cot_values_test:' )
  print ( '  Normal end of execution.' )
  return

def cp_values ( n_data ):

#*****************************************************************************80
#
## cp_values returns some values of the specific heat at constant pressure.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Lester Haar, John Gallagher and George Kell,
#    NBS/NRC Steam Tables:
#    Thermodynamic and transport Properties and Computer Programs
#    for Vapor and Liquid States of Water in SI Units,
#    Hemisphere Publishing Corporation, Washington, 1984,
#    TJ270.H3, pages 229-237.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real TC, the temperature, in degrees Celsius.
#
#    real P, the pressure, in bar.
#
#    real CP, the specific heat at constant pressure,
#    in KJ/(kg K).
#
  import numpy as np

  n_max = 24

  cp_vec = np.array ( ( \
     4.228E+00, \
     2.042E+00, \
     1.975E+00, \
     2.013E+00, \
     2.040E+00, \
     2.070E+00, \
     2.135E+00, \
     2.203E+00, \
     2.378E+00, \
     2.541E+00, \
     2.792E+00, \
     2.931E+00, \
     4.226E+00, \
     4.223E+00, \
     4.202E+00, \
     4.177E+00, \
     4.130E+00, \
     4.089E+00, \
     4.053E+00, \
     4.021E+00, \
     3.909E+00, \
     3.844E+00, \
     3.786E+00, \
     2.890E+00  ))

  p_vec = np.array ( ( \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        5.0E+00, \
       10.0E+00, \
       50.0E+00, \
      100.0E+00, \
      200.0E+00, \
      300.0E+00, \
      400.0E+00, \
      500.0E+00, \
     1000.0E+00, \
     1500.0E+00, \
     2000.0E+00, \
     5000.0E+00 ))

  tc_vec = np.array ( ( \
        0.0E+00, \
      100.0E+00, \
      200.0E+00, \
      300.0E+00, \
      350.0E+00, \
      400.0E+00, \
      500.0E+00, \
      600.0E+00, \
      850.0E+00, \
     1100.0E+00, \
     1600.0E+00, \
     2000.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    tc = 0.0
    p = 0.0
    cp = 0.0
  else:
    tc = tc_vec[n_data]
    p = p_vec[n_data]
    cp = cp_vec[n_data]
    n_data = n_data + 1

  return n_data, tc, p, cp

def cp_values_test ( ):

#*****************************************************************************80
#
## cp_values_test() tests cp_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'cp_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  cp_values stores values of the specific heat CP as a function of' )
  print ( '  temperature and pressure.' )
  print ( '' )
  print ( '      T            P            CP(T,P)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, tc, p, cp = cp_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f' % ( tc, p, cp ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'cp_values_test:' )
  print ( '  Normal end of execution.' )
  return

def datenum_values ( n_data ):

#*****************************************************************************80
#
## datenum_values returns the MATLAB DATENUM for various dates.
#
#  Discussion:
#
#    The CE or Common Era calendar is used, under the
#    hybrid Julian/Gregorian Calendar, with a transition from Julian
#    to Gregorian.  The day after 04 October 1582 was 15 October 1582.  
#
#    The year before 1 AD or CE is 1 BC or BCE.  In this data set,
#    years BC/BCE are indicated by a negative year value.  
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 December 2017
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Edward Reingold, Nachum Dershowitz,
#    Calendrical Calculations: The Millennium Edition,
#    Cambridge University Press, 2001,
#    ISBN: 0 521 77752 6
#    LC: CE12.R45.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer Y, M, D, the Common Era date.
#
#    integer DATENUM, the MATLAB datenum value.
#
  import numpy as np

  n_max = 11

  d_vec = np.array ( ( \
     1, \
     1, \
     1, \
     1, \
    17, \
     9, \
    10, \
    12, \
     6, \
    25, \
     1 ))

  date_num_vec = np.array ( ( \
         1, \
       367, \
     36526, \
    365244, \
    708434, \
    710284, \
    713023, \
    718199, \
    723186, \
    729080, \
    730486 ))

  m_vec = np.array ( ( \
     1, \
     1, \
     1, \
     1, \
     8, \
     9, \
     3, \
     5, \
     1, \
     2, \
     1 ))

  y_vec = np.array ( ( \
        0, \
        1, \
      100, \
     1000, \
     1939, \
     1944, \
     1952, \
     1966, \
     1980, \
     1996, \
     2000 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    y = 0
    m = 0
    d = 0
    date_num = 0
  else:
    y = y_vec[n_data]
    m = m_vec[n_data]
    d = d_vec[n_data]
    date_num = date_num_vec[n_data]
    n_data = n_data + 1

  return n_data, y, m, d, date_num

def datenum_values_test ( ):

#*****************************************************************************80
#
## datenum_values_test() tests datenum_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 December 2017
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'datenum_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  datenum_values stores values of' )
  print ( '  the MATLAB datenum for a given Y/M/D date' )
  print ( '' )
  print ( '       Y       M       D   DateNum' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, y, m, d, date_num = datenum_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %6d  %6d    %6d' % ( y, m, d, date_num ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'datenum_values_test:' )
  print ( '  Normal end of execution.' )
  return

def dawson_values ( n_data ):

#*****************************************************************************80
#
## dawson_values returns some values of Dawson's integral.
#
#  Discussion:
#
#    The definition of Dawson's integral is
#
#      D(X) = exp ( -X * X ) * Integral ( 0 <= Y <= X ) exp ( Y * Y ) dY
#
#    Dawson's integral has a maximum at roughly
#
#      X = 0.9241388730
#
#    In Mathematica, the function can be evaluated by:
#
#      Sqrt[Pi] * Exp[-x^2] * I * Erf[I*x] / 2
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Eric Weisstein,
#    CRC Concise Encyclopedia of Mathematics,
#    CRC Press, 1998.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  fx_vec = np.array ( ( \
     0.0000000000000000E+00, \
     0.9933599239785286E-01, \
     0.1947510333680280E+00, \
     0.2826316650213119E+00, \
     0.3599434819348881E+00, \
     0.4244363835020223E+00, \
     0.4747632036629779E+00, \
     0.5105040575592318E+00, \
     0.5321017070563654E+00, \
     0.5407243187262987E+00, \
     0.5380795069127684E+00, \
     0.5262066799705525E+00, \
     0.5072734964077396E+00, \
     0.4833975173848241E+00, \
     0.4565072375268973E+00, \
     0.4282490710853986E+00, \
     0.3999398943230814E+00, \
     0.3725593489740788E+00, \
     0.3467727691148722E+00, \
     0.3229743193228178E+00, \
     0.3013403889237920E+00 ))

  x_vec = np.array ( ( \
     0.0E+00, \
     0.1E+00, \
     0.2E+00, \
     0.3E+00, \
     0.4E+00, \
     0.5E+00, \
     0.6E+00, \
     0.7E+00, \
     0.8E+00, \
     0.9E+00, \
     1.0E+00, \
     1.1E+00, \
     1.2E+00, \
     1.3E+00, \
     1.4E+00, \
     1.5E+00, \
     1.6E+00, \
     1.7E+00, \
     1.8E+00, \
     1.9E+00, \
     2.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def dawson_values_test ( ):

#*****************************************************************************80
#
## dawson_values_test() tests dawson_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'dawson_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  dawson_values stores values of the Dawson integral function.' )
  print ( '' )
  print ( '      X         F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = dawson_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'dawson_values_test:' )
  print ( '  Normal end of execution.' )
  return

def debye1_values ( n_data ):

#*****************************************************************************80
#
## debye1_values returns some values of Debye's function of order 1.
#
#  Discussion:
#
#    The function is defined by:
#
#      debye1(x) = 1 / x * Integral ( 0 <= t <= x ) t / ( exp ( t ) - 1 ) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#      special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#   
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
      0.99951182471380889183E+00, \
      0.99221462647120597836E+00, \
      0.96918395997895308324E+00, \
      0.88192715679060552968E+00, \
      0.77750463411224827642E+00, \
      0.68614531078940204342E+00, \
      0.60694728460981007205E+00, \
      0.53878956907785587703E+00, \
      0.48043521957304283829E+00, \
      0.38814802129793784501E+00, \
      0.36930802829242526815E+00, \
      0.32087619770014612104E+00, \
      0.29423996623154246701E+00, \
      0.27126046678502189985E+00, \
      0.20523930310221503723E+00, \
      0.16444346567994602563E+00, \
      0.10966194482735821276E+00, \
      0.82246701178200016086E-01, \
      0.54831135561510852445E-01, \
      0.32898681336964528729E-01 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
       5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def debye1_values_test ( ):

#*****************************************************************************80
#
## debye1_values_test() tests debye1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'debye1_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  debye1_values stores values of the Debye function of order 1.' )
  print ( '' )
  print ( '      X         F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = debye1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'debye1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def debye2_values ( n_data ):

#*****************************************************************************80
#
## debye2_values returns some values of Debye's function of order 2.
#
#  Discussion:
#
#    The function is defined by:
#
#      debye2(x) = 2 / x^2 * Integral ( 0 <= t <= x ) t^2 / ( exp ( t ) - 1 ) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 September 2004
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#      special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
      0.99934911727904599738E+00, \
      0.98962402299599181205E+00, \
      0.95898426200345986743E+00, \
      0.84372119334725358934E+00, \
      0.70787847562782928288E+00, \
      0.59149637225671282917E+00, \
      0.49308264399053185014E+00, \
      0.41079413579749669069E+00, \
      0.34261396060786351671E+00, \
      0.24055368752127897660E+00, \
      0.22082770061202308232E+00, \
      0.17232915939014138975E+00, \
      0.14724346738730182894E+00, \
      0.12666919046715789982E+00, \
      0.74268805954862854626E-01, \
      0.47971498020121871622E-01, \
      0.21369201683658373846E-01, \
      0.12020564476446432799E-01, \
      0.53424751249537071952E-02, \
      0.19232910450553508562E-02 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
       5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def debye2_values_test ( ):

#*****************************************************************************80
#
## debye2_values_test() tests debye2_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'debye2_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  debye2_values stores values of the Debye function of order 2.' )
  print ( '' )
  print ( '      X         F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = debye2_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'debye2_values_test:' )
  print ( '  Normal end of execution.' )
  return

def debye3_values ( n_data ):

#*****************************************************************************80
#
## debye3_values returns some values of Debye's function of order 3.
#
#  Discussion:
#
#    The function is defined by:
#
#      debye3(x) = 3 / x^3 * Integral ( 0 <= t <= x ) t^3 / ( exp ( t ) - 1 ) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 September 2004
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#      special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
      0.99926776885985461940E+00, \
      0.98833007755734698212E+00, \
      0.95390610472023510237E+00, \
      0.82496296897623372315E+00, \
      0.67441556407781468010E+00, \
      0.54710665141286285468E+00, \
      0.44112847372762418113E+00, \
      0.35413603481042394211E+00, \
      0.28357982814342246206E+00, \
      0.18173691382177474795E+00, \
      0.16277924385112436877E+00, \
      0.11759741179993396450E+00, \
      0.95240802723158889887E-01, \
      0.77581324733763020269E-01, \
      0.36560295673194845002E-01, \
      0.19295765690345489563E-01, \
      0.57712632276188798621E-02, \
      0.24352200674805479827E-02, \
      0.72154882216335666096E-03, \
      0.15585454565440389896E-03 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
       5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def debye3_values_test ( ):

#*****************************************************************************80
#
## debye3_values_test() tests debye3_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'debye3_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  debye3_values stores values of the Debye function of order 3.' )
  print ( '' )
  print ( '      X         F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = debye3_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'debye3_values_test:' )
  print ( '  Normal end of execution.' )
  return

def debye4_values ( n_data ):

#*****************************************************************************80
#
## debye4_values returns some values of Debye's function of order 4.
#
#  Discussion:
#
#    The function is defined by:
#
#      debye4(x) = 4 / x^4 * Integral ( 0 <= t <= x ) t^4 / ( exp ( t ) - 1 ) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#      special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
      0.99921896192761576256E+00, \
      0.98755425280996071022E+00, \
      0.95086788606389739976E+00, \
      0.81384569172034042516E+00, \
      0.65487406888673697092E+00, \
      0.52162830964878715188E+00, \
      0.41189273671788528876E+00, \
      0.32295434858707304628E+00, \
      0.25187863642883314410E+00, \
      0.15185461258672022043E+00, \
      0.13372661145921413299E+00, \
      0.91471377664481164749E-01, \
      0.71227828197462523663E-01, \
      0.55676547822738862783E-01, \
      0.21967566525574960096E-01, \
      0.96736755602711590082E-02, \
      0.19646978158351837850E-02, \
      0.62214648623965450200E-03, \
      0.12289514092077854510E-03, \
      0.15927210319002161231E-04 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
       5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def debye4_values_test ( ):

#*****************************************************************************80
#
## debye4_values_test() tests debye4_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'debye4_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  debye4_values stores values of the Debye function of order 4.' )
  print ( '' )
  print ( '      X         F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = debye4_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'debye4_values_test:' )
  print ( '  Normal end of execution.' )
  return

def dedekind_sum_values ( n_data ):

#*****************************************************************************80
#
## dedekind_sum_values returns some values of the Dedekind sum.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Hans Rademacher, Emil Grosswald,
#    Dedekind Sums,
#    Mathematics Association of America, 1972,
#    LC: QA241.R2.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer P, Q, the arguments of the function.
#
#    integer N, D, the numerator and denominator of the function value.
#
  import numpy as np

  n_max = 95

  p_vec = np.array ( ( \
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1, \
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1, \
     2,  2,  2,  2,  2,  2,  2,  2,  2,  2, \
     3,  3,  3,  3,  3,  3,  3,  3,  3,  3, \
     3,  3,  3,  3,  4,  4,  4,  4,  4,  4, \
     4,  4,  4,  4,  5,  5,  5,  5,  5,  5, \
     5,  5,  5,  5,  5,  5,  5,  5,  5,  5, \
     6,  6,  6,  6,  6,  6,  6,  7,  7,  7, \
     7,  7,  7,  7,  7,  7,  7,  7,  7,  7, \
     7,  7,  7,  7,  7 \
  ))

  q_vec = np.array ( ( \
     1,  2,  3,  4,  5,  6,  7,  8,  9, 10, \
    11, 12, 13, 14, 15, 16, 17, 18, 19, 20, \
     1,  3,  5,  7,  9, 11, 13, 15, 17, 19, \
     1,  2,  4,  5,  7,  8, 10, 11, 13, 14, \
    16, 17, 19, 20,  1,  3,  5,  7,  9, 11, \
    13, 15, 17, 19,  1,  2,  3,  4,  6,  7, \
     8,  9, 11, 12, 13, 14, 16, 17, 18, 19, \
     1,  5,  7, 11, 13, 17, 19,  1,  2,  3, \
     4,  5,  6,  8,  9, 10, 11, 12, 13, 15, \
    16, 17, 18, 19, 20 \
  ))

  n_vec = np.array ( ( \
     0,  0,  1,  1,  1,  5,  5,  7, 14,  3, \
    15, 55, 11, 13, 91, 35, 20, 34, 51, 57, \
     0, -1,  0,  1,  4,  5,  4,  7,  8, 21, \
     0,  0, -1,  0, -1,  1,  0,  3,  1,  3, \
     5,  5,  9,  3,  0,  1, -1,  1, -4,  3, \
    -1, 19,  0, 11,  0,  0, -1,  1, -5, -1, \
    -1,  4, -5, -1,  0,  3, -5,  1,  2, 11, \
     0,  1, -5,  5, -4,  5, -9,  0,  0,  1, \
    -1,  0,  5, -7, -4,  0, -3,  1,  4, -7, \
    -3,  1, -2,  3,  3 \
  ))

  d_vec = np.array ( ( \
     1,  1, 18,  8,  5, 18, 14, 16, 27,  5, \
    22, 72, 13, 14, 90, 32, 17, 27, 38, 40, \
     1, 18,  1, 14, 27, 22, 13, 18, 17, 38, \
     1,  1,  8,  1, 14, 16,  1, 22, 13, 14, \
    32, 17, 38,  8,  1, 18,  5, 14, 27, 22, \
    13, 90,  1, 38,  1,  1, 18,  8, 18, 14, \
    16, 27, 22, 72,  1, 14, 32, 17, 27, 38, \
     1,  5, 14, 22, 13, 17, 38,  1,  1, 18, \
     8,  1, 18, 16, 27,  1, 22, 72, 13, 18, \
    32, 17, 27, 38,  8 \
  ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    p = 0
    q = 0
    n = 0
    d = 0
  else:
    p = p_vec[n_data]
    q = q_vec[n_data]
    n = n_vec[n_data]
    d = d_vec[n_data]
    n_data = n_data + 1

  return n_data, p, q, n, d

def dedekind_sum_values_test ( ):

#*****************************************************************************80
#
## dedekind_sum_values_test() tests dedekind_sum_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'dedekind_sum_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  dedekind_sum_values returns values of the Dedekind sum ' )
  print ( '  (N/D) = dedekind_sum ( P, Q ).' )
  print ( '' )
  print ( '       P       Q       N       D' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, p, q, n, d = dedekind_sum_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %6d  %6d  %6d' % ( p, q, n, d ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'dedekind_sum_values_test:' )
  print ( '  Normal end of execution.' )
  return

def dielectric_values ( n_data ):

#*****************************************************************************80
#
## dielectric_values returns some values of the static dielectric constant.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Lester Haar, John Gallagher and George Kell,
#    NBS/NRC Steam Tables:
#    Thermodynamic and transport Properties and Computer Programs
#      for Vapor and Liquid States of Water in SI Units,
#    Hemisphere Publishing Corporation, Washington, 1984,
#    TJ270.H3, page 266.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real TC, the temperature, in degrees Celsius.
#
#    real P, the pressure, in bar.
#
#    real EPS, the dielectric constant, dimensionless.
#
  import numpy as np

  n_max = 15

  eps_vec = np.array ( ( \
      88.29E+00, \
      90.07E+00, \
      92.02E+00, \
      95.14E+00, \
     100.77E+00, \
      78.85E+00, \
      70.27E+00, \
      62.60E+00, \
      55.78E+00, \
      44.31E+00, \
      35.11E+00, \
      20.40E+00, \
       1.17E+00, \
       1.11E+00, \
       1.08E+00 ))

  p_vec = np.array ( ( \
      100.0E+00, \
      500.0E+00, \
     1000.0E+00, \
     2000.0E+00, \
     5000.0E+00, \
      100.0E+00, \
      100.0E+00, \
      100.0E+00, \
      100.0E+00, \
      100.0E+00, \
      100.0E+00, \
      100.0E+00, \
      100.0E+00, \
      100.0E+00, \
      100.0E+00 ))

  tc_vec = np.array ( ( \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
      25.0E+00, \
      50.0E+00, \
      75.0E+00, \
     100.0E+00, \
     150.0E+00, \
     200.0E+00, \
     300.0E+00, \
     400.0E+00, \
     500.0E+00, \
     600.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    tc = 0.0
    p = 0.0
    eps = 0.0
  else:
    tc = tc_vec[n_data]
    p = p_vec[n_data]
    eps = eps_vec[n_data]
    n_data = n_data + 1

  return n_data, tc, p, eps

def dielectric_values_test ( ):

#*****************************************************************************80
#
## dielectric_values_test() tests dielectric_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'dielectric_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  dielectric_values stores values of the dielectric function.' )
  print ( '' )
  print ( '      T            P            EPS(T,P)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, tc, p, eps = dielectric_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f' % ( tc, p, eps ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'dielectric_values_test:' )
  print ( '  Normal end of execution.' )
  return

def dilogarithm_values ( n_data ):

#*****************************************************************************80
#
## dilogarithm_values returns some values of the dilogarithm function.
#
#  Discussion:
#
#    The dilogarithm is defined as
#
#      Li_2(X) = - Integral ( 0 <= T <= X ) ln ( 1 - T ) / T dT
#
#    The dilogarithm is also known as Spence's integral. 
#
#    In Abramowitz and Stegun form of the function is different,
#    and is equivalent to evaluated Li_2(1-X).
#
#    The dilogarithm is the special case, with N = 2, of the 
#    polylogarithm Li_N(X).
#
#    In Mathematica, the function can be evaluated by:
#
#      PolyLog[2,X]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  fx_vec = np.array ( (
     0.0000000000000000E+00, \
     0.5063929246449603E-01, \
     0.1026177910993911E+00, \
     0.1560350339454831E+00, \
     0.2110037754397048E+00, \
     0.2676526390827326E+00, \
     0.3261295100754761E+00, \
     0.3866059411605865E+00, \
     0.4492829744712817E+00, \
     0.5143989891542119E+00, \
     0.5822405264650125E+00, \
     0.6531576315069018E+00, \
     0.7275863077163334E+00, \
     0.8060826895177240E+00, \
     0.8893776242860387E+00, \
     0.9784693929303061E+00, \
     0.1074794600008248E+01, \
     0.1180581123830255E+01, \
     0.1299714723004959E+01, \
     0.1440633796970039E+01, \
     0.1644934066848226E+01 ))

  x_vec = np.array ( (
     0.00E+00, \
     0.05E+00, \
     0.10E+00, \
     0.15E+00, \
     0.20E+00, \
     0.25E+00, \
     0.30E+00, \
     0.35E+00, \
     0.40E+00, \
     0.45E+00, \
     0.50E+00, \
     0.55E+00, \
     0.60E+00, \
     0.65E+00, \
     0.70E+00, \
     0.75E+00, \
     0.80E+00, \
     0.85E+00, \
     0.90E+00, \
     0.95E+00, \
     0.10E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def dilogarithm_values_test ( ):

#*****************************************************************************80
#
## dilogarithm_values_test() tests dilogarithm_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'dilogarithm_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  dilogarithm_values stores values of the dilogarithm function.' )
  print ( '' )
  print ( '      X         F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = dilogarithm_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'dilogarithm_values_test:' )
  print ( '  Normal end of execution.' )
  return

def e1_values ( n_data ):

#*****************************************************************************80
#
## e1_values returns some values of the exponential integral function E1(X).
#
#  Discussion:
#
#    The exponential integral E1(X) is defined by the formula:
#
#      E1(X) = integral ( 1 <= T <= Infinity ) exp ( -X*T ) / T dT
#
#    In Mathematica, the function can be evaluated by:
#
#      ExpIntegralE[1,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 16

  fx_vec = np.array ( (
     0.5597735947761608E+00, \
     0.4543795031894021E+00, \
     0.3737688432335091E+00, \
     0.3105965785455430E+00, \
     0.2601839393259996E+00, \
     0.2193839343955203E+00, \
     0.1859909045360402E+00, \
     0.1584084368514626E+00, \
     0.1354509578491291E+00, \
     0.1162193125713579E+00, \
     0.1000195824066327E+00, \
     0.8630833369753979E-01, \
     0.7465464440125305E-01, \
     0.6471312936386886E-01, \
     0.5620437817453485E-01, \
     0.4890051070806112E-01 ))

  x_vec = np.array ( (
     0.5E+00, \
     0.6E+00, \
     0.7E+00, \
     0.8E+00, \
     0.9E+00, \
     1.0E+00, \
     1.1E+00, \
     1.2E+00, \
     1.3E+00, \
     1.4E+00, \
     1.5E+00, \
     1.6E+00, \
     1.7E+00, \
     1.8E+00, \
     1.9E+00, \
     2.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def e1_values_test ( ):

#*****************************************************************************80
#
## e1_values_test() tests e1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'e1_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  e1_values stores values of the exponential integral.' )
  print ( '' )
  print ( '      X         E1(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = e1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'e1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def easter_gregorian_values ( n_data ):

#*****************************************************************************80
#
## easter_gregorian_values: Easter dates in Gregorian calendar.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 January 2017
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer D, M, Y, an Easter date.
#
  import numpy as np

  n_max = 10

  d_vec = np.array ( [ 30,   12,    4,   23,   15,   31,   20,   11,   27,   16 ] )
  m_vec = np.array ( [ 3,    4,    4,    4,    4,    3,    4,    4,    3,    4 ] )
  y_vec = np.array ( [ 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    d = 0
    m = 0
    y = 0
  else:
    d = d_vec[n_data]
    m = m_vec[n_data]
    y = y_vec[n_data]
    n_data = n_data + 1

  return n_data, d, m, y

def easter_gregorian_values_test ( ):

#*****************************************************************************80
#
## easter_gregorian_values_test() tests easter_gregorian_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 January 2018
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'easter_gregorian_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  easter_gregorian_values stores values of' )
  print ( '  the date of Easter in the Gregorian calendar.' )
  print ( '' )
  print ( '   D   M     Y' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, d, m, y = easter_gregorian_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %2d  %2d  %4d' % ( d, m, y ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'easter_gregorian_values_test:' )
  print ( '  Normal end of execution.' )
  return

def easter_julian_values ( n_data ):

#*****************************************************************************80
#
## easter_julian_values: Easter dates in Julian calendar.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 January 2017
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer D, M, Y, an Easter date.
#
  import numpy as np

  n_max = 10

  d_vec = np.array ( [ 30,   12,    4,   23,   15,   31,   20,   11,   27,   16 ] )
  m_vec = np.array ( [ 3,    4,    4,    4,    4,    3,    4,    4,    3,    4 ] )
  y_vec = np.array ( [ 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    d = 0
    m = 0
    y = 0
  else:
    d = d_vec[n_data]
    m = m_vec[n_data]
    y = y_vec[n_data]
    n_data = n_data + 1

  return n_data, d, m, y

def easter_julian_values_test ( ):

#*****************************************************************************80
#
## easter_julian_values_test() tests easter_julian_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 January 2018
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'easter_julian_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  easter_julian_values stores values of' )
  print ( '  the date of Easter in the Julian calendar.' )
  print ( '' )
  print ( '   D   M     Y' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, d, m, y = easter_julian_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %2d  %2d  %4d' % ( d, m, y ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'easter_julian_values_test:' )
  print ( '  Normal end of execution.' )
  return

def ei_values ( n_data ):

#*****************************************************************************80
#
## ei_values returns some values of the exponential integral function EI(X).
#
#  Definition:
#
#    The exponential integral EI(X) has the formula:
#
#      EI(X) = - integral ( -X <= T <= Infinity ) exp ( -T ) / T dT
#
#    In Mathematica, the function can be evaluated by:
#
#      ExpIntegralEi[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 September 2004
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 16

  fx_vec = np.array ( (
     0.4542199048631736E+00, \
     0.7698812899373594E+00, \
     0.1064907194624291E+01, \
     0.1347396548212326E+01, \
     0.1622811713696867E+01, \
     0.1895117816355937E+01, \
     0.2167378279563403E+01, \
     0.2442092285192652E+01, \
     0.2721398880232024E+01, \
     0.3007207464150646E+01, \
     0.3301285449129798E+01, \
     0.3605319949019469E+01, \
     0.3920963201354904E+01, \
     0.4249867557487934E+01, \
     0.4593713686953585E+01, \
     0.4954234356001890E+01 ))

  x_vec = np.array ( (
     0.5E+00, \
     0.6E+00, \
     0.7E+00, \
     0.8E+00, \
     0.9E+00, \
     1.0E+00, \
     1.1E+00, \
     1.2E+00, \
     1.3E+00, \
     1.4E+00, \
     1.5E+00, \
     1.6E+00, \
     1.7E+00, \
     1.8E+00, \
     1.9E+00, \
     2.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def ei_values_test ( ):

#*****************************************************************************80
#
## ei_values_test() tests ei_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'ei_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  ei_values stores values of the exponential integral.' )
  print ( '' )
  print ( '      X         EI(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = ei_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'ei_values_test:' )
  print ( '  Normal end of execution.' )
  return

def elliptic_ea_values ( n_data ):

#*****************************************************************************80
#
## elliptic_ea_values returns values of the complete elliptic integral E(A).
#
#  Discussion:
#
#    This is one form of what is sometimes called the complete elliptic 
#    integral of the second kind.
#
#    The function is defined by the formula:
#
#      E(A) = integral ( 0 <= T <= PI/2 ) 
#        sqrt ( 1 - sin ( A )^2 * sin ( T )^2 ) dT
#
#    In Mathematica, the function can be evaluated by:
#
#      EllipticE[(Sin[Pi*a/180])^2]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function, measured
#    in degrees.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 19

  fx_vec = np.array ( ( \
     1.570796326794897E+00, \
     1.567809073977622E+00, \
     1.558887196601596E+00, \
     1.544150496914673E+00, \
     1.523799205259774E+00, \
     1.498114928422116E+00, \
     1.467462209339427E+00, \
     1.432290969306756E+00, \
     1.393140248523812E+00, \
     1.350643881047676E+00, \
     1.305539094297794E+00, \
     1.258679624779997E+00, \
     1.211056027568459E+00, \
     1.163827964493139E+00, \
     1.118377737969864E+00, \
     1.076405113076403E+00, \
     1.040114395706010E+00, \
     1.012663506234396E+00, \
     1.000000000000000E+00 ))

  x_vec = np.array ( ( \
      0.0E+00, \
      5.0E+00, \
     10.0E+00, \
     15.0E+00, \
     20.0E+00, \
     25.0E+00, \
     30.0E+00, \
     35.0E+00, \
     40.0E+00, \
     45.0E+00, \
     50.0E+00, \
     55.0E+00, \
     60.0E+00, \
     65.0E+00, \
     70.0E+00, \
     75.0E+00, \
     80.0E+00, \
     85.0E+00, \
     90.0E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def elliptic_ea_values_test ( ):

#*****************************************************************************80
#
## elliptic_ea_values_test() tests elliptic_ea_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'elliptic_ea_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  elliptic_ea_values stores values of the complete elliptic' )
  print ( '  integral of the second kind, with parameter A in degrees.' )
  print ( '' )
  print ( '      A             E(A)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = elliptic_ea_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'elliptic_ea_values_test:' )
  print ( '  Normal end of execution.' )
  return

def elliptic_ek_values ( n_data ):

#*****************************************************************************80
#
## elliptic_ek_values returns values of the complete elliptic integral E(K).
#
#  Discussion:
#
#    This is one form of what is sometimes called the complete elliptic 
#    integral of the second kind.
#
#    The function is defined by the formula:
#
#      E(K) = integral ( 0 <= T <= PI/2 ) 
#        sqrt ( 1 - K^2 * sin ( T )^2 ) dT
#
#    In Mathematica, the function can be evaluated by:
#
#      EllipticE[k^2]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    29 May 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  fx_vec = np.array ( ( \
     1.570796326794897E+00, \
     1.550973351780472E+00, \
     1.530757636897763E+00, \
     1.510121832092819E+00, \
     1.489035058095853E+00, \
     1.467462209339427E+00, \
     1.445363064412665E+00, \
     1.422691133490879E+00, \
     1.399392138897432E+00, \
     1.375401971871116E+00, \
     1.350643881047676E+00, \
     1.325024497958230E+00, \
     1.298428035046913E+00, \
     1.270707479650149E+00, \
     1.241670567945823E+00, \
     1.211056027568459E+00, \
     1.178489924327839E+00, \
     1.143395791883166E+00, \
     1.104774732704073E+00, \
     1.060473727766278E+00, \
     1.000000000000000E+00 ))

  x_vec = np.array (( \
     0.0000000000000000, \
     0.2236067977499790, \
     0.3162277660168379, \
     0.3872983346207417, \
     0.4472135954999579, \
     0.5000000000000000, \
     0.5477225575051661, \
     0.5916079783099616, \
     0.6324555320336759, \
     0.6708203932499369, \
     0.7071067811865476, \
     0.7416198487095663, \
     0.7745966692414834, \
     0.8062257748298550, \
     0.8366600265340756, \
     0.8660254037844386, \
     0.8944271909999159, \
     0.9219544457292888, \
     0.9486832980505138, \
     0.9746794344808963, \
     1.0000000000000000 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def elliptic_ek_values_test ( ):

#*****************************************************************************80
#
## elliptic_ek_values_test() tests elliptic_ek_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    29 May 2018
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'elliptic_ek_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  elliptic_ek_values stores values of the complete elliptic' )
  print ( '  integral of the second kind, with parameter K.' )
  print ( '' )
  print ( '      K         E(K)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = elliptic_ek_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'elliptic_ek_values_test:' )
  print ( '  Normal end of execution.' )
  return

def elliptic_em_values ( n_data ):

#*****************************************************************************80
#
## elliptic_em_values returns values of the complete elliptic integral E(M).
#
#  Discussion:
#
#    This is one form of what is sometimes called the complete elliptic 
#    integral of the second kind.
#
#    The function is defined by the formula:
#
#      E(M) = integral ( 0 <= T <= PI/2 ) 
#        sqrt ( 1 - M * sin ( T )^2 ) dT
#
#    In Mathematica, the function can be evaluated by:
#
#      EllipticE[m]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 September 2004
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  fx_vec = np.array ( ( \
     1.570796326794897E+00, \
     1.550973351780472E+00, \
     1.530757636897763E+00, \
     1.510121832092819E+00, \
     1.489035058095853E+00, \
     1.467462209339427E+00, \
     1.445363064412665E+00, \
     1.422691133490879E+00, \
     1.399392138897432E+00, \
     1.375401971871116E+00, \
     1.350643881047676E+00, \
     1.325024497958230E+00, \
     1.298428035046913E+00, \
     1.270707479650149E+00, \
     1.241670567945823E+00, \
     1.211056027568459E+00, \
     1.178489924327839E+00, \
     1.143395791883166E+00, \
     1.104774732704073E+00, \
     1.060473727766278E+00, \
     1.000000000000000E+00 ))

  x_vec = np.array (( \
     0.00E+00, \
     0.05E+00, \
     0.10E+00, \
     0.15E+00, \
     0.20E+00, \
     0.25E+00, \
     0.30E+00, \
     0.35E+00, \
     0.40E+00, \
     0.45E+00, \
     0.50E+00, \
     0.55E+00, \
     0.60E+00, \
     0.65E+00, \
     0.70E+00, \
     0.75E+00, \
     0.80E+00, \
     0.85E+00, \
     0.90E+00, \
     0.95E+00, \
     1.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def elliptic_em_values_test ( ):

#*****************************************************************************80
#
## elliptic_em_values_test() tests elliptic_em_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'elliptic_em_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  elliptic_em_values stores values of the complete elliptic' )
  print ( '  integral of the second kind, with parameter modulus M.' )
  print ( '' )
  print ( '      M         E(M)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = elliptic_em_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'elliptic_em_values_test:' )
  print ( '  Normal end of execution.' )
  return

def elliptic_fa_values ( n_data ):

#*****************************************************************************80
#
## elliptic_fa_values returns values of the complete elliptic integral F(A).
#
#  Discussion:
#
#    This is one form of what is sometimes called the complete elliptic integral
#    of the first kind.
#
#    The function is defined by the formula:
#
#      F(A) = integral ( 0 <= T <= PI/2 ) 
#        dT / sqrt ( 1 - sin ( A )^2 * sin ( T )^2 )
#
#    In Mathematica, the function can be evaluated by:
#
#      EllipticK[(Sin[a*Pi/180])^2]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    04 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function, measured 
#    in degrees.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 18

  fx_vec = np.array ( ( \
     0.1570796326794897E+01, \
     0.1573792130924768E+01, \
     0.1582842804338351E+01, \
     0.1598142002112540E+01, \
     0.1620025899124204E+01, \
     0.1648995218478530E+01, \
     0.1685750354812596E+01, \
     0.1731245175657058E+01, \
     0.1786769134885021E+01, \
     0.1854074677301372E+01, \
     0.1935581096004722E+01, \
     0.2034715312185791E+01, \
     0.2156515647499643E+01, \
     0.2308786798167196E+01, \
     0.2504550079001634E+01, \
     0.2768063145368768E+01, \
     0.3153385251887839E+01, \
     0.3831741999784146E+01 ))

  x_vec = np.array ( ( \
      0.0E+00, \
      5.0E+00, \
     10.0E+00, \
     15.0E+00, \
     20.0E+00, \
     25.0E+00, \
     30.0E+00, \
     35.0E+00, \
     40.0E+00, \
     45.0E+00, \
     50.0E+00, \
     55.0E+00, \
     60.0E+00, \
     65.0E+00, \
     70.0E+00, \
     75.0E+00, \
     80.0E+00, \
     85.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def elliptic_fa_values_test ( ):

#*****************************************************************************80
#
## elliptic_fa_values_test() tests elliptic_fa_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    04 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'elliptic_fa_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  elliptic_fa_values stores values of the complete elliptic' )
  print ( '  integral of the first kind, with parameter A in degrees.' )
  print ( '' )
  print ( '      A             F(A)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = elliptic_fa_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'elliptic_fa_values_test:' )
  print ( '  Normal end of execution.' )
  return

def elliptic_fk_values ( n_data ):

#*****************************************************************************80
#
## elliptic_fk_values returns values of the complete elliptic integral F(K).
#
#  Discussion:
#
#    This is one form of what is sometimes called the complete elliptic 
#    integral of the first kind.
#
#    The function is defined by the formula:
#
#      F(K) = integral ( 0 <= T <= PI/2 ) 
#        dT / sqrt ( 1 - K^2 * sin ( T )^2 )
#
#    In Mathematica, the function can be evaluated by:
#
#      EllipticK[k^2]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    29 May 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( (
     1.570796326794897E+00, \
     1.591003453790792E+00, \
     1.612441348720219E+00, \
     1.635256732264580E+00, \
     1.659623598610528E+00, \
     1.685750354812596E+00, \
     1.713889448178791E+00, \
     1.744350597225613E+00, \
     1.777519371491253E+00, \
     1.813883936816983E+00, \
     1.854074677301372E+00, \
     1.898924910271554E+00, \
     1.949567749806026E+00, \
     2.007598398424376E+00, \
     2.075363135292469E+00, \
     2.156515647499643E+00, \
     2.257205326820854E+00, \
     2.389016486325580E+00, \
     2.578092113348173E+00, \
     2.908337248444552E+00 ))

  x_vec = np.array ( (
     0.0000000000000000E+00, \
     0.2236067977499790E+00, \
     0.3162277660168379E+00, \
     0.3872983346207417E+00, \
     0.4472135954999579E+00, \
     0.5000000000000000E+00, \
     0.5477225575051661E+00, \
     0.5916079783099616E+00, \
     0.6324555320336759E+00, \
     0.6708203932499369E+00, \
     0.7071067811865476E+00, \
     0.7416198487095663E+00, \
     0.7745966692414834E+00, \
     0.8062257748298550E+00, \
     0.8366600265340756E+00, \
     0.8660254037844386E+00, \
     0.8944271909999159E+00, \
     0.9219544457292888E+00, \
     0.9486832980505138E+00, \
     0.9746794344808963E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def elliptic_fk_values_test ( ):

#*****************************************************************************80
#
## elliptic_fk_values_test() tests elliptic_fk_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    29 May 2018
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'elliptic_fk_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  elliptic_fk_values stores values of the complete elliptic' )
  print ( '  integral of the first kind, with parameter KM.' )
  print ( '' )
  print ( '      K         F(K)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = elliptic_fk_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'elliptic_fk_values_test:' )
  print ( '  Normal end of execution.' )
  return

def elliptic_fm_values ( n_data ):

#*****************************************************************************80
#
## elliptic_fm_values returns values of the complete elliptic integral F(M).
#
#  Discussion:
#
#    This is one form of what is sometimes called the complete elliptic 
#    integral of the first kind.
#
#    The function is defined by the formula:
#
#      F(M) = integral ( 0 <= T <= PI/2 ) 
#        dT / sqrt ( 1 - M * sin ( T )^2 )
#
#    In Mathematica, the function can be evaluated by:
#
#      EllipticK[m]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    04 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( (
     1.570796326794897E+00, \
     1.591003453790792E+00, \
     1.612441348720219E+00, \
     1.635256732264580E+00, \
     1.659623598610528E+00, \
     1.685750354812596E+00, \
     1.713889448178791E+00, \
     1.744350597225613E+00, \
     1.777519371491253E+00, \
     1.813883936816983E+00, \
     1.854074677301372E+00, \
     1.898924910271554E+00, \
     1.949567749806026E+00, \
     2.007598398424376E+00, \
     2.075363135292469E+00, \
     2.156515647499643E+00, \
     2.257205326820854E+00, \
     2.389016486325580E+00, \
     2.578092113348173E+00, \
     2.908337248444552E+00 ))

  x_vec = np.array ( (
      0.00E+00, \
      0.05E+00, \
      0.10E+00, \
      0.15E+00, \
      0.20E+00, \
      0.25E+00, \
      0.30E+00, \
      0.35E+00, \
      0.40E+00, \
      0.45E+00, \
      0.50E+00, \
      0.55E+00, \
      0.60E+00, \
      0.65E+00, \
      0.70E+00, \
      0.75E+00, \
      0.80E+00, \
      0.85E+00, \
      0.90E+00, \
      0.95E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def elliptic_fm_values_test ( ):

#*****************************************************************************80
#
## elliptic_fm_values_test() tests elliptic_fm_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    04 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'elliptic_fm_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  elliptic_fm_values stores values of the complete elliptic' )
  print ( '  integral of the first kind, with parameter modulus M.' )
  print ( '' )
  print ( '      M         F(M)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = elliptic_fm_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'elliptic_fm_values_test:' )
  print ( '  Normal end of execution.' )
  return

def elliptic_inc_ea_values ( n_data ):

#*****************************************************************************80
#
## elliptic_inc_ea_values: values of the incomplete elliptic integral E(PHI,A).
#
#  Discussion:
#
#    This is one form of the incomplete elliptic integral of the second kind.
#
#      E(PHI,A) = integral ( 0 <= T <= PHI ) 
#        sqrt ( 1 - sin^2 ( A ) * sin^2 ( T ) ) dT
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real PHI, A, the arguments of the function.
#
#    real EA, the value of the function.
#
  import numpy as np

  n_max = 20

  a_vec = np.array ( [ \
         123.0821233267548, \
         11.26931745051486, \
        -94.88806452075445, \
        -99.71407853545323, \
         57.05881039324191, \
        -19.71363287074183, \
         56.31230299738043, \
        -91.55605346417718, \
        -27.00654574696468, \
        -169.2293728595904, \
         61.96859564803047, \
        -158.7324398933148, \
         105.0883958999383, \
        -48.95883872360177, \
        -42.58568835110901, \
         11.65603284687828, \
        -8.398113719173338, \
         17.69362213019626, \
          73.8803420626852, \
        -69.82492339645128 ] )

  ea_vec = np.array ( [ \
        0.3384181367348019, \
         1.292924624509506, \
        0.6074183768796306, \
        0.3939726730783567, \
       0.06880814097089803, \
        0.0969436473376824, \
        0.6025937791452033, \
        0.9500549494837583, \
         1.342783372140486, \
        0.1484915631401388, \
         1.085432887050926, \
        0.1932136916085597, \
        0.3983689593057807, \
        0.1780054133336934, \
         1.164525270273536, \
         1.080167047541845, \
         1.346684963830312, \
         1.402100272685504, \
        0.2928091845544553, \
        0.5889342583405707 ] )

  phi_vec = np.array ( [ \
        0.3430906586047127, \
         1.302990057703935, \
        0.6523628380743488, \
        0.4046022501376546, \
       0.06884642871852312, \
        0.0969609046794745, \
         0.630370432896175, \
         1.252375418911598, \
         1.409796082144801, \
        0.1485105463502483, \
         1.349466184634646, \
        0.1933711786970301, \
        0.4088829927466769, \
        0.1785430666405224, \
         1.292588374416351, \
         1.087095515757691, \
         1.352794600489329, \
         1.432530166308616, \
        0.2968093345769761, \
        0.6235880396594726 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    ea = 0.0
    phi = 0.0
  else:
    a = a_vec[n_data]
    ea = ea_vec[n_data]
    phi = phi_vec[n_data]
    n_data = n_data + 1

  return n_data, phi, a, ea

def elliptic_inc_ea_values_test ( ):

#*****************************************************************************80
#
## elliptic_inc_ea_values_test() tests elliptic_inc_ea_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'elliptic_inc_ea_values_test:' )
  print ( '  elliptic_inc_ea_values stores values of' )
  print ( '  the incomplete elliptic integral of the second' )
  print ( '  kind, with parameters PHI, A.' )
  print ( '' )
  print ( '    PHI        A            E(PHI,A)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, phi, a, ea = elliptic_inc_ea_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f' % ( phi, a, ea ) )

  return

def elliptic_inc_ek_values ( n_data ):

#*****************************************************************************80
#
## elliptic_inc_ek_values: values of the incomplete elliptic integral E(PHI,K).
#
#  Discussion:
#
#    This is the incomplete elliptic integral of the second kind.
#
#      E(PHI,K) = integral ( 0 <= T <= PHI ) 
#        sqrt ( 1 - K^2 * sin ( T )^2 ) dT
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real PHI, K, the arguments.
#
#    real EK, the function value.
#
  import numpy as np

  n_max = 20

  ek_vec = np.array ( [ \
        0.2852345328295404, \
         1.298690225567921, \
        0.5508100202571943, \
        0.3575401358115371, \
       0.06801307805507453, \
       0.09679584980231837, \
        0.6003112504412838, \
        0.8996717721794724, \
         1.380715261453875, \
        0.1191644625202453, \
         1.196994838171557, \
        0.1536260979667945, \
        0.3546768920544152, \
        0.1758756066650882, \
         1.229819109410569, \
          1.08381066114337, \
          1.35023378157378, \
         1.419775884709218, \
        0.2824895528020034, \
        0.5770427720982867 ] )

  k_vec = np.array ( [ \
         2.712952582080266, \
        0.1279518954120547, \
        -1.429437513650137, \
        -1.981659235625333, \
         3.894801879555818, \
        -1.042486024983672, \
        0.8641142168759754, \
        -1.049058412826877, \
       -0.3024062128402472, \
        -6.574288841527263, \
        0.6987397421988888, \
         -5.12558591600033, \
         2.074947853793764, \
        -1.670886158426681, \
       -0.4843595000931672, \
        0.1393061679635559, \
       -0.0946527302537008, \
        0.1977207111754007, \
         1.788159919089993, \
        -1.077780624681256 ] )

  phi_vec = np.array ( [ \
        0.3430906586047127, \
         1.302990057703935, \
        0.6523628380743488, \
        0.4046022501376546, \
       0.06884642871852312, \
        0.0969609046794745, \
         0.630370432896175, \
         1.252375418911598, \
         1.409796082144801, \
        0.1485105463502483, \
         1.349466184634646, \
        0.1933711786970301, \
        0.4088829927466769, \
        0.1785430666405224, \
         1.292588374416351, \
         1.087095515757691, \
         1.352794600489329, \
         1.432530166308616, \
        0.2968093345769761, \
        0.6235880396594726 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    ek = 0.0
    k = 0.0
    phi = 0.0
  else:
    ek = ek_vec[n_data]
    k = k_vec[n_data]
    phi = phi_vec[n_data]
    n_data = n_data + 1

  return n_data, phi, k, ek

def elliptic_inc_ek_values_test ( ):

#*****************************************************************************80
#
## elliptic_inc_ek_values_test() tests elliptic_inc_ek_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'elliptic_inc_ek_values_test:' )
  print ( '  elliptic_inc_ek_values stores values of' )
  print ( '  the incomplete elliptic integral of the second' )
  print ( '  kind, with parameters PHI, K.\n' )
  print ( '' )
  print ( '    PHI        K            E(PHI,K)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, phi, k, ek = elliptic_inc_ek_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f' % ( phi, k, ek ) )


  return

def elliptic_inc_em_values ( n_data ):

#*****************************************************************************80
#
## elliptic_inc_em_values: values of the incomplete elliptic integral E(PHI,M).
#
#  Discussion:
#
#    This is the incomplete elliptic integral of the second kind.
#
#      E(PHI,M) = integral ( 0 <= T <= PHI ) 
#        sqrt ( 1 - M * sin ( T )^2 ) dT
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real PHI, M, the arguments.
#
#    real EM, the function value.
#
  import numpy as np

  n_max = 20

  em_vec = np.array ( [ \
        0.2732317284159052, \
         1.124749725099781, \
        0.6446601913679151, \
        0.3968902354370061, \
       0.06063960799944668, \
       0.08909411577948728, \
         0.532402014802015, \
         1.251888640660265, \
          1.28897116191626, \
        0.1481718153599732, \
         1.038090185639913, \
        0.1931275771541276, \
        0.3304419611986801, \
         0.167394796063963, \
         1.214501175324736, \
        0.9516560179840655, \
         1.203682959526176, \
         1.206426326185419, \
        0.2522791382096692, \
        0.6026499038720986 ] )

  m_vec = np.array ( [ \
         8.450689756874594, \
        0.6039878267930615, \
        0.1794126658351454, \
        0.7095689301026752, \
         133.9643389059188, \
         47.96621393936416, \
         2.172070586163255, \
      0.002038130569431913, \
        0.3600036705339421, \
        0.6219544540067304, \
        0.8834215943508453, \
        0.2034290670379481, \
         5.772526076430922, \
         11.14853902343298, \
        0.2889238477277305, \
        0.7166617182589116, \
        0.4760623731559658, \
        0.6094948502068943, \
         8.902276887883076, \
        0.5434439226321253 ] )

  phi_vec = np.array ( [ \
      0.3430906586047127, \
       1.302990057703935, \
      0.6523628380743488, \
      0.4046022501376546, \
     0.06884642871852312, \
      0.0969609046794745, \
       0.630370432896175, \
       1.252375418911598, \
       1.409796082144801, \
      0.1485105463502483, \
       1.349466184634646, \
      0.1933711786970301, \
      0.4088829927466769, \
      0.1785430666405224, \
       1.292588374416351, \
       1.087095515757691, \
       1.352794600489329, \
       1.432530166308616, \
      0.2968093345769761, \
      0.6235880396594726 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    em = 0.0
    m = 0.0
    phi = 0.0
  else:
    em = em_vec[n_data]
    m = m_vec[n_data]
    phi = phi_vec[n_data]
    n_data = n_data + 1

  return n_data, phi, m, em

def elliptic_inc_em_values_test ( ):

#*****************************************************************************80
#
## elliptic_inc_em_values_test() tests elliptic_inc_em_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'elliptic_inc_em_values_test:' )
  print ( '  elliptic_inc_em_values stores values of' )
  print ( '  the incomplete elliptic integral of the second' )
  print ( '  kind, with parameters PHI, M.\n' )
  print ( '' )
  print ( '    PHI        M            E(PHI,M)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, phi, m, em = elliptic_inc_em_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f' % ( phi, m, em ) )

  return

def elliptic_inc_fa_values ( n_data ):

#*****************************************************************************80
#
## elliptic_inc_fa_values: values of the incomplete elliptic integral F(PHI,A).
#
#  Discussion:
#
#    This is the incomplete elliptic integral of the first kind.
#
#      F(PHI,A) = integral ( 0 <= T <= PHI ) 
#        dT / sqrt ( 1 - sin^2 ( A ) * sin^2 ( T ) )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real PHI, A, the arguments.
#
#    real FA, the function value.
#
  import numpy as np

  n_max = 20

  a_vec = np.array ( [ \
         123.0821233267548, \
         11.26931745051486, \
        -94.88806452075445, \
        -99.71407853545323, \
         57.05881039324191, \
        -19.71363287074183, \
         56.31230299738043, \
        -91.55605346417718, \
        -27.00654574696468, \
        -169.2293728595904, \
         61.96859564803047, \
        -158.7324398933148, \
         105.0883958999383, \
        -48.95883872360177, \
        -42.58568835110901, \
         11.65603284687828, \
        -8.398113719173338, \
         17.69362213019626, \
          73.8803420626852, \
        -69.82492339645128 ] )

  fa_vec = np.array ( [ \
        0.3478806460316299, \
         1.313180577009584, \
        0.7037956689264326, \
        0.4157626844675118, \
       0.06888475483285136, \
       0.09697816754845832, \
        0.6605394722518515, \
          1.82758346036751, \
         1.482258783392487, \
        0.1485295339221232, \
         1.753800062701494, \
         0.193528896465351, \
        0.4199100508706138, \
        0.1790836490491233, \
         1.446048832279763, \
         1.094097652100984, \
         1.358947908427035, \
          1.46400078231538, \
        0.3009092014525799, \
        0.6621341112075102 ] )

  phi_vec = np.array ( [ \
        0.3430906586047127, \
         1.302990057703935, \
        0.6523628380743488, \
        0.4046022501376546, \
       0.06884642871852312, \
        0.0969609046794745, \
         0.630370432896175, \
         1.252375418911598, \
         1.409796082144801, \
        0.1485105463502483, \
         1.349466184634646, \
        0.1933711786970301, \
        0.4088829927466769, \
        0.1785430666405224, \
         1.292588374416351, \
         1.087095515757691, \
         1.352794600489329, \
         1.432530166308616, \
        0.2968093345769761, \
        0.6235880396594726 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    fa = 0.0
    phi = 0.0
  else:
    a = a_vec[n_data]
    fa = fa_vec[n_data]
    phi = phi_vec[n_data]
    n_data = n_data + 1

  return n_data, phi, a, fa

def elliptic_inc_fa_values_test ( ):

#*****************************************************************************80
#
## elliptic_inc_fa_values_test() tests elliptic_inc_fa_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 June 2018
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'elliptic_inc_fa_values_test:' )
  print ( '  elliptic_inc_fa_values stores values of' )
  print ( '  the incomplete elliptic integral of the first' )
  print ( '  kind, with parameters PHI, A.' )
  print ( '' )
  print ( '    PHI        A            F(PHI,A)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, phi, a, fa = elliptic_inc_fa_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f' % ( phi, a, fa ) )

  return

def elliptic_inc_fk_values ( n_data ):

#*****************************************************************************80
#
## elliptic_inc_fk_values: values of the incomplete elliptic integral F(PHI,K).
#
#  Discussion:
#
#    This is the incomplete elliptic integral of the first kind.
#
#      F(PHI,K) = integral ( 0 <= T <= PHI ) 
#        dT / sqrt ( 1 - K^2 * sin ( T )^2 )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real PHI, K, the arguments.
#
#    real FK, the value of the function.
#
  import numpy as np

  n_max = 20

  fk_vec = np.array ( [ \
       0.4340870330108736, \
        1.307312511398114, \
       0.8005154258533936, \
       0.4656721451084328, \
      0.06969849613441773, \
      0.09712646708750489, \
       0.6632598061016007, \
          2.2308677858579, \
        1.439846282888019, \
       0.2043389243773096, \
        1.537183574881771, \
       0.2749229901565622, \
       0.4828388342828284, \
       0.1812848567886627, \
        1.360729522341841, \
         1.09039680912027, \
        1.355363051581808, \
        1.445462819732441, \
       0.3125355489354676, \
       0.6775731623807174 ] )

  k_vec = np.array ( [ \
        2.712952582080266, \
       0.1279518954120547, \
       -1.429437513650137, \
       -1.981659235625333, \
        3.894801879555818, \
       -1.042486024983672, \
       0.8641142168759754, \
       -1.049058412826877, \
      -0.3024062128402472, \
       -6.574288841527263, \
       0.6987397421988888, \
        -5.12558591600033, \
        2.074947853793764, \
       -1.670886158426681, \
      -0.4843595000931672, \
       0.1393061679635559, \
      -0.0946527302537008, \
       0.1977207111754007, \
        1.788159919089993, \
       -1.077780624681256 ] )

  phi_vec = np.array ( [ \
       0.3430906586047127, \
        1.302990057703935, \
       0.6523628380743488, \
       0.4046022501376546, \
      0.06884642871852312, \
       0.0969609046794745, \
        0.630370432896175, \
        1.252375418911598, \
        1.409796082144801, \
       0.1485105463502483, \
        1.349466184634646, \
       0.1933711786970301, \
       0.4088829927466769, \
       0.1785430666405224, \
        1.292588374416351, \
        1.087095515757691, \
        1.352794600489329, \
        1.432530166308616, \
       0.2968093345769761, \
       0.6235880396594726 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    fk = 0.0
    k = 0.0
    phi = 0.0
  else:
    fk = fk_vec[n_data]
    k = k_vec[n_data]
    phi = phi_vec[n_data]
    n_data = n_data + 1

  return n_data, phi, k, fk

def elliptic_inc_fk_values_test ( ):

#*****************************************************************************80
#
## elliptic_inc_fk_values_test() tests elliptic_inc_fk_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'elliptic_inc_fk_values_test:' )
  print ( '  elliptic_inc_fk_values stores values of' )
  print ( '  the incomplete elliptic integral of the first' )
  print ( '  kind, with parameters PHI, K.' )
  print ( '' )
  print ( '    PHI        K            F(PHI,K)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, phi, k, fk = elliptic_inc_fk_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f' % ( phi, k, fk ) )

  return

def elliptic_inc_fm_values ( n_data ):

#*****************************************************************************80
#
## elliptic_inc_fm_values: values of the incomplete elliptic integral F(PHI,M).
#
#  Discussion:
#
#    This is the incomplete elliptic integral of the first kind.
#
#      F(PHI,M) = integral ( 0 <= T <= PHI ) 
#        dT / sqrt ( 1 - M * sin ( T )^2 )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real PHI, M, the arguments.
#
#    real FM, the value of the function.
#
  import numpy as np

  n_max = 20

  fm_vec = np.array ( [ \
        0.4804314075855023, \
         1.535634981092025, \
        0.6602285297476601, \
        0.4125884303785135, \
       0.07964566007155376, \
        0.1062834070535258, \
        0.7733990864393913, \
         1.252862499892228, \
         1.549988686611532, \
        0.1488506735822822, \
         1.892229900799662, \
        0.1936153327753556, \
        0.5481932935424454, \
        0.1911795073571756, \
         1.379225069349756, \
         1.261282453331402, \
         1.535239838525378, \
         1.739782418156071, \
        0.3616930047198503, \
        0.6458627645916422 ] )

  m_vec = np.array ( [ \
         8.450689756874594, \
        0.6039878267930615, \
        0.1794126658351454, \
        0.7095689301026752, \
         133.9643389059188, \
         47.96621393936416, \
         2.172070586163255, \
      0.002038130569431913, \
        0.3600036705339421, \
        0.6219544540067304, \
        0.8834215943508453, \
        0.2034290670379481, \
         5.772526076430922, \
         11.14853902343298, \
        0.2889238477277305, \
        0.7166617182589116, \
        0.4760623731559658, \
        0.6094948502068943, \
         8.902276887883076, \
        0.5434439226321253 ] )

  phi_vec = np.array ( [ \
        0.3430906586047127, \
         1.302990057703935, \
        0.6523628380743488, \
        0.4046022501376546, \
       0.06884642871852312, \
        0.0969609046794745, \
         0.630370432896175, \
         1.252375418911598, \
         1.409796082144801, \
        0.1485105463502483, \
         1.349466184634646, \
        0.1933711786970301, \
        0.4088829927466769, \
        0.1785430666405224, \
         1.292588374416351, \
         1.087095515757691, \
         1.352794600489329, \
         1.432530166308616, \
        0.2968093345769761, \
        0.6235880396594726  ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    fm = 0.0
    m = 0.0
    phi = 0.0
  else:
    fm = fm_vec[n_data]
    m = m_vec[n_data]
    phi = phi_vec[n_data]
    n_data = n_data + 1

  return n_data, phi, m, fm

def elliptic_inc_fm_values_test ( ):

#*****************************************************************************80
#
## elliptic_inc_fm_values_test() tests elliptic_inc_fm_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'elliptic_inc_fm_values_test:' )
  print ( '  elliptic_inc_fm_values stores values of' )
  print ( '  the incomplete elliptic integral of the first' )
  print ( '  kind, with parameters PHI, M.' )
  print ( '' )
  print ( '    PHI        M            F(PHI,M)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, phi, m, fm = elliptic_inc_fm_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f' % ( phi, m, fm ) )

  return

def elliptic_inc_pia_values ( n_data ):

#*****************************************************************************80
#
## elliptic_inc_pia_values: values of incomplete elliptic integral Pi(PHI,N,A).
#
#  Discussion:
#
#    This is the incomplete elliptic integral of the third kind.
#
#      Pi(PHI,N,A) = integral ( 0 <= T <= PHI ) 
#        dT / (1 - N sin^2(T) ) sqrt ( 1 - sin^2(A) * sin ( T )^2 )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real PHI, N, A, the arguments of the function.
#
#    real PIA, the value of the function.
#
  import numpy as np

  n_max = 20

  a_vec = np.array ( [ \
         88.87822485052908, \
        -86.55208740039521, \
        -116.6195703112117, \
        -9.742878017582015, \
         65.73480919446207, \
        -115.0387719677141, \
         124.9421177735846, \
        -89.78704401263703, \
        -98.42673771271734, \
        -53.74936192418378, \
         68.28047574440727, \
         20.82174673810708, \
         -29.1042364797769, \
        -37.80176710944693, \
        -55.81173355852393, \
        -37.66594589748672, \
        -80.09408170610219, \
         52.23806528467412, \
         74.30945212430545, \
        -17.22920703094039 ] )

  n_vec = np.array ( [ \
         8.064681366127422, \
       -0.2840588974558835, \
        -5.034023488967104, \
        -1.244606253942751, \
         1.465981775919188, \
         95338.12857321106, \
        -44.43130633436311, \
       -0.8029374966926196, \
         5.218883222649502, \
         2.345821782626782, \
         0.157358332363011, \
         1.926593468907062, \
         6.113982855261652, \
         1.805710621498681, \
       -0.4072847419780592, \
       -0.9416404038595624, \
        0.7009655305226739, \
        -1.019830985340273, \
       -0.4510798219577842, \
        0.6028821390092596  ] )

  phi_vec = np.array ( [ \
        0.3430906586047127, \
        0.8823091382756705, \
        0.4046022501376546, \
        0.9958310121985398, \
         0.630370432896175, \
      0.002887706662908567, \
        0.1485105463502483, \
         1.320800086884777, \
        0.4088829927466769, \
         0.552337007372852, \
         1.087095515757691, \
        0.7128175949111615, \
        0.2968093345769761, \
        0.2910907344062498, \
        0.9695030752034163, \
         1.122288759723523, \
         1.295911610809573, \
         1.116491437736542, \
         1.170719322533712, \
         1.199360682338851 ] )

  pia_vec = np.array ( [ \
        0.7099335174334724, \
        0.9601963779142505, \
        0.3362852532098376, \
        0.7785343427543768, \
         0.857889755214478, \
      0.004630772344931844, \
        0.1173842687902911, \
         1.505788070660267, \
        0.7213264194624553, \
        0.8073261799642218, \
         1.402853811110838, \
         1.259245331474513, \
        0.3779079263971614, \
        0.3088493910496766, \
        0.9782829177005183, \
        0.9430491574504173, \
         3.320796277384155, \
        0.9730988737054799, \
         1.301988094953789, \
          1.64558360445259 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    n = 0.0
    phi = 0.0
    pia = 0.0
  else:
    a = a_vec[n_data]
    n = n_vec[n_data]
    phi = phi_vec[n_data]
    pia = pia_vec[n_data]
    n_data = n_data + 1

  return n_data, phi, n, a, pia

def elliptic_inc_pia_values_test ( ):

#*****************************************************************************80
#
## elliptic_inc_pia_values_test() tests elliptic_inc_pia_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'elliptic_inc_pia_values_test:' )
  print ( '  elliptic_inc_pia_values stores values of' )
  print ( '  the incomplete elliptic integral of the third' )
  print ( '  kind, with parameters PHI, N and A.' )
  print ( '' )
  print ( '    PHI           N             A            Pi(PHI,N,A)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, phi, n, a, pia = elliptic_inc_pia_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16f' % ( phi, n, a, pia ) )

  return

def elliptic_inc_pik_values ( n_data ):

#*****************************************************************************80
#
## elliptic_inc_pik_values: values of incomplete elliptic integral Pi(PHI,N,K).
#
#  Discussion:
#
#    This is the incomplete elliptic integral of the third kind.
#
#      Pi(PHI,N,K) = integral ( 0 <= T <= PHI ) 
#        dT / (1 - N sin^2(T) ) sqrt ( 1 - K^2 * sin ( T )^2 )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real PHI, N, K, the arguments of the function.
#
#    real PIK, the value of the function.
#
  import numpy as np

  n_max = 20

  k_vec = np.array ( [ \
       1.959036804709882, \
      -1.123741823223131, \
      -2.317629084640271, \
     -0.1202582658444815, \
       1.008702896970963, \
      -103.3677494756118, \
       4.853800240677973, \
      -1.016577251056124, \
       -1.94341484065839, \
     -0.8876593284500023, \
      0.8160487832898813, \
      0.2994546721661018, \
     -0.7044232294525243, \
     -0.9266523277404759, \
     -0.6962608926846425, \
     -0.4453932031991797, \
     -0.9104582513322106, \
      0.6187501419936026, \
      0.8672305032589989, \
     -0.1996772638241632 ] )

  n_vec = np.array ( [ \
       8.064681366127422, \
     -0.2840588974558835, \
      -5.034023488967104, \
      -1.244606253942751, \
       1.465981775919188, \
       95338.12857321106, \
      -44.43130633436311, \
     -0.8029374966926196, \
       5.218883222649502, \
       2.345821782626782, \
       0.157358332363011, \
       1.926593468907062, \
       6.113982855261652, \
       1.805710621498681, \
     -0.4072847419780592, \
     -0.9416404038595624, \
      0.7009655305226739, \
      -1.019830985340273, \
     -0.4510798219577842, \
      0.6028821390092596  ] )

  phi_vec = np.array ( [ \
      0.3430906586047127, \
      0.8823091382756705, \
      0.4046022501376546, \
      0.9958310121985398, \
       0.630370432896175, \
    0.002887706662908567, \
      0.1485105463502483, \
       1.320800086884777, \
      0.4088829927466769, \
       0.552337007372852, \
       1.087095515757691, \
      0.7128175949111615, \
      0.2968093345769761, \
      0.2910907344062498, \
      0.9695030752034163, \
       1.122288759723523, \
       1.295911610809573, \
       1.116491437736542, \
       1.170719322533712, \
       1.199360682338851 ] )

  pik_vec = np.array ( [ \
      0.7982975462595892, \
       1.024022134726036, \
        0.40158120852642, \
      0.7772649487439858, \
      0.8737159913132074, \
    0.004733334297691273, \
      0.1280656893638068, \
       1.594376037512564, \
      0.8521145133671923, \
      0.8154325229803082, \
        1.31594514075427, \
        1.25394623148424, \
      0.3796503567258643, \
      0.3111034454739552, \
      0.9442477901112342, \
      0.9153111661980959, \
       2.842080644328393, \
      0.9263253777034376, \
       1.212396018757624, \
       1.628083572710471 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    k = 0.0
    n = 0.0
    phi = 0.0
    pik = 0.0
  else:
    k = k_vec[n_data]
    n = n_vec[n_data]
    phi = phi_vec[n_data]
    pik = pik_vec[n_data]
    n_data = n_data + 1

  return n_data, phi, n, k, pik

def elliptic_inc_pik_values_test ( ):

#*****************************************************************************80
#
## elliptic_inc_pik_values_test() tests elliptic_inc_pik_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'elliptic_inc_pik_values_test:' )
  print ( '  elliptic_inc_pik_values stores values of' )
  print ( '  the incomplete elliptic integral of the third' )
  print ( '  kind, with parameters PHI, N and K.' )
  print ( '' )
  print ( '    PHI           N             K            Pi(PHI,N,K)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, phi, n, k, pik = elliptic_inc_pik_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16f' % ( phi, n, k, pik ) )

  return

def elliptic_inc_pim_values ( n_data ):

#*****************************************************************************80
#
## elliptic_inc_pim_values: values of incomplete elliptic integral Pi(PHI,N,M).
#
#  Discussion:
#
#    This is the incomplete elliptic integral of the third kind.
#
#      Pi(PHI,N,M) = integral ( 0 <= T <= PHI ) 
#        dT / (1 - N sin^2(T) ) sqrt ( 1 - M * sin ( T )^2 )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    24 June 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real PHI, N, M, the arguments of the function.
#
#    real PIM, the value of the function.
#
  import numpy as np

  n_max = 20

  m_vec = np.array ( [ \
       7.330122710928245, \
      0.1108806690614566, \
      0.2828355944410993, \
      0.6382999794812498, \
       2.294718938593894, \
       42062.55329826538, \
        39.2394337789563, \
    0.008002151065098688, \
      0.7190579590867517, \
      0.9703767630929055, \
       1.098881295982823, \
       1.398066725917478, \
       4.641021931654496, \
       4.455969064311461, \
      0.3131448239736511, \
      0.3686443684703166, \
     0.06678210908100803, \
      0.9635538974026796, \
       1.060208762696207, \
      0.4687160847955397 ] )

  n_vec = np.array ( [ \
       8.064681366127422, \
     -0.2840588974558835, \
      -5.034023488967104, \
      -1.244606253942751, \
       1.465981775919188, \
       95338.12857321106, \
      -44.43130633436311, \
     -0.8029374966926196, \
       5.218883222649502, \
       2.345821782626782, \
       0.157358332363011, \
       1.926593468907062, \
       6.113982855261652, \
       1.805710621498681, \
     -0.4072847419780592, \
     -0.9416404038595624, \
      0.7009655305226739, \
      -1.019830985340273, \
     -0.4510798219577842, \
      0.6028821390092596  ] )

  phi_vec = np.array ( [ \
      0.3430906586047127, \
      0.8823091382756705, \
      0.4046022501376546, \
      0.9958310121985398, \
       0.630370432896175, \
    0.002887706662908567, \
      0.1485105463502483, \
       1.320800086884777, \
      0.4088829927466769, \
       0.552337007372852, \
       1.087095515757691, \
      0.7128175949111615, \
      0.2968093345769761, \
      0.2910907344062498, \
      0.9695030752034163, \
       1.122288759723523, \
       1.295911610809573, \
       1.116491437736542, \
       1.170719322533712, \
       1.199360682338851 ] )

  pim_vec = np.array ( [ \
         1.0469349800785, \
       0.842114448140669, \
      0.3321642201520043, \
      0.8483033529960849, \
       1.055753817656772, \
    0.005108896144265593, \
      0.1426848042785896, \
       1.031350958206424, \
      0.7131013701418496, \
      0.8268044665355507, \
        1.57632867896015, \
       1.542817120857211, \
      0.4144629799126912, \
      0.3313231611366746, \
      0.9195822851915201, \
      0.9422320754002217, \
       2.036599002815859, \
       1.076799231499882, \
       1.416084462957852, \
       1.824124922310891 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    m = 0.0
    n = 0.0
    phi = 0.0
    pim = 0.0
  else:
    m = m_vec[n_data]
    n = n_vec[n_data]
    phi = phi_vec[n_data]
    pim = pim_vec[n_data]
    n_data = n_data + 1

  return n_data, phi, n, m, pim

def elliptic_inc_pim_values_test ( ):

#*****************************************************************************80
#
## elliptic_inc_pim_values_test() tests elliptic_inc_pim_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 June 2018
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'elliptic_inc_pim_values_test:' )
  print ( '  elliptic_inc_pim_values stores values of' )
  print ( '  the incomplete elliptic integral of the third' )
  print ( '  kind, with parameters PHI, N and M.' )
  print ( '' )
  print ( '    PHI           N             M            Pi(PHI,N,M)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, phi, n, m, pim = elliptic_inc_pim_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16f' % ( phi, n, m, pim ) )

  return

def elliptic_pia_values ( n_data ):

#*****************************************************************************80
#
## elliptic_pia_values returns values of the complete elliptic integral Pi(A).
#
#  Discussion:
#
#    This is one form of what is sometimes called the complete elliptic
#    integral of the third kind.
#
#    The function is defined by the formula:
#
#      Pi(N,A) = integral ( 0 <= T <= PI/2 )
#        dT / (1 - N sin^2(T) ) sqrt ( 1 - sin^2(A) * sin ( T )^2 )
#
#    In MATLAB, the function can be evaluated by:
#
#      ellipticPi(n,(sin(A*pi/180))^2)
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    30 May 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real N, A, the arguments of the function.
#
#    real PIA, the value of the function.
#
  import numpy as np

  n_max = 20

  a_vec = np.array ( ( \
    30.00000000000000, \
    45.00000000000000, \
    60.00000000000000, \
    77.07903361841643, \
    30.00000000000000, \
    45.00000000000000, \
    60.00000000000000, \
    77.07903361841643, \
    30.00000000000000, \
    45.00000000000000, \
    60.00000000000000, \
    77.07903361841643, \
    30.00000000000000, \
    45.00000000000000, \
    60.00000000000000, \
    77.07903361841643, \
    30.00000000000000, \
    45.00000000000000, \
    60.00000000000000, \
    77.07903361841643 ))

  n_vec = np.array ( ( \
    -10.0, \
    -10.0, \
    -10.0, \
    -10.0, \
     -3.0, \
     -3.0, \
     -3.0, \
     -3.0, \
     -1.0, \
     -1.0, \
     -1.0, \
     -1.0, \
      0.0, \
      0.0, \
      0.0, \
      0.0, \
      0.5, \
      0.5, \
      0.5, \
      0.5 ) )

  pia_vec = np.array ( ( \
    0.4892245275965397, \
    0.5106765677902629, \
    0.5460409271920561, \
    0.6237325893535237, \
    0.823045542660675,  \
    0.8760028274011437, \
    0.9660073560143946, \
    1.171952391481798, \
    1.177446843000566, \
    1.273127366749682, \
    1.440034318657551, \
    1.836472172302591, \
    1.685750354812596, \
    1.854074677301372, \
    2.156515647499643, \
    2.908337248444552, \
    2.413671504201195, \
    2.701287762095351, \
    3.234773471249465, \
    4.633308147279891 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    n = 0.0
    pia = 0.0
  else:
    a = a_vec[n_data]
    n = n_vec[n_data]
    pia = pia_vec[n_data]
    n_data = n_data + 1

  return n_data, n, a, pia

def elliptic_pia_values_test ( ):

#*****************************************************************************80
#
## elliptic_pia_values_test() tests elliptic_pia_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    30 May 2018
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'elliptic_pia_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  elliptic_pia_values stores values of the complete elliptic' )
  print ( '  integral of the third kind, with parameter A in degrees.' )
  print ( '' )
  print ( '      N             A             Pi(N,A)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, a, pia = elliptic_pia_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f' % ( n, a, pia ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'elliptic_pia_values_test:' )
  print ( '  Normal end of execution.' )
  return

def elliptic_pik_values ( n_data ):

#*****************************************************************************80
#
## elliptic_pik_values returns values of the complete elliptic integral Pi(K).
#
#  Discussion:
#
#    This is one form of what is sometimes called the complete elliptic
#    integral of the third kind.
#
#    The function is defined by the formula:
#
#      Pi(N,K) = integral ( 0 <= T <= PI/2 )
#        dT / (1 - N sin^2(T) ) sqrt ( 1 - K^2 * sin ( T )^2 )
#
#    In MATLAB, the function can be evaluated by:
#
#      ellipticPi(n,k^2)
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    30 May 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real N, K, the arguments of the function.
#
#    real PIK, the value of the function.
#
  import numpy as np

  n_max = 20

  k_vec = np.array ( ( \
    0.5000000000000000, \
    0.7071067811865476, \
    0.8660254037844386, \
    0.9746794344808963, \
    0.5000000000000000, \
    0.7071067811865476, \
    0.8660254037844386, \
    0.9746794344808963, \
    0.5000000000000000, \
    0.7071067811865476, \
    0.8660254037844386, \
    0.9746794344808963, \
    0.5000000000000000, \
    0.7071067811865476, \
    0.8660254037844386, \
    0.9746794344808963, \
    0.5000000000000000, \
    0.7071067811865476, \
    0.8660254037844386, \
    0.9746794344808963  ))

  n_vec = np.array ( ( \
    -10.0, \
    -10.0, \
    -10.0, \
    -10.0, \
     -3.0, \
     -3.0, \
     -3.0, \
     -3.0, \
     -1.0, \
     -1.0, \
     -1.0, \
     -1.0, \
      0.0, \
      0.0, \
      0.0, \
      0.0, \
      0.5, \
      0.5, \
      0.5, \
      0.5 ) )

  pik_vec = np.array ( ( \
    0.4892245275965397, \
    0.5106765677902629, \
    0.5460409271920561, \
    0.6237325893535237, \
    0.823045542660675,  \
    0.8760028274011437, \
    0.9660073560143946, \
    1.171952391481798, \
    1.177446843000566, \
    1.273127366749682, \
    1.440034318657551, \
    1.836472172302591, \
    1.685750354812596, \
    1.854074677301372, \
    2.156515647499643, \
    2.908337248444552, \
    2.413671504201195, \
    2.701287762095351, \
    3.234773471249465, \
    4.633308147279891 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    k = 0.0
    n = 0.0
    pik = 0.0
  else:
    k = k_vec[n_data]
    n = n_vec[n_data]
    pik = pik_vec[n_data]
    n_data = n_data + 1

  return n_data, n, k, pik

def elliptic_pik_values_test ( ):

#*****************************************************************************80
#
## elliptic_pik_values_test() tests elliptic_pik_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    30 May 2018
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'elliptic_pik_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  elliptic_pik_values stores values of the complete elliptic' )
  print ( '  integral of the third kind, with parameter K.' )
  print ( '' )
  print ( '      N             K             Pi(N,K)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, k, pik = elliptic_pik_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f' % ( n, k, pik ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'elliptic_pik_values_test:' )
  print ( '  Normal end of execution.' )
  return

def elliptic_pim_values ( n_data ):

#*****************************************************************************80
#
## elliptic_pim_values returns values of the complete elliptic integral Pi(M).
#
#  Discussion:
#
#    This is one form of what is sometimes called the complete elliptic
#    integral of the third kind.
#
#    The function is defined by the formula:
#
#      Pi(N,M) = integral ( 0 <= T <= PI/2 )
#        dT / (1 - N sin^2(T) ) sqrt ( 1 - M * sin ( T )^2 )
#
#    In MATLAB, the function can be evaluated by:
#
#      ellipticPi(n,m)
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    30 May 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real N, M, the arguments of the function.
#
#    real PIM, the value of the function.
#
  import numpy as np

  n_max = 20

  m_vec = np.array ( ( \
    0.25, \
    0.50, \
    0.75, \
    0.95, \
    0.25, \
    0.50, \
    0.75, \
    0.95, \
    0.25, \
    0.50, \
    0.75, \
    0.95, \
    0.25, \
    0.50, \
    0.75, \
    0.95, \
    0.25, \
    0.50, \
    0.75, \
    0.95 ))

  n_vec = np.array ( ( \
    -10.0, \
    -10.0, \
    -10.0, \
    -10.0, \
     -3.0, \
     -3.0, \
     -3.0, \
     -3.0, \
     -1.0, \
     -1.0, \
     -1.0, \
     -1.0, \
      0.0, \
      0.0, \
      0.0, \
      0.0, \
      0.5, \
      0.5, \
      0.5, \
      0.5 ) )

  pim_vec = np.array ( ( \
    0.4892245275965397, \
    0.5106765677902629, \
    0.5460409271920561, \
    0.6237325893535237, \
    0.823045542660675,  \
    0.8760028274011437, \
    0.9660073560143946, \
    1.171952391481798, \
    1.177446843000566, \
    1.273127366749682, \
    1.440034318657551, \
    1.836472172302591, \
    1.685750354812596, \
    1.854074677301372, \
    2.156515647499643, \
    2.908337248444552, \
    2.413671504201195, \
    2.701287762095351, \
    3.234773471249465, \
    4.633308147279891 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    m = 0.0
    n = 0.0
    pim = 0.0
  else:
    m = m_vec[n_data]
    n = n_vec[n_data]
    pim = pim_vec[n_data]
    n_data = n_data + 1

  return n_data, n, m, pim

def elliptic_pim_values_test ( ):

#*****************************************************************************80
#
## elliptic_pim_values_test() tests elliptic_pim_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    30 May 2018
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'elliptic_pim_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  elliptic_pim_values stores values of the complete elliptic' )
  print ( '  integral of the third kind, with parameter M.' )
  print ( '' )
  print ( '      N             M             Pi(N,M)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, m, pim = elliptic_pim_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f' % ( n, m, pim ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'elliptic_pim_values_test:' )
  print ( '  Normal end of execution.' )
  return

def erfc_values ( n_data ):

#*****************************************************************************80
#
## erfc_values returns some values of the ERFC or "complementary error" function.
#
#  Discussion:
#
#    The complementary error function is defined by:
#
#      ERFC(X) = 1 - ( 2 / sqrt ( PI ) * integral ( 0 <= T <= X ) exp ( - T^2 ) dT
#
#    In Mathematica, the function can be evaluated by:
#
#      Erfc[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  fx_vec = np.array ( ( \
    1.000000000000000E+00, \
    0.7772974107895215E+00, \
    0.5716076449533315E+00, \
    0.3961439091520741E+00, \
    0.2578990352923395E+00, \
    0.1572992070502851E+00, \
    0.08968602177036462E+00, \
    0.04771488023735119E+00, \
    0.02365161665535599E+00, \
    0.01090949836426929E+00, \
    0.004677734981047266E+00, \
    0.001862846297981891E+00, \
    0.0006885138966450786E+00, \
    0.0002360344165293492E+00, \
    0.00007501319466545902E+00, \
    0.00002209049699858544E+00, \
    6.025761151762095E-06, \
    1.521993362862285E-06, \
    3.558629930076853E-07, \
    7.700392745696413E-08, \
    1.541725790028002E-08 ) )

  x_vec = np.array ( ( \
    0.0E+00, \
    0.2E+00, \
    0.4E+00, \
    0.6E+00, \
    0.8E+00, \
    1.0E+00, \
    1.2E+00, \
    1.4E+00, \
    1.6E+00, \
    1.8E+00, \
    2.0E+00, \
    2.2E+00, \
    2.4E+00, \
    2.6E+00, \
    2.8E+00, \
    3.0E+00, \
    3.2E+00, \
    3.4E+00, \
    3.6E+00, \
    3.8E+00, \
    4.0E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def erfc_values_test ( ):

#*****************************************************************************80
#
## erfc_values_test() tests erfc_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'erfc_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  erfc_values stores values of the complementary error function.' )
  print ( '' )
  print ( '      X         ERFC(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = erfc_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'erfc_values_test:' )
  print ( '  Normal end of execution.' )
  return

def erf_values ( n_data ):

#*****************************************************************************80
#
## erf_values returns some values of the ERF or "error" function.
#
#  Discussion:
#
#    The error function is defined by:
#
#      ERF(X) = ( 2 / sqrt ( PI ) * integral ( 0 <= T <= X ) exp ( - T^2 ) dT
#
#    In Mathematica, the function can be evaluated by:
#
#      Erf[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 September 2004
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  fx_vec = np.array ( ( \
     0.0000000000000000E+00, \
     0.1124629160182849E+00, \
     0.2227025892104785E+00, \
     0.3286267594591274E+00, \
     0.4283923550466685E+00, \
     0.5204998778130465E+00, \
     0.6038560908479259E+00, \
     0.6778011938374185E+00, \
     0.7421009647076605E+00, \
     0.7969082124228321E+00, \
     0.8427007929497149E+00, \
     0.8802050695740817E+00, \
     0.9103139782296354E+00, \
     0.9340079449406524E+00, \
     0.9522851197626488E+00, \
     0.9661051464753107E+00, \
     0.9763483833446440E+00, \
     0.9837904585907746E+00, \
     0.9890905016357307E+00, \
     0.9927904292352575E+00, \
     0.9953222650189527E+00 ) )

  x_vec = np.array ( ( \
     0.0E+00, \
     0.1E+00, \
     0.2E+00, \
     0.3E+00, \
     0.4E+00, \
     0.5E+00, \
     0.6E+00, \
     0.7E+00, \
     0.8E+00, \
     0.9E+00, \
     1.0E+00, \
     1.1E+00, \
     1.2E+00, \
     1.3E+00, \
     1.4E+00, \
     1.5E+00, \
     1.6E+00, \
     1.7E+00, \
     1.8E+00, \
     1.9E+00, \
     2.0E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def erf_values_test ( ):

#*****************************************************************************80
#
## erf_values_test() tests erf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'erf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  erf_values stores values of the error function.' )
  print ( '' )
  print ( '      X         ERF(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = erf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'erf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def euler_number_values ( n_data ):

#*****************************************************************************80
#
## euler_number_values returns some values of the Euler numbers.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      EulerE[n]
#
#    These numbers rapidly get too big to store in an ordinary integer!
#
#    The terms of odd index are 0.
#
#    E(N) = -C(N,N-2) * E(N-2) - C(N,N-4) * E(N-4) - ... - C(N,0) * E(0).
#
#  First terms:
#
#    E0  = 1
#    E1  = 0
#    E2  = -1
#    E3  = 0
#    E4  = 5
#    E5  = 0
#    E6  = -61
#    E7  = 0
#    E8  = 1385
#    E9  = 0
#    E10 = -50521
#    E11 = 0
#    E12 = 2702765
#    E13 = 0
#    E14 = -199360981
#    E15 = 0
#    E16 = 19391512145
#    E17 = 0
#    E18 = -2404879675441
#    E19 = 0
#    E20 = 370371188237525
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    04 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the Euler number.
#
#    integer C, the value of the Euler number.
#
  import numpy as np

  n_max = 8

  c_vec = np.array ( (
    1, 0, -1, 5, -61, 1385, -50521, 2702765 ))

  n_vec = np.array ( (
     0, 1, 2, 4, 6, 8, 10, 12 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    c = 0
  else:
    n = n_vec[n_data]
    c = c_vec[n_data]
    n_data = n_data + 1

  return n_data, n, c

def euler_number_values_test ( ):

#*****************************************************************************80
#
## euler_number_values_test() tests euler_number_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    04 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'euler_number_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  euler_number_values returns values of ' )
  print ( '  the Euler numbers.' )
  print ( '' )
  print ( '     N         euler_number(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, c = euler_number_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4d  %10d' % ( n, c ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'euler_number_values_test:' )
  print ( '  Normal end of execution.' )
  return

def euler_poly_values ( n_data ):

#*****************************************************************************80
#
## euler_poly_values returns some values of the Euler polynomials.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      EulerE[n,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    04 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the Euler polynomial.
#
#    real X, the argument of the Euler polynomial.
#
#    real FX, the value of the Euler polynomial.
#
  import numpy as np

  n_max = 27

  fx_vec = np.array ( (
      0.100000000000E+01, \
     -0.300000000000E+00, \
     -0.160000000000E+00, \
      0.198000000000E+00, \
      0.185600000000E+00, \
     -0.403680000000E+00, \
     -0.560896000000E+00, \
      0.171878880000E+01, \
      0.318043136000E+01, \
     -0.125394670080E+02, \
     -0.289999384576E+02, \
     -0.625000000000E-01, \
     -0.174240000000E+00, \
     -0.297680000000E+00, \
     -0.404320000000E+00, \
     -0.475260000000E+00, \
     -0.500000000000E+00, \
     -0.475240000000E+00, \
     -0.403680000000E+00, \
     -0.292820000000E+00, \
     -0.153760000000E+00, \
      0.000000000000E+00, \
      0.153760000000E+00, \
      0.292820000000E+00, \
      0.403680000000E+00, \
      0.475240000000E+00, \
      0.500000000000E+00 ))

  n_vec = np.array ( (
     0, \
     1, \
     2, \
     3, \
     4, \
     5, \
     6, \
     7, \
     8, \
     9, \
    10, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5 ))

  x_vec = np.array ( (
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
      0.2E+00, \
     -0.5E+00, \
     -0.4E+00, \
     -0.3E+00, \
     -0.2E+00, \
     -0.1E+00, \
      0.0E+00, \
      0.1E+00, \
      0.2E+00, \
      0.3E+00, \
      0.4E+00, \
      0.5E+00, \
      0.6E+00, \
      0.7E+00, \
      0.8E+00, \
      0.9E+00, \
      1.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    fx = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, fx

def euler_poly_values_test ( ):

#*****************************************************************************80
#
## euler_poly_values_test() tests euler_poly_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    04 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'euler_poly_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  euler_poly_values stores values of the Euler polynomials.' )
  print ( '' )
  print ( '      N            X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, fx = euler_poly_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'euler_poly_values_test:' )
  print ( '  Normal end of execution.' )
  return

def exp3_int_values ( n_data ):

#*****************************************************************************80
#
## exp3_int_values returns some values of the exp3 integral function.
#
#  Discussion:
#
#    The function is defined by:
#
#      exp3_int(x) = Integral ( 0 <= t <= x ) exp ( -t^3 ) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( (
      0.19531249963620212007E-02, \
      0.78124990686775522671E-02, \
      0.31249761583499728667E-01, \
      0.12493899888803079984E+00, \
      0.48491714311363971332E+00, \
      0.80751118213967145286E+00, \
      0.86889265412623270696E+00, \
      0.88861722235357162648E+00, \
      0.89286018500218176869E+00, \
      0.89295351429387631138E+00, \
      0.89297479112737843939E+00, \
      0.89297880579798112220E+00, \
      0.89297950317496621294E+00, \
      0.89297951152951902903E+00, \
      0.89297951156918122102E+00, \
      0.89297951156924734716E+00, \
      0.89297951156924917298E+00, \
      0.89297951156924921121E+00, \
      0.89297951156924921122E+00, \
      0.89297951156924921122E+00 ))

  x_vec = np.array ( (
      0.0019531250E+00, \
      0.0078125000E+00, \
      0.0312500000E+00, \
      0.1250000000E+00, \
      0.5000000000E+00, \
      1.0000000000E+00, \
      1.2500000000E+00, \
      1.5000000000E+00, \
      1.8750000000E+00, \
      2.0000000000E+00, \
      2.1250000000E+00, \
      2.2500000000E+00, \
      2.5000000000E+00, \
      2.7500000000E+00, \
      3.0000000000E+00, \
      3.1250000000E+00, \
      3.2500000000E+00, \
      3.5000000000E+00, \
      3.7500000000E+00, \
      4.0000000000E+00 ))
     
  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def exp3_int_values_test ( ):

#*****************************************************************************80
#
## exp3_int_values_test() tests exp3_int_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'exp3_int_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  exp3_int_values stores values of the exp3 integral.' )
  print ( '' )
  print ( '      X         F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = exp3_int_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'exp3_int_values_test:' )
  print ( '  Normal end of execution.' )
  return

def exponential_01_pdf_values ( n_data ):

#*****************************************************************************80
#
## exponential_01_pdf_values returns some values of the standard exponential PDF.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    28 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 10

  f_vec = np.array ( ( \
    0.4959398481993681, \
    0.00856777959135697, \
    0.01720937842266235, \
    0.07507070056996956, \
    0.1679332083261492, \
    0.0, \
    0.399845179478639, \
    0.9005384971416223, \
    0.0, \
    0.05044803826563792 ))

  x_vec = np.array ( ( \
        0.7013006334030669, \
         4.759746670799113, \
         4.062300786629853, \
         2.589324935217918, \
         1.784188948117787, \
       -0.1363469579618277, \
        0.9166778581012469, \
        0.1047623644285883, \
       -0.2589405122149109, \
         2.986811417663269 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def exponential_01_pdf_values_test ( ):

#*****************************************************************************80
#
## exponential_01_pdf_values_test() tests exponential_01_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    28 July 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'exponential_01_pdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  exponential_01_pdf_values stores values of the unit exponential PDF.' )
  print ( '' )
  print ( '      X         exponential_01_pdf(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = exponential_01_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'exponential_01_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def exponential_cdf_values ( n_data ):

#*****************************************************************************80
#
## exponential_cdf_values returns some values of the exponential CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = exponentialDistribution [ lambda ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    07 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real LAM, the parameter of the distribution.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 9

  f_vec = np.array ( ( \
     0.3934693402873666E+00, \
     0.6321205588285577E+00, \
     0.7768698398515702E+00, \
     0.8646647167633873E+00, \
     0.8646647167633873E+00, \
     0.9816843611112658E+00, \
     0.9975212478233336E+00, \
     0.9996645373720975E+00, \
     0.9999546000702375E+00 ))

  lam_vec = np.array ( ( \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01 ))

  x_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    lam = 0.0
    x = 0.0
    f = 0.0
  else:
    lam = lam_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, lam, x, f

def exponential_cdf_values_test ( ):

#*****************************************************************************80
#
## exponential_cdf_values_test() tests exponential_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    07 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'exponential_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  exponential_cdf_values stores values of the exponential CDF.' )
  print ( '' )
  print ( '        LAM           X               F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, lam, x, f = exponential_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( lam, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'exponential_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def exponential_pdf_values ( n_data ):

#*****************************************************************************80
#
## exponential_pdf_values returns some values of the exponential PDF.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    29 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real BETA, the parameter of the distribution.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 10

  beta_vec = np.array ( ( \
         1.092091484911879, \
         4.147546169663503, \
         2.076535407379806, \
         1.287888961910225, \
        0.2191449888955355, \
        0.3086361453280091, \
         2.006531407488083, \
         3.986434770531281, \
         4.487520304498656, \
         0.472723751058401 ))

  f_vec = np.array ( ( \
     0.0001446999730194618, \
       0.06289850821824726, \
        0.3663607831924032, \
        0.3542787877169571, \
     1.472582451176006e-12, \
     1.829637907028298e-06, \
       0.01173398427218792, \
                       0.0, \
        0.1034724689882351, \
          1.95394780436833 ))

  x_vec = np.array ( ( \
         9.558807522740191, \
         5.573123971945631, \
        0.5677992226519164, \
         1.010563614677953, \
         6.303053694254367, \
         4.440343499102481, \
         7.522202212856243, \
      -0.08143245130010748, \
         3.442598613603521, \
       0.03753060499296568 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    beta = 0.0
    x = 0.0
    f = 0.0
  else:
    beta = beta_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, beta, x, f

def exponential_pdf_values_test ( ):

#*****************************************************************************80
#
## exponential_pdf_values_test() tests exponential_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    29 July 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'exponential_pdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  exponential_pdf_values stores values of the exponential PDF.' )
  print ( '' )
  print ( '        BETA          X               F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, beta, x, f = exponential_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %24.16g' % ( beta, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'exponential_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def exp_values ( n_data ):

#*****************************************************************************80
#
## exp_values returns some values of the exponential function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Exp[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 24

  fx_vec = np.array ( (
    0.000045399929762484851536E+00, \
    0.0067379469990854670966E+00, \
    0.36787944117144232160E+00, \
    1.0000000000000000000E+00, \
    1.0000000100000000500E+00, \
    1.0001000050001666708E+00, \
    1.0010005001667083417E+00, \
    1.0100501670841680575E+00, \
    1.1051709180756476248E+00, \
    1.2214027581601698339E+00, \
    1.3498588075760031040E+00, \
    1.4918246976412703178E+00, \
    1.6487212707001281468E+00, \
    1.8221188003905089749E+00, \
    2.0137527074704765216E+00, \
    2.2255409284924676046E+00, \
    2.4596031111569496638E+00, \
    2.7182818284590452354E+00, \
    7.3890560989306502272E+00, \
    23.140692632779269006E+00, \
     148.41315910257660342E+00, \
    22026.465794806716517E+00, \
    4.8516519540979027797E+08, \
    2.3538526683701998541E+17 ))

  x_vec = np.array ( (
     -10.0E+00, \
      -5.0E+00, \
      -1.0E+00, \
       0.0E+00, \
       0.00000001E+00, \
       0.0001E+00, \
       0.001E+00, \
       0.01E+00, \
       0.1E+00, \
       0.2E+00, \
       0.3E+00, \
       0.4E+00, \
       0.5E+00, \
       0.6E+00, \
       0.7E+00, \
       0.8E+00, \
       0.9E+00, \
       1.0E+00, \
       2.0E+00, \
       3.1415926535897932385E+00, \
       5.0E+00, \
      10.0E+00, \
      20.0E+00, \
      40.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def exp_values_test ( ):

#*****************************************************************************80
#
## exp_values_test() tests exp_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'exp_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  exp_values stores values of the exponential function.' )
  print ( '' )
  print ( '      X         F(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = exp_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'exp_values_test:' )
  print ( '  Normal end of execution.' )
  return

def extreme_values_cdf_values ( n_data ):

#*****************************************************************************80
#
## extreme_values_cdf_values returns some values of the Extreme Values CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = ExtremeValuesDistribution [ alpha, beta ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    06 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real ALPHA, the first parameter of the distribution.
#
#    real BETA, the second parameter of the distribution.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 12

  alpha_vec = np.array ( (
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01 ))

  beta_vec = np.array ( (
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01 ))

  f_vec = np.array ( (
     0.3678794411714423E+00, \
     0.8734230184931166E+00, \
     0.9818510730616665E+00, \
     0.9975243173927525E+00, \
     0.5452392118926051E+00, \
     0.4884435800065159E+00, \
     0.4589560693076638E+00, \
     0.4409910259429826E+00, \
     0.5452392118926051E+00, \
     0.3678794411714423E+00, \
     0.1922956455479649E+00, \
     0.6598803584531254E-01 ))

  x_vec = np.array ( (
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    alpha = 0.0
    beta = 0.0
    x = 0.0
    f = 0.0
  else:
    alpha = alpha_vec[n_data]
    beta = beta_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, alpha, beta, x, f

def extreme_values_cdf_values_test ( ):

#*****************************************************************************80
#
## extreme_values_cdf_values_test() tests extreme_values_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    06 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'extreme_values_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  extreme_values_cdf_values stores values of the Extreme Values CDF.' )
  print ( '' )
  print ( '        Alpha         Beta          X               CDF' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, alpha, beta, x, f = extreme_values_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16g' % ( alpha, beta, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'extreme_values_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def f_cdf_values ( n_data ):

#*****************************************************************************80
#
## f_cdf_values returns some values of the F CDF test function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = FRatioDistribution [ dfn, dfd ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    07 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer A, integer B, the parameters of the function.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  a_vec = np.array ( ( \
    1, \
    1, \
    5, \
    1, \
    2, \
    4, \
    1, \
    6, \
    8, \
    1, \
    3, \
    6, \
    1, \
    1, \
    1, \
    1, \
    2, \
    3, \
    4, \
    5 ))

  b_vec = np.array ( ( \
     1, \
     5, \
     1, \
     5, \
    10, \
    20, \
     5, \
     6, \
    16, \
     5, \
    10, \
    12, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5 ))

  f_vec = np.array ( ( \
     0.5000000000000000E+00, \
     0.4999714850534485E+00, \
     0.4996034370170990E+00, \
     0.7496993658293228E+00, \
     0.7504656462757382E+00, \
     0.7514156325324275E+00, \
     0.8999867031372156E+00, \
     0.8997127554259699E+00, \
     0.9002845660853669E+00, \
     0.9500248817817622E+00, \
     0.9500574946122442E+00, \
     0.9501926400000000E+00, \
     0.9750133887312993E+00, \
     0.9900022327445249E+00, \
     0.9949977837872073E+00, \
     0.9989999621122122E+00, \
     0.5687988496283079E+00, \
     0.5351452100063650E+00, \
     0.5143428032407864E+00, \
     0.5000000000000000E+00 ))

  x_vec = np.array ( ( \
      1.00E+00, \
      0.528E+00, \
      1.89E+00, \
      1.69E+00, \
      1.60E+00, \
      1.47E+00, \
      4.06E+00, \
      3.05E+00, \
      2.09E+00, \
      6.61E+00, \
      3.71E+00, \
      3.00E+00, \
     10.01E+00, \
     16.26E+00, \
     22.78E+00, \
     47.18E+00, \
      1.00E+00, \
      1.00E+00, \
      1.00E+00, \
      1.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0
    b = 0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, x, f

def f_cdf_values_test ( ):

#*****************************************************************************80
#
## f_cdf_values_test() tests f_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    07 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'f_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  f_cdf_values stores values of the F CDF.' )
  print ( '' )
  print ( '      A         B         X        f_cdf(A,B,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, x, f = f_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12d  %12f  %24.16g' % ( a, b, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'f_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def f_noncentral_cdf_values ( n_data ):

#*****************************************************************************80
#
## f_noncentral_cdf_values: values of the noncentral F CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = NoncentralFRatioDistribution [ n1, n2, lambda ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    08 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer A, integer B, the numerator and denominator
#    degrees of freedom.
#
#    real LAM, the noncentrality parameter.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 22

  a_vec = np.array ( ( \
     1,  1,  1,  1, \
     1,  1,  1,  1, \
     1,  1,  2,  2, \
     3,  3,  4,  4, \
     5,  5,  6,  6, \
     8, 16 ))

  b_vec = np.array ( ( \
     1,  5,  5,  5, \
     5,  5,  5,  5, \
     5,  5,  5, 10, \
     5,  5,  5,  5, \
     1,  5,  6, 12, \
    16,  8 ))

  f_vec = np.array ( ( \
     0.5000000000000000E+00, \
     0.6367825323508774E+00, \
     0.5840916116305482E+00, \
     0.3234431872392788E+00, \
     0.4501187879813550E+00, \
     0.6078881441188312E+00, \
     0.7059275551414605E+00, \
     0.7721782003263727E+00, \
     0.8191049017635072E+00, \
     0.3170348430749965E+00, \
     0.4327218008454471E+00, \
     0.4502696915707327E+00, \
     0.4261881186594096E+00, \
     0.6753687206341544E+00, \
     0.4229108778879005E+00, \
     0.6927667261228938E+00, \
     0.3632174676491226E+00, \
     0.4210054012695865E+00, \
     0.4266672258818927E+00, \
     0.4464016600524644E+00, \
     0.8445888579504827E+00, \
     0.4339300273343604E+00 ))

  lam_vec = np.array ( ( \
     0.00E+00, \
     0.00E+00, \
     0.25E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     2.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     2.00E+00, \
     1.00E+00, \
     1.00E+00, \
     0.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00 ))

  x_vec = np.array ( ( \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     0.50E+00, \
     1.00E+00, \
     2.00E+00, \
     3.00E+00, \
     4.00E+00, \
     5.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     2.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     2.00E+00, \
     2.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0
    b = 0
    lam = 0.0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    lam = lam_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, lam, x, f

def f_noncentral_cdf_values_test ( ):

#*****************************************************************************80
#
## f_noncentral_cdf_values_test() tests f_noncentral_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    08 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'f_noncentral_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  f_noncentral_cdf_values stores values of the noncentral F CDF.' )
  print ( '' )
  print ( '     A     B        LAM           X               F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, lam, x, f = f_noncentral_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4d  %4d  %12f  %12f  %24.16g' % ( a, b, lam, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'f_noncentral_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def fresnel_cos_values ( n_data ):

#*****************************************************************************80
#
## fresnel_cos_values returns values of the Fresnel cosine integral function.
#
#  Discussion:
#
#    The Fresnel cosine integral is defined by:
#
#      C(X) = integral ( 0 <= T <= X ) cos ( PI * T^2 / 2 ) dT
#
#    In Mathematica, the function can be evaluated by:
#
#      FresnelC[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 November 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 16

  fx_vec = np.array ( ( \
     0.0000000000000000E+00, \
     0.1999210575944531E+00, \
     0.3974807591723594E+00, \
     0.5810954469916523E+00, \
     0.7228441718963561E+00, \
     0.7798934003768228E+00, \
     0.7154377229230734E+00, \
     0.5430957835462564E+00, \
     0.3654616834404877E+00, \
     0.3336329272215571E+00, \
     0.4882534060753408E+00, \
     0.6362860449033195E+00, \
     0.5549614058564281E+00, \
     0.3889374961919690E+00, \
     0.4674916516989059E+00, \
     0.6057207892976856E+00 ))

  x_vec = np.array ( ( \
     0.0E+00, \
     0.2E+00, \
     0.4E+00, \
     0.6E+00, \
     0.8E+00, \
     1.0E+00, \
     1.2E+00, \
     1.4E+00, \
     1.6E+00, \
     1.8E+00, \
     2.0E+00, \
     2.2E+00, \
     2.4E+00, \
     2.6E+00, \
     2.8E+00, \
     3.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def fresnel_cos_values_test ( ):

#*****************************************************************************80
#
## fresnel_cos_values_test() tests fresnel_cos_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    08 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'fresnel_cos_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  fresnel_cos_values stores values of the Fresnel cosine integral.' )
  print ( '' )
  print ( '        X              F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = fresnel_cos_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'fresnel_cos_values_test:' )
  print ( '  Normal end of execution.' )
  return

def fresnel_sin_values ( n_data ):

#*****************************************************************************80
#
## fresnel_sin_values returns some values of the Fresnel sine integral function.
#
#  Discussion:
#
#    The Fresnel sine integral is defined by
#
#      S(X) = integral ( 0 <= T <= X ) sin ( pi * T^2 / 2 ) dT
#
#    In Mathematica, the function can be evaluated by:
#
#      FresnelS[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 November 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 16

  f_vec = np.array ( ( \
     0.0000000000000000E+00, \
     0.4187609161656762E-02, \
     0.3335943266061318E-01, \
     0.1105402073593870E+00, \
     0.2493413930539178E+00, \
     0.4382591473903548E+00, \
     0.6234009185462497E+00, \
     0.7135250773634121E+00, \
     0.6388876835093809E+00, \
     0.4509387692675831E+00, \
     0.3434156783636982E+00, \
     0.4557046121246569E+00, \
     0.6196899649456836E+00, \
     0.5499893231527195E+00, \
     0.3915284435431718E+00, \
     0.4963129989673750E+00 ) )

  x_vec = np.array ( ( \
     0.0E+00, \
     0.2E+00, \
     0.4E+00, \
     0.6E+00, \
     0.8E+00, \
     1.0E+00, \
     1.2E+00, \
     1.4E+00, \
     1.6E+00, \
     1.8E+00, \
     2.0E+00, \
     2.2E+00, \
     2.4E+00, \
     2.6E+00, \
     2.8E+00, \
     3.0E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def fresnel_sin_values_test ( ):

#*****************************************************************************80
#
## fresnel_sin_values_test() tests fresnel_sin_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    09 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'fresnel_sin_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  fresnel_sin_values stores values of the Fresnel sine integral.' )
  print ( '' )
  print ( '        X              F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = fresnel_sin_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'fresnel_sin_values_test:' )
  print ( '  Normal end of execution.' )
  return

def frobenius_number_data_values ( n_data, order ):

#*****************************************************************************80
#
## frobenius_number_data_values returns data for the Frobenius problem.
#
#  Discussion:
#
#    The user should first call frobenius_number_order_values to get the
#    order or size of the "C" vector that will be returned by this routine.
#
#    The Frobenius number of order N and data C is the solution of the
#    Frobenius coin sum problem for N coin denominations C(1) through C(N).
#
#    The Frobenius coin sum problem assumes the existence of
#    N coin denominations, and asks for the largest value that cannot
#    be formed by any combination of coins of these denominations.
#
#    The coin denominations are assumed to be distinct positive integers.
#
#    For general N, this problem is fairly difficult to handle.
#
#    For N = 2, it is known that:
#
#    * if C1 and C2 are not relatively prime, then
#      there are infinitely large values that cannot be formed.
#
#    * otherwise, the largest value that cannot be formed is
#      C1 * C2 - C1 - C2, and that exactly half the values between
#      1 and C1 * C2 - C1 - C2 + 1 cannot be represented.
#
#    As a simple example, if C1 = 2 and C2 = 7, then the largest
#    unrepresentable value is 5, and there are (5+1)/2 = 3
#    unrepresentable values, namely 1, 3, and 5.
#
#    For a general N, and a set of coin denominations C1, C2, \, CN,
#    the Frobenius number F(N, C(1:N) ) is defined as the largest value
#    B for which the equation
#
#      C1*X1 + C2*X2 + \ + CN*XN = B
#
#    has no nonnegative integer solution X(1:N).
#
#    In Mathematica, the Frobenius number can be determined by
#
#      FrobeniusNumber[ {C1,...,CN} ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Gerard Cornuejols, Regina Urbaniak, Robert Weismantel, Laurence Wolsey,
#    Decomposition of Integer Programs and of Generating Sets,
#    in Algorithms - ESA '97,
#    Lecture Notes in Computer Science 1284,
#    edited by Rainer Burkard, G Woeginger,
#    Springer, 1997, pages 92-103.
#
#    Robert Owens,
#    An Algorithm to Solve the Frobenius Problem,
#    Mathematics Magazine,
#    Volume 76, Number 4, October 2003, 264-275.
#
#    James Sylvester,
#    Question 7382,
#    Mathematical Questions with their Solutions,
#    Educational Times,
#    Volume 41, page 21, 1884.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  Unlike most other routines in this
#    library, this routine assumes that N_data has already been 
#    processed by a call to frobenius_number_order_value.  Therefore, 
#    this routine will return the next set of data as long as 
#    N_data is in the expected range.
#
#    integer ORDER, the order of the problem.
#
#  Output:
#
#    integer C(ORDER), the denominations of the problem.
#
#    integer F, the value of the function.
#
  import numpy as np

  n_max = 19

  c_vec = np.array ( [ \
    [     2,     5,     0,     0,     0,     0,     0,     0 ], \
    [     3,    17,     0,     0,     0,     0,     0,     0 ], \
    [     4,    19,     0,     0,     0,     0,     0,     0 ], \
    [     5,    13,     0,     0,     0,     0,     0,     0 ], \
    [    12,    11,     0,     0,     0,     0,     0,     0 ], \
    [    99,   100,     0,     0,     0,     0,     0,     0 ], \
    [     6,     9,    20,     0,     0,     0,     0,     0 ], \
    [     5,    17,    23,     0,     0,     0,     0,     0 ], \
    [   137,   251,   256,     0,     0,     0,     0,     0 ], \
    [    31,    41,    47,    61,     0,     0,     0,     0 ], \
    [   271,   277,   281,   283,     0,     0,     0,     0 ], \
    [    10,    18,    26,    33,    35,     0,     0,     0 ], \
    [    34,    37,    38,    40,    43,     0,     0,     0 ], \
    [ 12223, 12224, 36674, 61119, 85569,     0,     0,     0 ], \
    [  1000,  1476,  3764,  4864,  4871,  7773,     0,     0 ], \
    [ 12228, 36679, 36682, 46908, 61139, 73365,     0,     0 ], \
    [ 12137, 36405, 24269, 36407, 84545, 60683,     0,     0 ], \
    [ 13211, 13212, 39638, 66060, 52864, 79268, 92482,     0 ], \
    [ 13429, 26850, 26855, 40280, 40281, 53711, 53714, 67141 ] \
  ] )
 
  f_vec = np.array ( ( \
          3, \
         31, \
         53, \
         47, \
        109, \
       9701, \
         43, \
         41, \
       4948, \
        240, \
      13022, \
         67, \
        175, \
   89643481, \
      47350, \
   89716838, \
   58925134, \
  104723595, \
   45094583 ))
#
#  Step NDATA back 1.
#
  n_data = n_data - 1

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    c = []
    f = 0
  else:
    c = np.zeros ( order )
    for j in range ( 0, order ):
      c[j] = c_vec[n_data,j]
    f = f_vec[n_data]

  return c, f

def frobenius_number_data_values_test ( ):

#*****************************************************************************80
#
## frobenius_number_data_values_test() tests frobenius_number_data_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'frobenius_number_data_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  frobenius_number_data_values returns the coin denominations' )
  print ( '  for a Frobenius problem.' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, order = frobenius_number_order_values ( n_data )

    if ( n_data == 0 ):
      break

    c, f = frobenius_number_data_values ( n_data, order )

    print ( '' )
    print ( '  Order = %d' % ( order ) )
    for i in range ( 0, order ):
      print ( '  %8d' % ( c[i] ) )
    print ( '' )
    print ( '' )
    print ( '  Frobenius number = %d' % ( f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'frobenius_number_data_values_test:' )
  print ( '  Normal end of execution.' )
  return

def frobenius_number_order2_values ( n_data ):

#*****************************************************************************80
#
## frobenius_number_order2_values returns values of the order 2 Frobenius number.
#
#  Discussion:
#
#    The Frobenius number of order N is the solution of the Frobenius
#    coin sum problem for N coin denominations.
#
#    The Frobenius coin sum problem assumes the existence of
#    N coin denominations, and asks for the largest value that cannot
#    be formed by any combination of coins of these denominations.
#
#    The coin denominations are assumed to be distinct positive integers.
#
#    For general N, this problem is fairly difficult to handle.
#
#    For N = 2, it is known that:
#
#    * if C1 and C2 are not relatively prime, then
#      there are infinitely large values that cannot be formed.
#
#    * otherwise, the largest value that cannot be formed is
#      C1 * C2 - C1 - C2, and that exactly half the values between
#      1 and C1 * C2 - C1 - C2 + 1 cannot be represented.
#
#    As a simple example, if C1 = 2 and C2 = 7, then the largest
#    unrepresentable value is 5, and there are (5+1)/2 = 3
#    unrepresentable values, namely 1, 3, and 5.
#
#    For a general N, and a set of coin denominations C1, C2, ..., CN,
#    the Frobenius number F(N, C(1:N) ) is defined as the largest value
#    B for which the equation
#
#      C1*X1 + C2*X2 + ... + CN*XN = B
#
#    has no nonnegative integer solution X(1:N).
#
#    In Mathematica, the Frobenius number can be determined by
#
#      FrobeniusNumber[ {C1,...,CN} ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 November 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Gerard Cornuejols, Regina Urbaniak, Robert Weismantel, Laurence Wolsey,
#    Decomposition of Integer Programs and of Generating Sets,
#    in Algorithms - ESA '97,
#    Lecture Notes in Computer Science 1284,
#    edited by Rainer Burkard, G Woeginger,
#    Springer, 1997, pages 92-103,
#    LC: QA76.9.A43.E83.
#
#    Robert Owens,
#    An Algorithm to Solve the Frobenius Problem,
#    Mathematics Magazine,
#    Volume 76, Number 4, October 2003, 264-275.
#
#    James Sylvester,
#    Question 7382,
#    Mathematical Questions with their Solutions,
#    Educational Times,
#    Volume 41, page 21, 1884.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer C1, C2, the parameters of the function.
#
#    integer F, the value of the function.
#
  import numpy as np

  n_max = 6

  c1_vec = np.array ( ( 2,  3,  4,  5,  12,  99 ) )
  c2_vec = np.array ( ( 5,  17,  19,  13,  11,  100 ) )
  f_vec = np.array ( ( 3,  31,  53,  47,  109,  9701 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    c1 = 0
    c2 = 0
    f = 0
  else:
    c1 = c1_vec[n_data]
    c2 = c2_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, c1, c2, f

def frobenius_number_order2_values_test ( ):

#*****************************************************************************80
#
## frobenius_number_order2_values_test() tests frobenius_number_order2_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 November 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'frobenius_number_order2_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  frobenius_number_order2_values returns values of' )
  print ( '  the Frobenius number of order 2.' )
  print ( '' )
  print ( '         C1        C2          F(C1,C2)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, c1, c2, f = frobenius_number_order2_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %8d  %8d  %8d' % ( c1, c2, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'frobenius_number_order2_values_test:' )
  print ( '  Normal end of execution.' )
  return

def frobenius_number_order_values ( n_data ):

#*****************************************************************************80
#
## frobenius_number_order_values returns orders of the Frobenius problem.
#
#  Discussion:
#
#    This routine returns the order or size of a Frobenius problem.
#    To get the corresponding data, call frobenius_number_data_values.
#
#    The Frobenius number of order N and data C is the solution of a Frobenius
#    coin sum problem for N coin denominations C(1) through C(N).
#
#    The Frobenius coin sum problem assumes the existence of
#    N coin denominations, and asks for the largest value that cannot
#    be formed by any combination of coins of these denominations.
#
#    The coin denominations are assumed to be distinct positive integers.
#
#    For general order N, this problem is fairly difficult to handle.
#
#    For order N = 2, it is known that:
#
#    * if C1 and C2 are not relatively prime, then
#      there are infinitely large values that cannot be formed.
#
#    * otherwise, the largest value that cannot be formed is
#      C1 * C2 - C1 - C2, and that exactly half the values between
#      1 and C1 * C2 - C1 - C2 + 1 cannot be represented.
#
#    As a simple example, if C1 = 2 and C2 = 7, then the largest
#    unrepresentable value is 5, and there are (5+1)/2 = 3
#    unrepresentable values, namely 1, 3, and 5.
#
#    For a general N, and a set of coin denominations C1, C2, \, CN,
#    the Frobenius number F(N, C(1:N) ) is defined as the largest value
#    B for which the equation
#
#      C1*X1 + C2*X2 + ... + CN*XN = B
#
#    has no nonnegative integer solution X(1:N).
#
#    In Mathematica, the Frobenius number can be determined by
#
#      FrobeniusNumber[ {C1,...,CN} ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    10 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Gerard Cornuejols, Regina Urbaniak, Robert Weismantel, Laurence Wolsey,
#    Decomposition of Integer Programs and of Generating Sets,
#    in Algorithms - ESA '97,
#    Lecture Notes in Computer Science 1284,
#    edited by R Burkard, G Woeginger,
#    Springer, 1997, pages 92-103,
#    LC: QA76.9.A43.E83.
#
#    Robert Owens,
#    An Algorithm to Solve the Frobenius Problem,
#    Mathematics Magazine,
#    Volume 76, Number 4, October 2003, 264-275.
#
#    James Sylvester,
#    Question 7382,
#    Mathematical Questions with their Solutions,
#    Educational Times,
#    Volume 41, page 21, 1884.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer ORDER, the order of a Frobenius problem.
#
  import numpy as np

  n_max = 19

  order_vec = np.array ( ( \
    2, \
    2, \
    2, \
    2, \
    2, \
    2, \
    3, \
    3, \
    3, \
    4, \
    4, \
    5, \
    5, \
    5, \
    6, \
    6, \
    6, \
    7, \
    8  \
  ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    order = 0
  else:
    order = order_vec[n_data]
    n_data = n_data + 1

  return n_data, order

def frobenius_number_order_values_test ( ):

#*****************************************************************************80
#
## frobenius_number_order_values_test() tests frobenius_number_order_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    10 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'frobenius_number_order_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  frobenius_number_order_values returns the order for' )
  print ( '  a Frobenius problem.' )
  print ( '' )
  print ( '   Problem   Order' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, order = frobenius_number_order_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %8d  %8d' % ( n_data, order ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'frobenius_number_order_values_test:' )
  print ( '  Normal end of execution.' )
  return

def gamma_01_pdf_values ( n_data ):

#*****************************************************************************80
#
## gamma_01_pdf_values returns some values of the standard Gamma PDF.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    28 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real ALPHA, the shape parameter.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 10

  alpha_vec = np.array ( ( \
         1.092091484911879, \
         4.147546169663503, \
         2.076535407379806, \
         1.287888961910225, \
        0.2191449888955355, \
        0.3086361453280091, \
         2.006531407488083, \
         3.986434770531281, \
         4.487520304498656, \
         0.472723751058401 ))

  f_vec = np.array ( ( \
    0.00009260811963612823, \
        0.1260335478747823, \
        0.1363536772414351, \
        0.5114450139194701, \
     0.0001230139468263628, \
      0.001870342832511005, \
      0.004476000451227789, \
                       0.0, \
        0.2056668486524041, \
                       0.0 ))

  x_vec = np.array ( ( \
         9.541334553343761, \
          5.39780214905239, \
        0.1942467166183289, \
        0.6545463320909413, \
         6.156639979175331, \
         4.220159083225351, \
         7.424071607424807, \
       -0.4806971028367454, \
          3.18289954879574, \
       -0.3570226383736496 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    alpha = 0.0
    x = 0.0
    f = 0.0
  else:
    alpha = alpha_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, alpha, x, f

def gamma_01_pdf_values_test ( ):

#*****************************************************************************80
#
## gamma_01_pdf_values_test() tests gamma_01_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    28 July 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'gamma_01_pdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  gamma_01_pdf_values stores values of the standard Gamma PDF.' )
  print ( '' )
  print ( '        ALPHA         X               PDF' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, alpha, x, f = gamma_01_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %24.16g' % ( alpha, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'gamma_01_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def gamma_cdf_values ( n_data ):

#*****************************************************************************80
#
## gamma_cdf_values returns some values of the Gamma CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = GammaDistribution [ mu, sigma ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    11 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real MU, the mean of the distribution.
#
#    real SIGMA, the standard deviation of the distribution.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 12

  f_vec = np.array ( ( \
     0.8646647167633873E+00, \
     0.9816843611112658E+00, \
     0.9975212478233336E+00, \
     0.9996645373720975E+00, \
     0.6321205588285577E+00, \
     0.4865828809674080E+00, \
     0.3934693402873666E+00, \
     0.3296799539643607E+00, \
     0.4421745996289254E+00, \
     0.1911531694619419E+00, \
     0.6564245437845009E-01, \
     0.1857593622214067E-01 ))

  mu_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01 ))

  sigma_vec = np.array ( ( \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01 ))

  x_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    mu = 0.0
    sigma = 0.0
    x = 0.0
    f = 0.0
  else:
    mu = mu_vec[n_data]
    sigma = sigma_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, mu, sigma, x, f

def gamma_cdf_values_test ( ):

#*****************************************************************************80
#
## gamma_cdf_values_test() tests gamma_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    11 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'gamma_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  gamma_cdf_values stores values of the GAMMA CDF.' )
  print ( '' )
  print ( '      Mu        Sigma      X        F(Mu,Sigma,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, mu, sigma, x, f = gamma_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16g' % ( mu, sigma, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'gamma_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def gamma_inc_p_values ( n_data ):

#*****************************************************************************80
#
## gamma_inc_p_values values of the normalized incomplete Gamma function P(A,X)
#
#  Discussion:
#
#    The (normalized) incomplete Gamma function is defined as:
#
#      P(A,X) = 1/Gamma(A) * Integral ( 0 <= T <= X ) T^(A-1) * exp(-T) dT.
#
#    With this definition, for all A and X,
#
#      0 <= P(A,X) <= 1
#
#    and
#
#      P(A,oo) = 1.0
#
#    In Mathematica, the function can be evaluated by:
#
#      1 - GammaRegularized[A,X]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    12 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, the parameter of the function.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  a_vec = np.array (( \
     0.10E+00, \
     0.10E+00, \
     0.10E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.10E+01, \
     0.10E+01, \
     0.10E+01, \
     0.11E+01, \
     0.11E+01, \
     0.11E+01, \
     0.20E+01, \
     0.20E+01, \
     0.20E+01, \
     0.60E+01, \
     0.60E+01, \
     0.11E+02, \
     0.26E+02, \
     0.41E+02  ))

  f_vec = (( \
     0.7382350532339351E+00, \
     0.9083579897300343E+00, \
     0.9886559833621947E+00, \
     0.3014646416966613E+00, \
     0.7793286380801532E+00, \
     0.9918490284064973E+00, \
     0.9516258196404043E-01, \
     0.6321205588285577E+00, \
     0.9932620530009145E+00, \
     0.7205974576054322E-01, \
     0.5891809618706485E+00, \
     0.9915368159845525E+00, \
     0.1018582711118352E-01, \
     0.4421745996289254E+00, \
     0.9927049442755639E+00, \
     0.4202103819530612E-01, \
     0.9796589705830716E+00, \
     0.9226039842296429E+00, \
     0.4470785799755852E+00, \
     0.7444549220718699E+00 ))

  x_vec = (( \
     0.30E-01, \
     0.30E+00, \
     0.15E+01, \
     0.75E-01, \
     0.75E+00, \
     0.35E+01, \
     0.10E+00, \
     0.10E+01, \
     0.50E+01, \
     0.10E+00, \
     0.10E+01, \
     0.50E+01, \
     0.15E+00, \
     0.15E+01, \
     0.70E+01, \
     0.25E+01, \
     0.12E+02, \
     0.16E+02, \
     0.25E+02, \
     0.45E+02 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, x, f

def gamma_inc_p_values_test ( ):

#*****************************************************************************80
#
## gamma_inc_p_values_test() tests gamma_inc_p_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    12 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'gamma_inc_p_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  gamma_inc_p_values stores values of an incomplete Gamma function.' )
  print ( '' )
  print ( '      A         X        gamma_inc_p(A,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, x, f = gamma_inc_p_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( a, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'gamma_inc_p_values_test:' )
  print ( '  Normal end of execution.' )
  return

def gamma_inc_q_values ( n_data ):

#*****************************************************************************80
#
## gamma_inc_q_values: values of the normalized incomplete Gamma function Q(A,X).
#
#  Discussion:
#
#    The (normalized) incomplete Gamma function is defined as:
#
#      Q(A,X) = 1/Gamma(A) * Integral ( X <= T < oo ) T^(A-1) * exp(-T) dT.
#
#    With this definition, for all A and X,
#
#      0 <= Q(A,X) <= 1
#
#    and
#
#      Q(A,INFINITY) = 0.0
#
#    In Mathematica, the function can be evaluated by:
#
#      GammaRegularized[A,X]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, the parameter of the function.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  a_vec = np.array ( ( \
     0.10E+00, \
     0.10E+00, \
     0.10E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.10E+01, \
     0.10E+01, \
     0.10E+01, \
     0.11E+01, \
     0.11E+01, \
     0.11E+01, \
     0.20E+01, \
     0.20E+01, \
     0.20E+01, \
     0.60E+01, \
     0.60E+01, \
     0.11E+02, \
     0.26E+02, \
     0.41E+02  ))

  f_vec = np.array ( ( \
    0.2617649467660649, \
    0.09164201026996572, \
    0.01134401663780527, \
    0.6985353583033387, \
    0.2206713619198468, \
    0.008150971593502700, \
    0.9048374180359596, \
    0.3678794411714423, \
    0.006737946999085467, \
    0.9279402542394568, \
    0.4108190381293515, \
    0.008463184015447498, \
    0.9898141728888165, \
    0.5578254003710746, \
    0.007295055724436130, \
    0.9579789618046939, \
    0.02034102941692837, \
    0.07739601577035708, \
    0.5529214200244148, \
    0.2555450779281301 ))

  x_vec = np.array ( ( \
     0.30E-01, \
     0.30E+00, \
     0.15E+01, \
     0.75E-01, \
     0.75E+00, \
     0.35E+01, \
     0.10E+00, \
     0.10E+01, \
     0.50E+01, \
     0.10E+00, \
     0.10E+01, \
     0.50E+01, \
     0.15E+00, \
     0.15E+01, \
     0.70E+01, \
     0.25E+01, \
     0.12E+02, \
     0.16E+02, \
     0.25E+02, \
     0.45E+02 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, x, f

def gamma_inc_q_values_test ( ):

#*****************************************************************************80
#
## gamma_inc_q_values_test() tests gamma_inc_q_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'gamma_inc_q_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  gamma_inc_q_values stores values of an incomplete Gamma function.' )
  print ( '' )
  print ( '      A         X        gamma_inc_q(A,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, x, f = gamma_inc_q_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( a, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'gamma_inc_q_values_test:' )
  print ( '  Normal end of execution.' )
  return

def gamma_inc_tricomi_values ( n_data ):

#*****************************************************************************80
#
## gamma_inc_tricomi_values: values of Tricomi's incomplete Gamma function.
#
#  Discussion:
#
#    Tricomi's incomplete Gamma function is defined as:
#
#      1/Gamma(A) * 1/X^A * Integral ( 0 <= T <= X ) T^(A-1) * exp(-T) dT.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, the parameter of the function.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  a_vec = np.array ( ( \
     0.10E+00, \
     0.10E+00, \
     0.10E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.10E+01, \
     0.10E+01, \
     0.10E+01, \
     0.11E+01, \
     0.11E+01, \
     0.11E+01, \
     0.20E+01, \
     0.20E+01, \
     0.20E+01, \
     0.60E+01, \
     0.60E+01, \
     0.11E+02, \
     0.26E+02, \
     0.41E+02  ))

  f_vec = np.array ( ( \
    1.048292641463504E+00, \
    1.024577737369574E+00, \
    0.9493712443185374E+00, \
    1.100793230316492E+00, \
    0.8998911979655218E+00, \
    0.5301656062431039E+00, \
    0.9516258196404043E+00, \
    0.6321205588285577E+00, \
    0.1986524106001829E+00, \
    0.9071784510537487E+00, \
    0.5891809618706485E+00, \
    0.1688269752193589E+00, \
    0.4527034271637121E+00, \
    0.1965220442795224E+00, \
    0.02025928457705232E+00, \
    0.0001721181724479739E+00, \
    3.280858070850586E-07, \
    5.244396471821590E-14, \
    2.013462926183376E-37, \
    1.230623887499875E-68 ))

  x_vec = np.array ( ( \
     0.30E-01, \
     0.30E+00, \
     0.15E+01, \
     0.75E-01, \
     0.75E+00, \
     0.35E+01, \
     0.10E+00, \
     0.10E+01, \
     0.50E+01, \
     0.10E+00, \
     0.10E+01, \
     0.50E+01, \
     0.15E+00, \
     0.15E+01, \
     0.70E+01, \
     0.25E+01, \
     0.12E+02, \
     0.16E+02, \
     0.25E+02, \
     0.45E+02 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, x, f

def gamma_inc_tricomi_values_test ( ):

#*****************************************************************************80
#
## gamma_inc_tricomi_values_test() tests gamma_inc_tricomi_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'gamma_inc_tricomi_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  gamma_inc_tricomi_values stores values of an incomplete Gamma function.' )
  print ( '' )
  print ( '      A         X        F(A,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, x, f = gamma_inc_tricomi_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( a, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'gamma_inc_tricomi_values_test:' )
  print ( '  Normal end of execution.' )
  return

def gamma_inc_values ( n_data ):

#*****************************************************************************80
#
## gamma_inc_values returns some values of the incomplete Gamma function.
#
#  Discussion:
#
#    The (normalized) incomplete Gamma function is defined as:
#
#      Integral ( X <= T < oo ) T^(A-1) * exp(-T) dT.
#
#    In Mathematica, the function can be evaluated by:
#
#      Gamma[A,X]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    25 April 2016
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, the parameter of the function.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  a_vec = np.array ( ( \
     0.10E+00, \
     0.10E+00, \
     0.10E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.10E+01, \
     0.10E+01, \
     0.10E+01, \
     0.11E+01, \
     0.11E+01, \
     0.11E+01, \
     0.20E+01, \
     0.20E+01, \
     0.20E+01, \
     0.60E+01, \
     0.60E+01, \
     0.11E+02, \
     0.26E+02, \
     0.41E+02 ))

  f_vec = np.array ( ( \
    2.490302836300570E+00, \
    0.8718369702247978E+00, \
    0.1079213896175866E+00, \
    1.238121685818417E+00, \
    0.3911298052193973E+00, \
    0.01444722098952533E+00, \
    0.9048374180359596E+00, \
    0.3678794411714423E+00, \
    0.006737946999085467E+00, \
    0.8827966752611692E+00, \
    0.3908330082003269E+00, \
    0.008051456628620993E+00, \
    0.9898141728888165E+00, \
    0.5578254003710746E+00, \
    0.007295055724436130E+00, \
    114.9574754165633E+00, \
    2.440923530031405E+00, \
    280854.6620274718E+00, \
    8.576480283455533E+24, \
    2.085031346403364E+47 ))

  x_vec = np.array ( ( \
     0.30E-01, \
     0.30E+00, \
     0.15E+01, \
     0.75E-01, \
     0.75E+00, \
     0.35E+01, \
     0.10E+00, \
     0.10E+01, \
     0.50E+01, \
     0.10E+00, \
     0.10E+01, \
     0.50E+01, \
     0.15E+00, \
     0.15E+01, \
     0.70E+01, \
     0.25E+01, \
     0.12E+02, \
     0.16E+02, \
     0.25E+02, \
     0.45E+02 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, x, f

def gamma_inc_values_test ( ):

#*****************************************************************************80
#
## gamma_inc_values_test() tests gamma_inc_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'gamma_inc_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  gamma_inc_values stores values of the incomplete Gamma function.' )
  print ( '' )
  print ( '      A         X        gamma_inc(A,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, x, f = gamma_inc_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( a, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'gamma_inc_values_test:' )
  print ( '  Normal end of execution.' )
  return

def gamma_log_values ( n_data ):

#*****************************************************************************80
#
## gamma_log_values returns some values of the Log Gamma function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Log[Gamma[x]]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 November 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  fx_vec = np.array ( ( \
      0.1524063822430784E+01, \
      0.7966778177017837E+00, \
      0.3982338580692348E+00, \
      0.1520596783998375E+00, \
      0.0000000000000000E+00, \
     -0.4987244125983972E-01, \
     -0.8537409000331584E-01, \
     -0.1081748095078604E+00, \
     -0.1196129141723712E+00, \
     -0.1207822376352452E+00, \
     -0.1125917656967557E+00, \
     -0.9580769740706586E-01, \
     -0.7108387291437216E-01, \
     -0.3898427592308333E-01, \
     0.00000000000000000E+00, \
     0.69314718055994530E+00, \
     0.17917594692280550E+01, \
     0.12801827480081469E+02, \
     0.39339884187199494E+02, \
     0.71257038967168009E+02 ) )

  x_vec = np.array ( ( \
      0.20E+00, \
      0.40E+00, \
      0.60E+00, \
      0.80E+00, \
      1.00E+00, \
      1.10E+00, \
      1.20E+00, \
      1.30E+00, \
      1.40E+00, \
      1.50E+00, \
      1.60E+00, \
      1.70E+00, \
      1.80E+00, \
      1.90E+00, \
      2.00E+00, \
      3.00E+00, \
      4.00E+00, \
     10.00E+00, \
     20.00E+00, \
     30.00E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def gamma_log_values_test ( ):

#*****************************************************************************80
#
## gamma_log_values_test() tests gamma_log_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    02 February 2009
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'gamma_log_values:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  gamma_log_values stores values of' )
  print ( '  the logarithm of the Gamma function.' )
  print ( '' )
  print ( '      X            gamma_log(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = gamma_log_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'gamma_log_values_test:' )
  print ( '  Normal end of execution.' )
  return

def gamma_pdf_values ( n_data ):

#*****************************************************************************80
#
## gamma_pdf_values returns some values of a Gamma PDF.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    29 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real BETA, the rate parameter.
#
#    real ALPHA, the shape parameter.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 10

  beta_vec = np.array ( ( \
         1.092091484911879, \
         2.808477213834471, \
         1.287888961910225, \
         3.169828561512062, \
         2.006531407488083, \
      0.009191855792026001, \
         0.472723751058401, \
         4.204237253278341, \
         1.301514988836825, \
         1.758143299519481 ))

  alpha_vec = np.array ( ( \
         4.781587882544648, \
         2.076535407379806, \
         0.549783967662353, \
        0.3086361453280091, \
         3.773367432107051, \
         4.487520304498656, \
       0.06808445791730976, \
        0.6155195788227712, \
         4.562418534907164, \
         4.114436583429598 ))

  f_vec = np.array ( ( \
        0.1672017697220646, \
        0.8522122814089312, \
         2.122272611165834, \
     6.993771842317114e-05, \
       0.01679379733182281, \
     6.687464259463117e-10, \
      0.001295436045931343, \
                       0.0, \
       0.01189893036865762, \
        0.3658836103539945 ))

  x_vec = np.array ( ( \
         4.942957250382744, \
        0.2099361564793942, \
       0.07173978623046406, \
         2.587141553904492, \
         4.743179115458788, \
         1.974664495479389, \
         5.126400502735112, \
       -0.1534233427414219, \
        0.5047170879434957, \
         1.456220075613112 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    beta = 0.0
    alpha = 0.0
    x = 0.0
    f = 0.0
  else:
    beta = beta_vec[n_data]
    alpha = alpha_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, beta, alpha, x, f

def gamma_pdf_values_test ( ):

#*****************************************************************************80
#
## gamma_pdf_values_test() tests gamma_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    28 July 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'gamma_pdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  gamma_pdf_values stores values of the standard Gamma PDF.' )
  print ( '' )
  print ( '           BETA            ALPHA          X               PDF' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, beta, alpha, x, f = gamma_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %14g  %14g  %14g  %24.16g' % ( beta, alpha, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'gamma_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def gamma_values ( n_data ):

#*****************************************************************************80
#
## gamma_values returns some values of the Gamma function.
#
#  Discussion:
#
#    The Gamma function is defined as:
#
#      Gamma(Z) = Integral ( 0 <= T < Infinity) T^(Z-1) exp(-T) dT
#
#    It satisfies the recursion:
#
#      Gamma(X+1) = X * Gamma(X)
#
#    Gamma is undefined for nonpositive integral X.
#    Gamma(0.5) = sqrt(PI)
#    For N a positive integer, Gamma(N+1) = N!, the standard factorial.
#
#    In Mathematica, the function can be evaluated by:
#
#      Gamma[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    25 July 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 25

  fx_vec = np.array ( ( \
     -0.3544907701811032E+01, \
     -0.1005871979644108E+03, \
      0.9943258511915060E+02, \
      0.9513507698668732E+01, \
      0.4590843711998803E+01, \
      0.2218159543757688E+01, \
      0.1772453850905516E+01, \
      0.1489192248812817E+01, \
      0.1164229713725303E+01, \
      0.1000000000000000E+01, \
      0.9513507698668732E+00, \
      0.9181687423997606E+00, \
      0.8974706963062772E+00, \
      0.8872638175030753E+00, \
      0.8862269254527580E+00, \
      0.8935153492876903E+00, \
      0.9086387328532904E+00, \
      0.9313837709802427E+00, \
      0.9617658319073874E+00, \
      0.1000000000000000E+01, \
      0.2000000000000000E+01, \
      0.6000000000000000E+01, \
      0.3628800000000000E+06, \
      0.1216451004088320E+18, \
      0.8841761993739702E+31 ) )

  x_vec = np.array ( ( \
     -0.50E+00, \
     -0.01E+00, \
      0.01E+00, \
      0.10E+00, \
      0.20E+00, \
      0.40E+00, \
      0.50E+00, \
      0.60E+00, \
      0.80E+00, \
      1.00E+00, \
      1.10E+00, \
      1.20E+00, \
      1.30E+00, \
      1.40E+00, \
      1.50E+00, \
      1.60E+00, \
      1.70E+00, \
      1.80E+00, \
      1.90E+00, \
      2.00E+00, \
      3.00E+00, \
      4.00E+00, \
     10.00E+00, \
     20.00E+00, \
     30.00E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def gamma_values_test ( ):

#*****************************************************************************80
#
## gamma_value_test() tests gamma_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    02 February 2009
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'gamma_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  gamma_values stores values of the Gamma function.' )
  print ( '' )
  print ( '      X            GAMMA(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = gamma_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'gamma_values_test:' )
  print ( '  Normal end of execution.' )
  return

def gegenbauer_polynomial_values ( n_data ):

#*****************************************************************************80
#
## gegenbauer_polynomial_values returns some values of the Gegenbauer polynomials.
#
#  Discussion:
#
#    The Gegenbauer polynomials are also known as the "spherical
#    polynomials" or "ultraspherical polynomials".
#
#    In Mathematica, the function can be evaluated by:
#
#      GegenbauerC[n,m,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    08 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order parameter of the function.
#
#    real A, the real parameter of the function.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 38

  a_vec = np.array ( ( \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.0E+00, \
      1.0E+00, \
      2.0E+00, \
      3.0E+00, \
      4.0E+00, \
      5.0E+00, \
      6.0E+00, \
      7.0E+00, \
      8.0E+00, \
      9.0E+00, \
     10.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00 ))

  f_vec = np.array ( ( \
       1.0000000000E+00, \
       0.2000000000E+00, \
      -0.4400000000E+00, \
      -0.2800000000E+00, \
       0.2320000000E+00, \
       0.3075200000E+00, \
      -0.0805760000E+00, \
      -0.2935168000E+00, \
      -0.0395648000E+00, \
       0.2459712000E+00, \
       0.1290720256E+00, \
       0.0000000000E+00, \
      -0.3600000000E+00, \
      -0.0800000000E+00, \
       0.8400000000E+00, \
       2.4000000000E+00, \
       4.6000000000E+00, \
       7.4400000000E+00, \
      10.9200000000E+00, \
      15.0400000000E+00, \
      19.8000000000E+00, \
      25.2000000000E+00, \
      -9.0000000000E+00, \
      -0.1612800000E+00, \
      -6.6729600000E+00, \
      -8.3750400000E+00, \
      -5.5267200000E+00, \
       0.0000000000E+00, \
       5.5267200000E+00, \
       8.3750400000E+00, \
       6.6729600000E+00, \
       0.1612800000E+00, \
      -9.0000000000E+00, \
     -15.4252800000E+00, \
      -9.6969600000E+00, \
      22.4409600000E+00, \
     100.8892800000E+00, \
     252.0000000000E+00 ))

  n_vec = np.array ( ( \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10,  2, \
     2,  2,  2, \
     2,  2,  2, \
     2,  2,  2, \
     2,  5,  5, \
     5,  5,  5, \
     5,  5,  5, \
     5,  5,  5, \
     5,  5,  5, \
     5,  5 ))

  x_vec = np.array ( ( \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
     -0.50E+00, \
     -0.40E+00, \
     -0.30E+00, \
     -0.20E+00, \
     -0.10E+00, \
      0.00E+00, \
      0.10E+00, \
      0.20E+00, \
      0.30E+00, \
      0.40E+00, \
      0.50E+00, \
      0.60E+00, \
      0.70E+00, \
      0.80E+00, \
      0.90E+00, \
      1.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    a = 0.0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    a = a_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, a, x, f

def gegenbauer_polynomial_values_test ( ):

#*****************************************************************************80
#
## gegenbauer_polynomial_values_test() tests gegenbauer_polynomial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    08 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'gegenbauer_polynomial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  gegenbauer_polynomial_values stores values of the Gegenbauer polynomials.' )
  print ( '' )
  print ( '      N            A         X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, a, x, fx = gegenbauer_polynomial_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %12f  %24.16g' % ( n, a, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'gegenbauer_polynomial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def gegenbauer_poly_values ( n_data ):

#*****************************************************************************80
#
## gegenbauer_poly_values returns some values of the Gegenbauer polynomials.
#
#  Discussion:
#
#    The Gegenbauer polynomials are also known as the "spherical
#    polynomials" or "ultraspherical polynomials".
#
#    In Mathematica, the function can be evaluated by:
#
#      GegenbauerC[n,m,x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    08 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order parameter of the function.
#
#    real A, the real parameter of the function.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 38

  a_vec = np.array ( ( \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.5E+00, \
      0.0E+00, \
      1.0E+00, \
      2.0E+00, \
      3.0E+00, \
      4.0E+00, \
      5.0E+00, \
      6.0E+00, \
      7.0E+00, \
      8.0E+00, \
      9.0E+00, \
     10.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00, \
      3.0E+00 ))

  f_vec = np.array ( ( \
       1.0000000000E+00, \
       0.2000000000E+00, \
      -0.4400000000E+00, \
      -0.2800000000E+00, \
       0.2320000000E+00, \
       0.3075200000E+00, \
      -0.0805760000E+00, \
      -0.2935168000E+00, \
      -0.0395648000E+00, \
       0.2459712000E+00, \
       0.1290720256E+00, \
       0.0000000000E+00, \
      -0.3600000000E+00, \
      -0.0800000000E+00, \
       0.8400000000E+00, \
       2.4000000000E+00, \
       4.6000000000E+00, \
       7.4400000000E+00, \
      10.9200000000E+00, \
      15.0400000000E+00, \
      19.8000000000E+00, \
      25.2000000000E+00, \
      -9.0000000000E+00, \
      -0.1612800000E+00, \
      -6.6729600000E+00, \
      -8.3750400000E+00, \
      -5.5267200000E+00, \
       0.0000000000E+00, \
       5.5267200000E+00, \
       8.3750400000E+00, \
       6.6729600000E+00, \
       0.1612800000E+00, \
      -9.0000000000E+00, \
     -15.4252800000E+00, \
      -9.6969600000E+00, \
      22.4409600000E+00, \
     100.8892800000E+00, \
     252.0000000000E+00 ))

  n_vec = np.array ( ( \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10,  2, \
     2,  2,  2, \
     2,  2,  2, \
     2,  2,  2, \
     2,  5,  5, \
     5,  5,  5, \
     5,  5,  5, \
     5,  5,  5, \
     5,  5,  5, \
     5,  5 ))

  x_vec = np.array ( ( \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.20E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
      0.40E+00, \
     -0.50E+00, \
     -0.40E+00, \
     -0.30E+00, \
     -0.20E+00, \
     -0.10E+00, \
      0.00E+00, \
      0.10E+00, \
      0.20E+00, \
      0.30E+00, \
      0.40E+00, \
      0.50E+00, \
      0.60E+00, \
      0.70E+00, \
      0.80E+00, \
      0.90E+00, \
      1.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    a = 0.0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    a = a_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, a, x, f

def gegenbauer_poly_values_test ( ):

#*****************************************************************************80
#
## gegenbauer_poly_values_test() tests gegenbauer_poly_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    08 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'gegenbauer_poly_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  gegenbauer_poly_values stores values of the Gegenbauer polynomials.' )
  print ( '' )
  print ( '      N            A         X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, a, x, fx = gegenbauer_poly_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %12f  %24.16g' % ( n, a, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'gegenbauer_poly_values_test:' )
  print ( '  Normal end of execution.' )
  return

def geometric_cdf_values ( n_data ):

#*****************************************************************************80
#
## geometric_cdf_values returns values of the geometric CDF.
#
#  Discussion:
#
#    The geometric or Pascal probability density function gives the 
#    probability that the first success will happen on the X-th Bernoulli 
#    trial, given that the probability of a success on a single trial is P.
#
#    The value of CDF ( X, P ) is the probability that the first success
#    will happen on or before the X-th trial.
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`DiscreteDistributions`]
#      dist = GeometricDistribution [ p ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#    Daniel Zwillinger and Stephen Kokoska,
#    CRC Standard Probability and Statistics Tables and Formulae,
#    Chapman and Hall / CRC Press, 2000.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer X, the number of trials.
#
#    real P, the probability of success 
#    on one trial.
#
#    real CDF, the cumulative density function.
#
  import numpy as np

  n_max = 14

  cdf_vec = np.array ( ( \
     0.1900000000000000E+00, \
     0.2710000000000000E+00, \
     0.3439000000000000E+00, \
     0.6861894039100000E+00, \
     0.3600000000000000E+00, \
     0.4880000000000000E+00, \
     0.5904000000000000E+00, \
     0.9141006540800000E+00, \
     0.7599000000000000E+00, \
     0.8704000000000000E+00, \
     0.9375000000000000E+00, \
     0.9843750000000000E+00, \
     0.9995117187500000E+00, \
     0.9999000000000000E+00 ))

  p_vec = np.array ( ( \
     0.1E+00, \
     0.1E+00, \
     0.1E+00, \
     0.1E+00, \
     0.2E+00, \
     0.2E+00, \
     0.2E+00, \
     0.2E+00, \
     0.3E+00, \
     0.4E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     0.9E+00 ))

  x_vec = np.array ( ( \
    1,  2,  3, 10, 1, \
    2,  3, 10,  3, 3, \
    3,  5, 10,  3 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    p = 0.0
    x = 0
    cdf = 0.0
  else:
    p = p_vec[n_data]
    x = x_vec[n_data]
    cdf = cdf_vec[n_data]
    n_data = n_data + 1

  return n_data, x, p, cdf

def geometric_cdf_values_test ( ):

#*****************************************************************************80
#
## geometric_cdf_values_test() tests geometric_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'geometric_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  geometric_cdf_values stores values of the Geometric CDF.' )
  print ( '' )
  print ( '      X         P        geometric_cdf(X,P)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, p, cdf = geometric_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12g  %24.16g' % ( x, p, cdf ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'geometric_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def goodwin_values ( n_data ):

#*****************************************************************************80
#
## goodwin_values returns some values of the Goodwin and Staton function.
#
#  Discussion:
#
#    The function is defined by:
#
#      GOODWIN(x) = Integral ( 0 <= t < infinity ) exp ( -t^2 ) / ( t + x ) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#      special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
      0.59531540040441651584E+01, \
      0.45769601268624494109E+01, \
      0.32288921331902217638E+01, \
      0.19746110873568719362E+01, \
      0.96356046208697728563E+00, \
      0.60513365250334458174E+00, \
      0.51305506459532198016E+00, \
      0.44598602820946133091E+00, \
      0.37344458206879749357E+00, \
      0.35433592884953063055E+00, \
      0.33712156518881920994E+00, \
      0.29436170729362979176E+00, \
      0.25193499644897222840E+00, \
      0.22028778222123939276E+00, \
      0.19575258237698917033E+00, \
      0.17616303166670699424E+00, \
      0.16015469479664778673E+00, \
      0.14096116876193391066E+00, \
      0.13554987191049066274E+00, \
      0.11751605060085098084E+00 ))

  x_vec = np.array ( ( \
      0.0019531250E+00, \
      0.0078125000E+00, \
      0.0312500000E+00, \
      0.1250000000E+00, \
      0.5000000000E+00, \
      1.0000000000E+00, \
      1.2500000000E+00, \
      1.5000000000E+00, \
      1.8750000000E+00, \
      2.0000000000E+00, \
      2.1250000000E+00, \
      2.5000000000E+00, \
      3.0000000000E+00, \
      3.5000000000E+00, \
      4.0000000000E+00, \
      4.5000000000E+00, \
      5.0000000000E+00, \
      5.7500000000E+00, \
      6.0000000000E+00, \
      7.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def goodwin_values_test ( ):

#*****************************************************************************80
#
## goodwin_value_test() tests goodwin_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'goodwin_values:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  goodwin_values stores values of the Gudermannian function.' )
  print ( '' )
  print ( '      X              GOODWIN(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = goodwin_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'goodwin_values_test:' )
  print ( '  Normal end of execution.' )
  return

def gud_values ( n_data ):

#*****************************************************************************80
#
## gud_values returns some values of the Gudermannian function.
#
#  Discussion:
#
#    The Gudermannian function relates the hyperbolic and trigonomentric
#    functions.  For any argument X, there is a corresponding value
#    GD so that
#
#      SINH(X) = TAN(GD).
#
#    This value GD is called the Gudermannian of X and symbolized
#    GD(X).  The inverse Gudermannian function is given as input a value 
#    GD and computes the corresponding value X.
#
#    GD(X) = 2 * arctan ( exp ( X ) ) - PI / 2
#
#    In Mathematica, the function can be evaluated by:
#
#      2 * Atan[Exp[x]] - Pi/2
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#    Daniel Zwillinger, editor,
#    CRC Standard Mathematical Tables and Formulae,
#    30th Edition,
#    CRC Press, 1996.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 13

  fx_vec = np.array ( ( \
     -0.1301760336046015E+01, \
     -0.8657694832396586E+00, \
      0.0000000000000000E+00, \
      0.9983374879348662E-01, \
      0.1986798470079397E+00, \
      0.4803810791337294E+00, \
      0.8657694832396586E+00, \
      0.1131728345250509E+01, \
      0.1301760336046015E+01, \
      0.1406993568936154E+01, \
      0.1471304341117193E+01, \
      0.1510419907545700E+01, \
      0.1534169144334733E+01 ) )

  x_vec = np.array ( ( \
     -2.0E+00, \
     -1.0E+00, \
      0.0E+00, \
      0.1E+00, \
      0.2E+00, \
      0.5E+00, \
      1.0E+00, \
      1.5E+00, \
      2.0E+00, \
      2.5E+00, \
      3.0E+00, \
      3.5E+00, \
      4.0E+00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    fx = 0.0
  else:
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, x, fx

def gud_values_test ( ):

#*****************************************************************************80
#
## gud_value_test() tests gud_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'gud_values:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  gud_values stores values of the Gudermannian function.' )
  print ( '' )
  print ( '      X              GUD(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = gud_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'gud_values_test:' )
  print ( '  Normal end of execution.' )
  return

def hermite_function_values ( n_data ):

#*****************************************************************************80
#
## hermite_function_values: values of the Hermite function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Hf(n,x) = HermiteH[n,x] 
#        * Exp [ -1/2 * x^2] / Sqrt [ 2^n * n! * Sqrt[Pi] ]
#
#    The Hermite functions are orthonormal:
#
#      Integral ( -oo < x < +oo ) Hf(m,x) Hf(n,x) dx = delta ( m, n )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the polynomial.
#
#    real X, the point where the polynomial is evaluated.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 23

  f_vec = np.array ( ( \
    0.7511255444649425E+00,  0.0000000000000000E+00, -0.5311259660135985E+00, \
    0.0000000000000000E+00,  0.4599685791773266E+00,  0.0000000000000000E+00, \
    0.4555806720113325E+00,  0.6442883651134752E+00,  0.3221441825567376E+00, \
   -0.2630296236233334E+00, -0.4649750762925110E+00, -0.5881521185179581E-01, \
    0.3905052515434106E+00,  0.2631861423064045E+00, -0.2336911435996523E+00, \
   -0.3582973361472840E+00,  0.6146344487883041E-01,  0.3678312067984882E+00, \
    0.9131969309166278E-01,  0.4385750950032321E+00, -0.2624689527931006E-01, \
    0.5138426125477819E+00,  0.09355563118061758E+00 ))

  n_vec = np.array ( ( \
    0,  1,  2,  \
    3,  4,  5,  \
    0,  1,  2,  \
    3,  4,  5,  \
    6,  7,  8,  \
    9, 10, 11,  \
   12,  5,  5,  \
    5,  5  ))

  x_vec = np.array ( ( \
    0.0E+00, 0.0E+00, 0.0E+00, \
    0.0E+00, 0.0E+00, 0.0E+00, \
    1.0E+00, 1.0E+00, 1.0E+00, \
    1.0E+00, 1.0E+00, 1.0E+00, \
    1.0E+00, 1.0E+00, 1.0E+00, \
    1.0E+00, 1.0E+00, 1.0E+00, \
    1.0E+00, 0.5E+00, 2.0E+00, \
    3.0E+00, 4.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, f

def hermite_function_values_test ( ):

#*****************************************************************************80
#
## hermite_function_values_test() tests hermite_function_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'hermite_function_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  hermite_function_values stores values of the Hermite function.' )
  print ( '' )
  print ( '      N            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, f = hermite_function_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12g  %24.16g' % ( n, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'hermite_function_values_test:' )
  print ( '  Normal end of execution.' )
  return

def hermite_poly_phys_values ( n_data ):

#*****************************************************************************80
#
## hermite_poly_phys_values returns some values of the physicist's Hermite polynomial.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      HermiteH[n,x]
#
#  Differential equation:
#
#    Y'' - 2 X Y' + 2 N Y = 0
#
#  First terms:
#
#      1
#      2 X
#      4 X^2     -  2
#      8 X^3     - 12 X
#     16 X^4     - 48 X^2     + 12
#     32 X^5    - 160 X^3    + 120 X
#     64 X^6    - 480 X^4    + 720 X^2    - 120
#    128 X^7   - 1344 X^5   + 3360 X^3   - 1680 X
#    256 X^8   - 3584 X^6  + 13440 X^4  - 13440 X^2   + 1680
#    512 X^9   - 9216 X^7  + 48384 X^5  - 80640 X^3  + 30240 X
#   1024 X^10 - 23040 X^8 + 161280 X^6 - 403200 X^4 + 302400 X^2 - 30240
#
#  Recursion:
#
#    H(0,X) = 1,
#    H(1,X) = 2*X,
#    H(N,X) = 2*X * H(N-1,X) - 2*(N-1) * H(N-2,X)
#
#  Norm:
#
#    Integral ( -oo < X < +oo ) exp ( - X^2 ) * H(N,X)^2 dX
#    = sqrt ( PI ) * 2^N * N!
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    12 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the polynomial.
#
#    real X, the point where the polynomial is evaluated.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 18

  f_vec = np.array ( ( \
      0.1000000000000000E+01, \
      0.1000000000000000E+02, \
      0.9800000000000000E+02, \
      0.9400000000000000E+03, \
      0.8812000000000000E+04, \
      0.8060000000000000E+05, \
      0.7178800000000000E+06, \
      0.6211600000000000E+07, \
      0.5206568000000000E+08, \
      0.4212712000000000E+09, \
      0.3275529760000000E+10, \
      0.2432987360000000E+11, \
      0.1712370812800000E+12, \
      0.0000000000000000E+00, \
      0.4100000000000000E+02, \
     -0.8000000000000000E+01, \
      0.3816000000000000E+04, \
      0.3041200000000000E+07 ))

  n_vec = np.array ( ( \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10, 11, \
    12,  5,  5, \
     5,  5,  5 ))

  x_vec = np.array ( ( \
     5.0E+00, \
     5.0E+00, \
     5.0E+00, \
     5.0E+00, \
     5.0E+00, \
     5.0E+00, \
     5.0E+00, \
     5.0E+00, \
     5.0E+00, \
     5.0E+00, \
     5.0E+00, \
     5.0E+00, \
     5.0E+00, \
     0.0E+00, \
     0.5E+00, \
     1.0E+00, \
     3.0E+00, \
     1.0E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, f

def hermite_poly_phys_values_test ( ):

#*****************************************************************************80
#
## hermite_poly_phys_values_test() tests hermite_poly_phys_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    12 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'hermite_poly_phys_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  hermite_poly_phys_values stores values of the Hermite physicist polynomials.' )
  print ( '' )
  print ( '      N            X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, fx = hermite_poly_phys_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'hermite_poly_phys_values_test:' )
  print ( '  Normal end of execution.' )
  return

def hermite_poly_prob_values ( n_data ):

#*****************************************************************************80
#
## hermite_poly_prob_values: values of the probabilist's Hermite polynomial.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      He(n,x) = HermiteH[n,x/Sqrt[2]] / Sqrt [ 2^n ] 
#
#  First terms:
#
#   1
#   X
#   X^2  -  1
#   X^3  -  3 X
#   X^4  -  6 X^2 +   3
#   X^5  - 10 X^3 +  15 X
#   X^6  - 15 X^4 +  45 X^2 -   15
#   X^7  - 21 X^5 + 105 X^3 -  105 X
#   X^8  - 28 X^6 + 210 X^4 -  420 X^2 +  105
#   X^9  - 36 X^7 + 378 X^5 - 1260 X^3 +  945 X
#   X^10 - 45 X^8 + 630 X^6 - 3150 X^4 + 4725 X^2 - 945
#
#  Recursion:
#
#    He(0,X) = 1,
#    He(1,X) = X,
#    He(N,X) = X * He(N-1,X) - (N-1) * He(N-2,X)
#
#  Norm:
#
#    Integral ( -oo < X < +oo ) exp ( - 0.5 * X^2 ) * He(M,X) He(N,X) dX 
#    = sqrt ( 2 * pi ) * N! * delta ( N, M )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the polynomial.
#
#    real X, the point where the polynomial is evaluated.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 18

  f_vec = np.array ((\
    1.000000000000000E+00, \
    5.000000000000000E+00, \
    24.00000000000000E+00, \
    110.0000000000000E+00, \
    478.0000000000000E+00, \
    1950.000000000000E+00, \
    7360.000000000000E+00, \
    25100.00000000000E+00, \
    73980.00000000000E+00, \
    169100.0000000000E+00, \
    179680.0000000000E+00, \
   -792600.0000000000E+00, \
   -5939480.000000000E+00, \
    0.000000000000000E+00, \
    6.281250000000000E+00, \
    6.000000000000000E+00, \
    18.00000000000000E+00, \
    90150.00000000000E+00 ))

  n_vec = np.array ((\
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10, 11, \
    12,  5,  5, \
     5,  5,  5 ))

  x_vec = np.array ((\
    5.0E+00, \
    5.0E+00, \
    5.0E+00, \
    5.0E+00, \
    5.0E+00, \
    5.0E+00, \
    5.0E+00, \
    5.0E+00, \
    5.0E+00, \
    5.0E+00, \
    5.0E+00, \
    5.0E+00, \
    5.0E+00, \
    0.0E+00, \
    0.5E+00, \
    1.0E+00, \
    3.0E+00, \
    1.0E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, f

def hermite_poly_prob_values_test ( ):

#*****************************************************************************80
#
## hermite_poly_prob_values_test() tests hermite_poly_prob_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    12 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'hermite_poly_prob_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  hermite_poly_prob_values stores values of the Hermite probabilist polynomials.' )
  print ( '' )
  print ( '      N            X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, f = hermite_poly_prob_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'hermite_poly_prob_values_test:' )
  print ( '  Normal end of execution.' )
  return

def hyper_1f1_values ( n_data ):

#*****************************************************************************80
#
## hyper_1f1_values returns some values of the hypergeometric 1F1 function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      fx = Hypergeometric1F1 [ a, b, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Shanjie Zhang, Jianming Jin,
#    Computation of Special Functions,
#    Wiley, 1996,
#    ISBN: 0-471-11963-6,
#    LC: QA351.C45
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#    Daniel Zwillinger, editor,
#    CRC Standard Mathematical Tables and Formulae,
#    30th Edition,
#    CRC Press, 1996,
#    ISBN: 0-8493-2479-3,
#    LC: QA47.M315.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, B, X, the parameters.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 24

  a_vec = np.array ( (\
    -2.500, \
    -0.500, \
     0.500, \
     2.500, \
    -2.500, \
    -0.500, \
     0.500, \
     2.500, \
    -2.500, \
    -0.500, \
     0.500, \
     2.500, \
     0.825, \
     1.100, \
     1.650, \
     3.300, \
     0.825, \
     1.100, \
     1.650, \
     3.300, \
     0.825, \
     1.100, \
     1.650, \
     3.300 ))
  b_vec = np.array ( (\
     3.3, \
     1.1, \
     1.1, \
     3.3, \
     3.3, \
     1.1, \
     1.1, \
     3.3, \
     3.3, \
     1.1, \
     1.1, \
     3.3, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7 ))
  f_vec = np.array ( (\
     0.81879926689265186854, \
     0.88283984828032972070, \
     1.1245023764952626690, \
     1.2101049301639599598, \
     0.12723045536781567174, \
     0.12326016871544045107, \
     2.3297954665128293051, \
     3.3890020264468009733, \
    -0.18819510282516768874, \
    -1.0764203806547022727, \
     5.7521824680907968433, \
     9.9998567403304086593, \
     1.0317208964319891384, \
     1.0424867029249952040, \
     1.0643112000949092012, \
     1.1321844369742336326, \
     1.2328402688568452181, \
     1.3200654482027340732, \
     1.5104811522310825217, \
     2.2307520785940524365, \
     1.5197286298183137741, \
     1.7364938170250847619, \
     2.2492330307668135926, \
     4.6377737119178965298 ))
  x_vec = np.array ( (\
     0.25, \
     0.25, \
     0.25, \
     0.25, \
     1.55, \
     1.55, \
     1.55, \
     1.55, \
     2.85, \
     2.85, \
     2.85, \
     2.85, \
     0.25, \
     0.25, \
     0.25, \
     0.25, \
     1.55, \
     1.55, \
     1.55, \
     1.55, \
     2.85, \
     2.85, \
     2.85, \
     2.85 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    b = 0,0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, x, f

def hyper_1f1_values_test ( ):

#*****************************************************************************80
#
## hyper_1f1_values_test() tests hyper_1f1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'hyper_1f1_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  hyper_1f1_values stores values of the hypergeometric function 1F1' )
  print ( '' )
  print ( '     A     B        X               F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, x, f = hyper_1f1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %12g  %24.16g' % ( a, b, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'hyper_1f1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def hyper_2f1_values ( n_data ):

#*****************************************************************************80
#
## hyper_2f1_values returns some values of the hypergeometric 2F1 function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      fx = Hypergeometric2F1 [ a, b, c, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Shanjie Zhang, Jianming Jin,
#    Computation of Special Functions,
#    Wiley, 1996,
#    ISBN: 0-471-11963-6,
#    LC: QA351.C45
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#    Daniel Zwillinger, editor,
#    CRC Standard Mathematical Tables and Formulae,
#    30th Edition,
#    CRC Press, 1996,
#    ISBN: 0-8493-2479-3,
#    LC: QA47.M315.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, B, C, X, the parameters.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 24

  a_vec = np.array ( ( \
   -2.5, \
   -0.5, \
    0.5, \
    2.5, \
   -2.5, \
   -0.5, \
    0.5, \
    2.5, \
   -2.5, \
   -0.5, \
    0.5, \
    2.5, \
    3.3, \
    1.1, \
    1.1, \
    3.3, \
    3.3, \
    1.1, \
    1.1, \
    3.3, \
    3.3, \
    1.1, \
    1.1, \
    3.3 ))

  b_vec = np.array ( ( \
    3.3, \
    1.1, \
    1.1, \
    3.3, \
    3.3, \
    1.1, \
    1.1, \
    3.3, \
    3.3, \
    1.1, \
    1.1, \
    3.3, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7 ))

  c_vec = np.array ( ( \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
    6.7, \
   -5.5, \
   -0.5, \
    0.5, \
    4.5, \
   -5.5, \
   -0.5, \
    0.5, \
    4.5, \
   -5.5, \
   -0.5, \
    0.5, \
    4.5 ))

  f_vec = np.array ( ( \
    0.72356129348997784913, \
    0.97911109345277961340, \
    1.0216578140088564160, \
    1.4051563200112126405, \
    0.46961431639821611095, \
    0.95296194977446325454, \
    1.0512814213947987916, \
    2.3999062904777858999, \
    0.29106095928414718320, \
    0.92536967910373175753, \
    1.0865504094806997287, \
    5.7381565526189046578, \
    15090.669748704606754, \
   -104.31170067364349677, \
    21.175050707768812938, \
    4.1946915819031922850, \
    1.0170777974048815592E+10, \
   -24708.635322489155868, \
    1372.2304548384989560, \
    58.092728706394652211, \
    5.8682087615124176162E+18, \
   -4.4635010147295996680E+08, \
    5.3835057561295731310E+06, \
    20396.913776019659426 ))

  x_vec = np.array ( ( \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
    0.55, \
    0.55, \
    0.55, \
    0.55, \
    0.85, \
    0.85, \
    0.85, \
    0.85, \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
    0.55, \
    0.55, \
    0.55, \
    0.55, \
    0.85, \
    0.85, \
    0.85, \
    0.85 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0
    b = 0
    c = 0.0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    c = c_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, c, x, f

def hyper_2f1_values_test ( ):

#*****************************************************************************80
#
## hyper_2f1_values_test() tests hyper_2f1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'hyper_2f1_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  hyper_2f1_values stores values of the hypergeometric function 2F1' )
  print ( '' )
  print ( '     A     B        C           X               F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, c, x, f = hyper_2f1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4d  %4d  %12f  %12f  %24.16g' % ( a, b, c, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'hyper_2f1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def hypergeometric_cdf_values ( n_data ):

#*****************************************************************************80
#
## hypergeometric_cdf_values returns some values of the hypergeometric CDF.
#
#  Discussion:
#
#    CDF(X)(A,B) is the probability of at most X successes in A trials,
#    given that the probability of success on a single trial is B.
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`DiscreteDistributions`]
#      dist = HypergeometricDistribution [ sam, suc, pop ]
#      CDF [ dist, n ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#    Daniel Zwillinger,
#    CRC Standard Mathematical Tables and Formulae,
#    30th Edition, CRC Press, 1996, pages 651-652.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer SAM, integer SUC, integer POP, the sample size, 
#    success size, and population parameters of the function.
#
#    integer N, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 16

  f_vec = np.array ( (\
     0.6001858177500578E-01, \
     0.2615284665839845E+00, \
     0.6695237889132748E+00, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.5332595856827856E+00, \
     0.1819495964117640E+00, \
     0.4448047017527730E-01, \
     0.9999991751316731E+00, \
     0.9926860896560750E+00, \
     0.8410799901444538E+00, \
     0.3459800113391901E+00, \
     0.0000000000000000E+00, \
     0.2088888139634505E-02, \
     0.3876752992448843E+00, \
     0.9135215248834896E+00 ))

  n_vec = np.array ( (\
     7,  8,  9, 10, \
     6,  6,  6,  6, \
     6,  6,  6,  6, \
     0,  0,  0,  0 ))

  pop_vec = np.array ( (\
    100, 100, 100, 100, \
    100, 100, 100, 100, \
    100, 100, 100, 100, \
    90,  200, 1000, 10000 ))

  sam_vec = np.array ( (\
    10, 10, 10, 10, \
     6,  7,  8,  9, \
    10, 10, 10, 10, \
    10, 10, 10, 10 ))

  suc_vec = np.array ( (\
    90, 90, 90, 90, \
    90, 90, 90, 90, \
    10, 30, 50, 70, \
    90, 90, 90, 90 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    sam = 0
    suc = 0
    pop = 0
    n = 0
    f = 0.0
  else:
    sam = sam_vec[n_data]
    suc = suc_vec[n_data]
    pop = pop_vec[n_data]
    n = n_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, sam, suc, pop, n, f

def hypergeometric_cdf_values_test ( ):

#*****************************************************************************80
#
## hypergeometric_cdf_value_test() tests hypergeometric_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'hypergeometric_cdf_values:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  hypergeometric_cdf_values stores values of the hypergeometric CDF.' )
  print ( '' )
  print ( '    Sam    Suc    Pop    X     F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, sam, suc, pop, n, f = hypergeometric_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %6d  %6d  %6d  %24.16f' % ( sam, suc, pop, n, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'hypergeometric_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def hypergeometric_pdf_values ( n_data ):

#*****************************************************************************80
#
## hypergeometric_pdf_values returns some values of the hypergeometric PDF.
#
#  Discussion:
#
#    PDF(X)(A,B) is the probability of X successes in A trials,
#    given that the probability of success on a single trial is B.
#
#    In Mathematica, the function can be evaluated by:
#
#      dist = HypergeometricDistribution [ sam, suc, pop ]
#      PDF [ dist, n ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#    Daniel Zwillinger,
#    CRC Standard Mathematical Tables and Formulae,
#    30th Edition, CRC Press, 1996, pages 651-652.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer SAM, integer SUC, integer POP, the sample size, 
#    success size, and population parameters of the function.
#
#    integer N, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 16

  f_vec = np.array ( (\
    0.05179370533242827E+00, \
    0.2015098848089788E+00, \
    0.4079953223292903E+00, \
    0.3304762110867252E+00, \
    0.5223047493549780E+00, \
    0.3889503452643453E+00, \
    0.1505614239732950E+00, \
    0.03927689321042477E+00, \
    0.00003099828465518108E+00, \
    0.03145116093938197E+00, \
    0.2114132170316862E+00, \
    0.2075776621999210E+00, \
    0.0000000000000000E+00, \
    0.002088888139634505E+00, \
    0.3876752992448843E+00, \
    0.9135215248834896E+00 ))

  n_vec = np.array ( (\
     7,  8,  9, 10, \
     6,  6,  6,  6, \
     6,  6,  6,  6, \
     0,  0,  0,  0 ))

  pop_vec = np.array ( (\
    100, 100, 100, 100, \
    100, 100, 100, 100, \
    100, 100, 100, 100, \
    90,  200, 1000, 10000 ))

  sam_vec = np.array ( (\
    10, 10, 10, 10, \
     6,  7,  8,  9, \
    10, 10, 10, 10, \
    10, 10, 10, 10 ))

  suc_vec = np.array ( (\
    90, 90, 90, 90, \
    90, 90, 90, 90, \
    10, 30, 50, 70, \
    90, 90, 90, 90 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    sam = 0
    suc = 0
    pop = 0
    n = 0
    f = 0.0
  else:
    sam = sam_vec[n_data]
    suc = suc_vec[n_data]
    pop = pop_vec[n_data]
    n = n_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, sam, suc, pop, n, f

def hypergeometric_pdf_values_test ( ):

#*****************************************************************************80
#
## hypergeometric_pdf_value_test() tests hypergeometric_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'hypergeometric_pdf_values:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  hypergeometric_pdf_values stores values of the hypergeometric PDF.' )
  print ( '' )
  print ( '     Sam     Suc     Pop       X          F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, sam, suc, pop, n, f = hypergeometric_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %6d  %6d  %6d  %24.16f' % ( sam, suc, pop, n, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'hypergeometric_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def hypergeometric_u_values ( n_data ):

#*****************************************************************************80
#
## hypergeometric_u_values: some values of the hypergeometric function U(a,b,x).
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      fx = HypergeometricU [ a, b, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license. 
#
#  Modified:
#
#    15 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#    Daniel Zwillinger, editor,
#    CRC Standard Mathematical Tables and Formulae,
#    30th Edition,
#    CRC Press, 1996,
#    ISBN: 0-8493-2479-3,
#    LC: QA47.M315.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, B, X, the parameters.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 24

  a_vec = np.array ( (\
    -2.500, \
    -0.500, \
     0.500, \
     2.500, \
    -2.500, \
    -0.500, \
     0.500, \
     2.500, \
    -2.500, \
    -0.500, \
     0.500, \
     2.500, \
     0.825, \
     1.100, \
     1.650, \
     3.300, \
     0.825, \
     1.100, \
     1.650, \
     3.300, \
     0.825, \
     1.100, \
     1.650, \
     3.300 ))

  b_vec = np.array ( (\
     3.3, \
     1.1, \
     1.1, \
     3.3, \
     3.3, \
     1.1, \
     1.1, \
     3.3, \
     3.3, \
     1.1, \
     1.1, \
     3.3, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7, \
     6.7 ))

  f_vec = np.array ( (\
         -68.693628728078601389E+00, \
          -0.0029710551374761070801E+00, \
           1.5008631742177797301E+00, \
          20.614688244200596134E+00, \
           7.4563815469305551938E+00, \
           1.0155793767749293733E+00, \
           0.73446538936622668912E+00, \
           0.28046404941879399225E+00, \
           3.4508153741446547607E+00, \
           1.5156637368753063495E+00, \
           0.56042118587934993510E+00, \
           0.064897147735134223341E+00, \
      223432.02356977463356E+00, \
      263079.25980740811495E+00, \
      269802.90319351274132E+00, \
       82809.311335606553425E+00, \
          26.465684783131844524E+00, \
          28.093506172516056560E+00, \
          23.889164624518872504E+00, \
           4.5338847857070388229E+00, \
           3.0224469362694842535E+00, \
           2.8040650913713359934E+00, \
           1.9262578111480172682E+00, \
           0.23020518115860909098E+00 ))

  x_vec = np.array ( (\
     0.25, \
     0.25, \
     0.25, \
     0.25, \
     1.55, \
     1.55, \
     1.55, \
     1.55, \
     2.85, \
     2.85, \
     2.85, \
     2.85, \
     0.25, \
     0.25, \
     0.25, \
     0.25, \
     1.55, \
     1.55, \
     1.55, \
     1.55, \
     2.85, \
     2.85, \
     2.85, \
     2.85 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    b = 0.0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, x, f

def hypergeometric_u_values_test ( ):

#*****************************************************************************80
#
## hypergeometric_u_values_test() tests hypergeometric_u_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'hypergeometric_u_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  hypergeometric_u_values stores values of the Hypergeometric U function.' )
  print ( '' )
  print ( '        A             B             X              F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, x, f = hypergeometric_u_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16g' % ( a, b, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'hypergeometric_u_values_test:' )
  print ( '  Normal end of execution.' )
  return

def i0ml0_values ( n_data ):

#*****************************************************************************80
#
## i0ml0_values returns some values of the i0ml0 function.
#
#  Discussion:
#
#    The function is defined by:
#
#      i0ml0(x) = I0(x) - L0(x)
#
#    I0(x) is the modified Bessel function of the first kind of order 0,
#    L0(x) is the modified Struve function of order 0.
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#      special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( (\
     0.99875755515461749793E+00, \
     0.99011358230706643807E+00, \
     0.92419435310023947018E+00, \
     0.73624267134714273902E+00, \
     0.55582269181411744686E+00, \
     0.34215154434462160628E+00, \
     0.17087174888774706539E+00, \
     0.81081008709219208918E-01, \
     0.53449421441089580702E-01, \
     0.39950321008923244846E-01, \
     0.39330637437584921392E-01, \
     0.37582274342808670750E-01, \
     0.31912486554480390343E-01, \
     0.25506146883504738403E-01, \
     0.21244480317825292412E-01, \
     0.15925498348551684335E-01, \
     0.12737506927242585015E-01, \
     0.84897750814784916847E-02, \
     0.63668349178454469153E-02, \
     0.50932843163122551114E-02 ))

  x_vec = np.array ( (\
       0.0019531250E+00, \
       0.0156250000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       2.0000000000E+00, \
       4.0000000000E+00, \
       8.0000000000E+00, \
      12.0000000000E+00, \
      16.0000000000E+00, \
      16.2500000000E+00, \
      17.0000000000E+00, \
      20.0000000000E+00, \
      25.0000000000E+00, \
      30.0000000000E+00, \
      40.0000000000E+00, \
      50.0000000000E+00, \
      75.0000000000E+00, \
     100.0000000000E+00, \
     125.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def i0ml0_values_test ( ):

#*****************************************************************************80
#
## i0ml0_values_test() tests i0ml0_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'i0ml0_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  i0ml0_values stores values of the i0ml0 function.' )
  print ( '' )
  print ( '      X         i0ml0(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = i0ml0_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'i0ml0_values_test:' )
  print ( '  Normal end of execution.' )
  return

def i1ml1_values ( n_data ):

#*****************************************************************************80
#
## i1ml1_values returns some values of the i1ml1 function.
#
#  Discussion:
#
#    The function is defined by:
#
#      i1ml1(x) = I1(x) - L1(x)
#
#    I1(x) is the modified Bessel function of the first kind of order 1, 
#    L1(x) is the modified Struve function of order 1.
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#      special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( (\
     0.97575346155386267134E-03, \
     0.77609293280609272733E-02, \
     0.59302966404545373770E-01, \
     0.20395212276737365307E+00, \
     0.33839472293667639038E+00, \
     0.48787706726961324579E+00, \
     0.59018734196576517506E+00, \
     0.62604539530312149476E+00, \
     0.63209315274909764698E+00, \
     0.63410179313235359215E+00, \
     0.63417966797578128188E+00, \
     0.63439268632392089434E+00, \
     0.63501579073257770690E+00, \
     0.63559616677359459337E+00, \
     0.63591001826697110312E+00, \
     0.63622113181751073643E+00, \
     0.63636481702133606597E+00, \
     0.63650653499619902120E+00, \
     0.63655609126300261851E+00, \
     0.63657902087183929223E+00 ))

  x_vec = np.array ( (\
       0.0019531250E+00, \
       0.0156250000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       2.0000000000E+00, \
       4.0000000000E+00, \
       8.0000000000E+00, \
      12.0000000000E+00, \
      16.0000000000E+00, \
      16.2500000000E+00, \
      17.0000000000E+00, \
      20.0000000000E+00, \
      25.0000000000E+00, \
      30.0000000000E+00, \
      40.0000000000E+00, \
      50.0000000000E+00, \
      75.0000000000E+00, \
     100.0000000000E+00, \
     125.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def i1ml1_values_test ( ):

#*****************************************************************************80
#
## i1ml1_values_test() tests i1ml1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'i1ml1_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  i1ml1_values stores values of the i1ml1 function.' )
  print ( '' )
  print ( '      X         i1ml1(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = i1ml1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'i1ml1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def i4_factorial2_values ( n_data ):

#*****************************************************************************80
#
## i4_factorial2_values returns values of the double factorial function.
#
#  Formula:
#
#    FACTORIAL2( N ) = Product ( N * (N-2) * (N-4) * \ * 2 )  (N even)
#                    = Product ( N * (N-2) * (N-4) * \ * 1 )  (N odd)
#
#    In Mathematica, the function can be evaluated by:
#
#      n!!
#
#  Example:
#
#     N    N!!
#
#     0     1
#     1     1
#     2     2
#     3     3
#     4     8
#     5    15
#     6    48
#     7   105
#     8   384
#     9   945
#    10  3840
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#    Daniel Zwillinger,
#    CRC Standard Mathematical Tables and Formulae,
#    30th Edition,
#    CRC Press, 1996, page 16.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the argument of the function.
#
#    integer FN, the value of the function.
# 
  import numpy as np

  n_max = 16

  fn_vec = np.array ( ( 
          1, \
          1, \
          2, \
          3, \
          8, \
         15, \
         48, \
        105, \
        384, \
        945, \
       3840, \
      10395, \
      46080, \
     135135, \
     645120, \
    2027025 ) )

  n_vec = np.array ( ( 
    0, \
     1,  2,  3,  4,  5, \
     6,  7,  8,  9, 10, \
    11, 12, 13, 14, 15 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    fn = 0
  else:
    n = n_vec[n_data]
    fn = fn_vec[n_data]
    n_data = n_data + 1

  return n_data, n, fn

def i4_factorial2_values_test ( ):

#*****************************************************************************80
#
## i4_factorial2_values_test() tests FACTORIAL2_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'i4_factorial2_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  i4_factorial2_values returns values of the double factorial function.' )
  print ( '' )
  print ( '     N        N!!' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, fn = i4_factorial2_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '%6d  %10d' % ( n, fn ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'i4_factorial2_values_test:' )
  print ( '  Normal end of execution.' )
  return

def i4_factorial_values ( n_data ):

#*****************************************************************************80
#
## i4_factorial_values returns values of the factorial function.
#
#  Discussion:
#
#    0! = 1
#    I! = Product ( 1 <= J <= I ) I
#
#    In Mathematica, the function can be evaluated by:
#
#      n!
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the argument of the function.
#
#    integer FN, the value of the function.
#
  import numpy as np

  n_max = 13

  fn_vec = np.array ( [ \
            1, \
            1, \
            2, \
            6, \
           24, \
          120, \
          720, \
         5040, \
        40320, \
       362880, \
      3628800, \
     39916800, \
    479001600 ] )
  n_vec = np.array ( [ \
     0,  1,  2,  3, \
     4,  5,  6,  7, \
     8,  9, 10, 11, \
    12 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    fn = 0
  else:
    n = n_vec[n_data]
    fn = fn_vec[n_data]
    n_data = n_data + 1

  return n_data, n, fn

def i4_factorial_values_test ( ):

#*****************************************************************************80
#
## i4_factorial_values_test() tests i4_factorial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'i4_factorial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  i4_factorial_values returns values of the integer factorial function.' )
  print ( '' )
  print ( '          N          i4_factorial(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, fn = i4_factorial_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %8d  %12d' % ( n, fn ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'i4_factorial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def i4_fall_values ( n_data ):

#*****************************************************************************80
#
## i4_fall_values returns values of the integer falling factorial function.
#
#  Discussion:
#
#    The definition of the falling factorial function is
#
#      (m)_n = (m)! / (m-n)!
#            = ( m ) * ( m - 1 ) * ( m - 2 ) ... * ( m - n + 1 )
#            = Gamma ( m + 1 ) / Gamma ( m - n + 1 )
#
#    We assume 0 <= N <= M.
#
#    In Mathematica, the function can be evaluated by:
#
#      FactorialPower[m,n]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer M, N, the arguments of the function.
#
#    integer FMN, the value of the function.
#
  import numpy as np

  n_max = 15

  fmn_vec = np.array ( [ 
     1, 5, 20, 60, 120, \
     120, 0, 1, 10, 4000, \
     90, 4896, 24, 912576, 0 ] )
  m_vec = np.array ( [ 
    5, 5, 5, 5, 5, \
    5, 5, 50, 10, 4000, \
    10, 18, 4, 98, 1 ] )
  n_vec = np.array ( [ 
    0, 1, 2, 3, 4, \
    5, 6, 0, 1, 1, \
    2, 3, 4, 3, 7 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    m = 0
    n = 0
    fmn = 0
  else:
    m = m_vec[n_data]
    n = n_vec[n_data]
    fmn = fmn_vec[n_data]
    n_data = n_data + 1

  return n_data, m, n, fmn

def i4_fall_values_test ( ):

#*****************************************************************************80
#
## i4_fall_values_test() tests i4_fall_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'i4_fall_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  i4_fall_values returns values of the integer falling factorial.' )
  print ( '' )
  print ( '          M         N          i4_fall(M,N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, m, n, fmn = i4_fall_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %8d  %8d  %8d' % ( m, n, fmn ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'i4_fall_values_test:' )
  print ( '  Normal end of execution.' )
  return

def i4_rise_values ( n_data ):

#*****************************************************************************80
#
## i4_rise_values returns values of the integer rising factorial function.
#
#  Discussion:
#
#    The integer rising factorial function is sometimes symbolized by (m)_n.
#
#    The definition is
#
#      (m)_n = (m-1+n)! / (m-1)!
#            = ( m ) * ( m + 1 ) * ( m + 2 ) ... * ( m - 1 + n )
#            = Gamma ( m + n ) / Gamma ( m )
#
#    We assume 0 <= N <= M.
#
#    In Mathematica, the function can be evaluated by:
#
#      Pochhammer[m,n]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer M, N, the arguments of the function.
#
#    integer FMN, the value of the function.
#
  import numpy as np

  n_max = 15

  fmn_vec = np.array ( [ 
     1, 5, 30, 210, 1680, \
     15120, 151200, 1, 10, 4000, \
     110, 6840, 840, 970200, 5040 ] )
  m_vec = np.array ( [ 
    5, 5, 5, 5, 5, \
    5, 5, 50, 10, 4000, \
    10, 18, 4, 98, 1 ] )
  n_vec = np.array ( [ 
     0, 1, 2, 3, 4, \
    5, 6, 0, 1, 1, \
    2, 3, 4, 3, 7 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    m = 0
    n = 0
    fmn = 0
  else:
    m = m_vec[n_data]
    n = n_vec[n_data]
    fmn = fmn_vec[n_data]
    n_data = n_data + 1

  return n_data, m, n, fmn

def i4_rise_values_test ( ):

#*****************************************************************************80
#
## i4_rise_values_test() tests i4_rise_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'i4_rise_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  i4_rise_values returns values of the integer rising factorial.' )
  print ( '' )
  print ( '          M         N          i4_rise(M,N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, m, n, fmn = i4_rise_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %8d  %8d  %8d' % ( m, n, fmn ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'i4_rise_values_test:' )
  print ( '  Normal end of execution.' )
  return

def int_values ( n_data ):

#*****************************************************************************80
#
## int_values returns some values of the "integer part" function.
#
#  Discussion:
#
#    INT(X) = returns the integer part of a real number.
#
#    The result is returned as a real number.
#
#    The result is computed by rounding the absolute value of the
#    input towards 0, and then restoring the sign.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 25;

  f_vec = np.array ( ( \
     -2.00E+00, \
     -1.00E+00, \
     -1.00E+00, \
     -1.00E+00, \
     -1.00E+00, \
     -1.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      1.00E+00, \
      1.00E+00, \
      1.00E+00, \
      1.00E+00, \
      1.00E+00, \
      2.00E+00 ))

  x_vec = np.array ( ( \
     -2.01E+00, \
     -1.99E+00, \
     -1.50E+00, \
     -1.10E+00, \
     -1.01E+00, \
     -1.00E+00, \
     -0.99E+00, \
     -0.90E+00, \
     -0.51E+00, \
     -0.50E+00, \
     -0.49E+00, \
     -0.01E+00, \
      0.00E+00, \
      0.01E+00, \
      0.49E+00, \
      0.50E+00, \
      0.51E+00, \
      0.90E+00, \
      0.99E+00, \
      1.00E+00, \
      1.01E+00, \
      1.10E+00, \
      1.50E+00, \
      1.99E+00, \
      2.01E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def int_values_test ( ):

#*****************************************************************************80
#
## int_values_test() tests int_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'int_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  int_values stores values of the integer part function.' )
  print ( '' )
  print ( '      X         INT(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = int_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'int_values_test:' )
  print ( '  Normal end of execution.' )
  return

def inverse_chi_square_pdf_values ( n_data ):

#*****************************************************************************80
#
## inverse_chi_square_pdf_values returns values of the inverse chi square PDF.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 August 2015
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real DF, the degrees of freedom.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 21

  df_vec = np.array ( [ \
     1.0, \
     2.0, \
     1.0, \
     2.0, \
     1.0, \
     2.0, \
     3.0, \
     4.0, \
     1.0, \
     2.0, \
     3.0, \
     4.0, \
     5.0, \
     3.0, \
     3.0, \
     3.0, \
     3.0, \
     3.0, \
    10.0, \
    10.0, \
    10.0 ] )
  fx_vec = np.array ( [ \
    0.08500366602520342, \
    0.3368973499542734, \
    0.3661245640481622, \
    1.026062482798735, \
    0.4518059816704532, \
    0.8953274901880941, \
    1.129514954176133, \
    1.119159362735118, \
    0.2419707245191433, \
    0.3032653298563167, \
    0.2419707245191433, \
    0.1516326649281584, \
    0.08065690817304778, \
    0.05492391118346530, \
    0.02166329508030457, \
    0.01100204146138436, \
    0.006457369034861447, \
    0.004162370481945731, \
    0.0007897534631674914, \
    0.00001584474249412852, \
    1.511920090468204E-06 ] )
  x_vec = np.array ( [ \
    0.10, \
    0.10, \
    0.20, \
    0.20, \
    0.40, \
    0.40, \
    0.40, \
    0.40, \
    1.00, \
    1.00, \
    1.00, \
    1.00, \
    1.00, \
    2.00, \
    3.00, \
    4.00, \
    5.00, \
    6.00, \
    1.00, \
    2.00, \
    3.00 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    df = 0.0
    x = 0.0
    fx = 0.0
  else:
    df = df_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1
 
  return n_data, df, x, fx

def inverse_chi_square_pdf_values_test ( ):

#*****************************************************************************80
#
## inverse_chi_square_pdf_values_test() tests inverse_chi_square_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 August 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'inverse_chi_square_pdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  inverse_chi_square_pdf_values returns values of' )
  print ( '  the inverse Chi Square Probability Density Function.' )
  print ( '' )
  print ( '        DF         X         PDF' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, df, x, fx = inverse_chi_square_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %8g  %8g  %24.16g' % ( df, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'inverse_chi_square_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def inverse_gamma_pdf_values ( n_data ):

#*****************************************************************************80
#
## inverse_gamma_pdf_values returns values of the inverse gamma PDF.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 August 2015
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real ALPHA, BETA, the parameters.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 12

  alpha_vec = np.array ( [ \
    1.00, \
    1.00, \
    1.00, \
    1.00, \
    1.00, \
    1.00, \
    1.00, \
    1.00, \
    2.00, \
    3.00, \
    4.00, \
    5.00 ] )
  beta_vec = np.array ( [ \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    2.00, \
    3.00, \
    4.00, \
    5.00, \
    2.00, \
    2.00, \
    2.00, \
    2.00 ] )
  fx_vec = np.array ( [ \
    0.3032653298563167, \
    0.09735009788392561, \
    0.04702676249392300, \
    0.02757802820576861, \
    0.1839397205857212, \
    0.1673476201113224, \
    0.1353352832366127, \
    0.1026062482798735, \
    0.07606179541223586, \
    0.02535393180407862, \
    0.005634207067573026, \
    0.0009390345112621711 ] )
  x_vec = np.array ( [ \
    1.00, \
    2.00, \
    3.00, \
    4.00, \
    2.00, \
    2.00, \
    2.00, \
    2.00, \
    3.00, \
    3.00, \
    3.00, \
    3.00 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    alpha = 0.0
    beta = 0.0
    x = 0.0
    fx = 0.0
  else:
    alpha = alpha_vec[n_data]
    beta = beta_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, alpha, beta, x, fx

def inverse_gamma_pdf_values_test ( ):

#*****************************************************************************80
#
## inverse_gamma_pdf_values_test() tests inverse_gamma_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 August 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'inverse_gamma_pdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  inverse_gamma_pdf_values returns values of' )
  print ( '  the inverse gamma Probability Density Function.' )
  print ( '' )
  print ( '        ALPHA     BETA       X         PDF' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, alpha, beta, x, fx = inverse_gamma_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %8g  %8g  %8g  %24.16g' % ( alpha, beta, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'inverse_gamma_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def jacobi_cn_values ( n_data ):

#*****************************************************************************80
#
## jacobi_cn_values returns some values of the Jacobi elliptic function CN(U,M).
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      JacobiCN[ u, m ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 November 2020
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real U, the argument of the function.
#
#    real A, K, M, the parameters of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  m_vec = np.array ( (\
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00 ))

  f_vec = np.array ( (\
      0.9950041652780258E+00, \
      0.9800665778412416E+00, \
      0.8775825618903727E+00, \
      0.5403023058681397E+00, \
     -0.4161468365471424E+00, \
      0.9950124626090582E+00, \
      0.9801976276784098E+00, \
      0.8822663948904403E+00, \
      0.5959765676721407E+00, \
     -0.1031836155277618E+00, \
      0.9950207489532265E+00, \
      0.9803279976447253E+00, \
      0.8868188839700739E+00, \
      0.6480542736638854E+00, \
      0.2658022288340797E+00, \
      0.3661899347368653E-01, \
      0.9803279976447253E+00, \
      0.8868188839700739E+00, \
      0.6480542736638854E+00, \
      0.2658022288340797E+00 ))

  u_vec = np.array ( (\
      0.1E+00, \
      0.2E+00, \
      0.5E+00, \
      1.0E+00, \
      2.0E+00, \
      0.1E+00, \
      0.2E+00, \
      0.5E+00, \
      1.0E+00, \
      2.0E+00, \
      0.1E+00, \
      0.2E+00, \
      0.5E+00, \
      1.0E+00, \
      2.0E+00, \
      4.0E+00, \
     -0.2E+00, \
     -0.5E+00, \
     -1.0E+00, \
     -2.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    m = 0.0
    k = 0.0
    a = 0.0
    u = 0.0
    f = 0.0
  else:
    m = m_vec[n_data]
    k = np.sqrt ( m )
    a = np.arcsin ( k )
    u = u_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, u, a, k, m, f

def jacobi_cn_values_test ( ):

#*****************************************************************************80
#
## jacobi_cn_values_test() tests jacobi_cn_values().
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 November 2020
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'jacobi_cn_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  jacobi_cn_values() stores values of the Jacobi CN function.' )
  print ( '' )
  print ( '      U         M        jacobi_CN(U,M)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, u, a, k, m, f = jacobi_cn_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( u, m, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'jacobi_cn_values_test:' )
  print ( '  Normal end of execution.' )
  return

def jacobi_dn_values ( n_data ):

#*****************************************************************************80
#
## jacobi_dn_values returns some values of the Jacobi elliptic function DN(U,M).
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      JacobiDN[ x, a ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 November 2020
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real U, the argument of the function.
#
#    real A, K, M, the parameters of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  m_vec = np.array ( ( \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00 ))

  f_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.9975093485144243E+00, \
     0.9901483195224800E+00, \
     0.9429724257773857E+00, \
     0.8231610016315963E+00, \
     0.7108610477840873E+00, \
     0.9950207489532265E+00, \
     0.9803279976447253E+00, \
     0.8868188839700739E+00, \
     0.6480542736638854E+00, \
     0.2658022288340797E+00, \
     0.3661899347368653E-01, \
     0.9803279976447253E+00, \
     0.8868188839700739E+00, \
     0.6480542736638854E+00, \
     0.2658022288340797E+00  ))

  u_vec = np.array ( ( \
      0.1E+00, \
      0.2E+00, \
      0.5E+00, \
      1.0E+00, \
      2.0E+00, \
      0.1E+00, \
      0.2E+00, \
      0.5E+00, \
      1.0E+00, \
      2.0E+00, \
      0.1E+00, \
      0.2E+00, \
      0.5E+00, \
      1.0E+00, \
      2.0E+00, \
      4.0E+00, \
     -0.2E+00, \
     -0.5E+00, \
     -1.0E+00, \
     -2.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    k = 0.0
    m = 0.0
    u = 0.0
    f = 0.0
  else:
    m = m_vec[n_data]
    k = np.sqrt ( m )
    a = np.arcsin ( k )
    u = u_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, u, a, k, m, f

def jacobi_dn_values_test ( ):

#*****************************************************************************80
#
## jacobi_dn_values_test() tests jacobi_dn_values().
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 November 2020
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'jacobi_dn_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  jacobi_dn_values() stores values of the Jacobi DN function.' )
  print ( '' )
  print ( '      U         M        jacobi_DN(U,M)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, u, a, k, m, f = jacobi_dn_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( u, m, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'jacobi_dn_values_test:' )
  print ( '  Normal end of execution.' )
  return

def jacobi_poly_values ( n_data ):

#*****************************************************************************80
#
## jacobi_poly_values returns some values of the Jacobi polynomial.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      JacobiP[ n, a, b, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the degree of the polynomial.
#
#    real A, B, parameters of the function.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 26

  a_vec = np.array ( (\
     0.0, 0.0, 0.0, 0.0, \
     0.0, 0.0, 1.0, 2.0, \
     3.0, 4.0, 5.0, 0.0, \
     0.0, 0.0, 0.0, 0.0, \
     0.0, 0.0, 0.0, 0.0, \
     0.0, 0.0, 0.0, 0.0, \
     0.0, 0.0 ))

  b_vec = np.array ( (\
    1.0, 1.0, 1.0, 1.0, \
    1.0, 1.0, 1.0, 1.0, \
    1.0, 1.0, 1.0, 2.0, \
    3.0, 4.0, 5.0, 1.0, \
    1.0, 1.0, 1.0, 1.0, \
    1.0, 1.0, 1.0, 1.0, \
    1.0, 1.0 ))

  f_vec = np.array ( (\
      1.000000000000000, \
      0.2500000000000000, \
     -0.3750000000000000, \
     -0.4843750000000000, \
     -0.1328125000000000, \
      0.2753906250000000, \
     -0.1640625000000000, \
     -1.174804687500000, \
     -2.361328125000000, \
     -2.616210937500000, \
      0.1171875000000000, \
      0.4218750000000000, \
      0.5048828125000000, \
      0.5097656250000000, \
      0.4306640625000000, \
     -6.000000000000000, \
      0.03862000000000000, \
      0.8118400000000000, \
      0.03666000000000000, \
     -0.4851200000000000, \
     -0.3125000000000000, \
      0.1891200000000000, \
      0.4023400000000000, \
      0.01216000000000000, \
     -0.4396200000000000, \
      1.000000000000000 ))

  n_vec = np.array ( (\
     0, 1, 2, 3, \
     4, 5, 5, 5, \
     5, 5, 5, 5, \
     5, 5, 5, 5, \
     5, 5, 5, 5, \
     5, 5, 5, 5, \
     5, 5 ))

  x_vec = np.array ( (\
      0.5, \
      0.5, \
      0.5, \
      0.5, \
      0.5, \
      0.5, \
      0.5, \
      0.5, \
      0.5, \
      0.5, \
      0.5, \
      0.5, \
      0.5, \
      0.5, \
      0.5, \
     -1.0, \
     -0.8, \
     -0.6, \
     -0.4, \
     -0.2, \
      0.0, \
      0.2, \
      0.4, \
      0.6, \
      0.8, \
      1.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    a = 0.0
    b = 0.0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    a = a_vec[n_data]
    b = b_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, a, b, x, f

def jacobi_poly_values_test ( ):

#*****************************************************************************80
#
## jacobi_poly_values_test() tests jacobi_poly_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'jacobi_poly_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  jacobi_poly_values stores values of the Jacobi polynomials.' )
  print ( '' )
  print ( '       N        A             B             X              F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, a, b, x, f = jacobi_poly_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %12f  %12f  %24.16g' % ( n, a, b, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'jacobi_poly_values_test:' )
  print ( '  Normal end of execution.' )
  return

def jacobi_sn_values ( n_data ):

#*****************************************************************************80
#
## jacobi_sn_values returns some values of the Jacobi elliptic function SN(U,M).
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      JacobiSN[ u, m ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 November 2020
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real U, the argument of the function.
#
#    real A, K, M, the parameters of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  m_vec = np.array ( ( \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00 ))

  f_vec = np.array ( ( \
      0.9983341664682815E-01, \
      0.1986693307950612E+00, \
      0.4794255386042030E+00, \
      0.8414709848078965E+00, \
      0.9092974268256817E+00, \
      0.9975068547462484E-01, \
      0.1980217429819704E+00, \
      0.4707504736556573E+00, \
      0.8030018248956439E+00, \
      0.9946623253580177E+00, \
      0.9966799462495582E-01, \
      0.1973753202249040E+00, \
      0.4621171572600098E+00, \
      0.7615941559557649E+00, \
      0.9640275800758169E+00, \
      0.9993292997390670E+00, \
     -0.1973753202249040E+00, \
     -0.4621171572600098E+00, \
     -0.7615941559557649E+00, \
     -0.9640275800758169E+00 ))

  u_vec = np.array ( ( \
      0.1E+00, \
      0.2E+00, \
      0.5E+00, \
      1.0E+00, \
      2.0E+00, \
      0.1E+00, \
      0.2E+00, \
      0.5E+00, \
      1.0E+00, \
      2.0E+00, \
      0.1E+00, \
      0.2E+00, \
      0.5E+00, \
      1.0E+00, \
      2.0E+00, \
      4.0E+00, \
     -0.2E+00, \
     -0.5E+00, \
     -1.0E+00, \
     -2.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    k = 0.0
    m = 0.0
    u = 0.0
    f = 0.0
  else:
    m = m_vec[n_data]
    k = np.sqrt ( m )
    a = np.arcsin ( k )
    u = u_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, u, a, k, m, f

def jacobi_sn_values_test ( ):

#*****************************************************************************80
#
## jacobi_sn_values_test() tests jacobi_sn_values().
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 November 2020
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'jacobi_sn_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  jacobi_sn_values() stores values of the Jacobi SN function.' )
  print ( '' )
  print ( '      U         M        jacobi_SN(U,M)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, u, a, k, m, f = jacobi_sn_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( u, m, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'jacobi_sn_values_test:' )
  print ( '  Normal end of execution.' )
  return

def jed_ce_values ( n_data ):

#*****************************************************************************80
#
## jed_ce_values returns the Common Era dates for Julian Ephemeris Dates.
#
#  Discussion:
#
#    The JED (Julian Ephemeris Date) is a calendrical system which counts days,
#    starting from noon on 1 January 4713 BCE.
#
#    The CE or Common Era is the day, month and year under the
#    hybrid Julian/Gregorian Calendar, with a transition from Julian
#    to Gregorian.  The day after 04 October 1582 was 15 October 1582.
#
#    The year before 1 AD or CE is 1 BC or BCE.  In this data set,
#    years BC/BCE are indicated by a negative year value.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Edward Reingold and Nachum Dershowitz,
#    Calendrical Calculations: The Millennium Edition,
#    Cambridge University Press, 2001,
#    ISBN: 0 521 77752 6
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real JED, the Julian Ephemeris Date.
#
#    integer Y, M, D, the Common Era date.
#
#    real F, the fractional part of the day.
#
  import numpy as np

  n_max = 51

  d_vec = np.array ( ( \
    1, \
    2, \
    26, \
    8, \
    6, \
    18, \
    8, \
    9, \
    1, \
    26, \
    26, \
    1, \
    1, \
    29, \
    31, \
    1, \
    3, \
    3, \
    29, \
    24, \
    24, \
    29, \
    3, \
    11, \
    12, \
    24, \
    19, \
    15, \
    16, \
    16, \
    21, \
    17, \
    9, \
    4, \
    15, \
    4, \
    13, \
    14, \
    18, \
    22, \
    21, \
    24, \
    17, \
    31, \
    1, \
    6, \
    25, \
    1, \
    9, \
    23, \
    1 ))

  f_vec = np.array ( ( \
    0.50, \
    0.50, \
    0.50, \
    0.00, \
    0.00, \
    0.25, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.50, \
    0.50, \
    0.00, \
    0.50, \
    0.50, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.81, \
    0.00, \
    0.00, \
    0.00, \
    0.00, \
    0.33, \
    0.00, \
    0.50 ))

  jed_vec = np.array ( ( \
           0.00, \
           1.00, \
      259261.00, \
      347998.50, \
      584282.50, \
      588465.75, \
      758325.50, \
     1438178.50, \
     1446389.50, \
     1448637.50, \
     1448637.50, \
     1607708.50, \
     1607738.50, \
     1713262.50, \
     1721422.50, \
     1721423.50, \
     1721425.50, \
     1721425.50, \
     1724220.50, \
     1741959.50, \
     1749994.50, \
     1825029.50, \
     1862836.50, \
     1922867.50, \
     1936747.50, \
     1940351.50, \
     1948320.50, \
     1948438.50, \
     1948439.50, \
     1952062.50, \
     1952067.50, \
     2114872.50, \
     2289425.50, \
     2299160.00, \
     2299161.00, \
     2333269.50, \
     2361221.00, \
     2361222.00, \
     2372547.50, \
     2375839.50, \
     2394646.50, \
     2394710.50, \
     2400000.50, \
     2415020.31, \
     2440587.50, \
     2444244.50, \
     2450138.50, \
     2451544.50, \
     2453073.83, \
     2456284.50, \
     2913943.00 ))

  m_vec = np.array ( ( \
     1, \
     1, \
     10, \
     10, \
     9, \
     2, \
     3, \
     7, \
     1, \
     2, \
     2, \
     9, \
     10, \
     8, \
     12, \
     1, \
     1, \
     1, \
     8, \
     3, \
     3, \
     8, \
     3, \
     7, \
     7, \
     5, \
     3, \
     7, \
     7, \
     6, \
     6, \
     3, \
     2, \
     10, \
     10, \
     3, \
     9, \
     9, \
     9, \
     9, \
     3, \
     5, \
     11, \
     12, \
     1, \
     1, \
     2, \
     1, \
     3, \
     12, \
     1 ))

  y_vec = np.array ( ( \
    -4713, \
    -4713, \
    -4004, \
    -3761, \
    -3114, \
    -3102, \
    -2637, \
     -776, \
     -753, \
     -747, \
     -747, \
     -312, \
     -312, \
      -23, \
       -1, \
        1, \
        1, \
        1, \
        8, \
       57, \
       79, \
      284, \
      388, \
      552, \
      590, \
      600, \
      622, \
      622, \
      622, \
      632, \
      632, \
     1078, \
     1556, \
     1582, \
     1582, \
     1676, \
     1752, \
     1752, \
     1783, \
     1792, \
     1844, \
     1844, \
     1858, \
     1899, \
     1970, \
     1980, \
     1996, \
     2000, \
     2004, \
     2012, \
     3266 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    jed = 0.0
    y = 0
    m = 0
    d = 0
    f = 0.0
  else:
    jed = jed_vec[n_data]
    y = y_vec[n_data]
    m = m_vec[n_data]
    d = d_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, jed, y, m, d, f

def jed_ce_values_test ( ):

#*****************************************************************************80
#
## jed_ce_values_test() tests jed_ce_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'jed_ce_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  jed_ce_values stores of the YMDF CE calendar date for a given JED' )
  print ( '' )
  print ( '         JED         Y       M       D           F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, jed, y, m, d, f = jed_ce_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12.1f  %6d  %6d  %6d  %12.2g' % ( jed, y, m, d, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'jed_ce_values_test:' )
  print ( '  Normal end of execution.' )
  return

def jed_mjd_values ( n_data ):

#*****************************************************************************80
#
## jed_mjd_values returns the MJD for Julian Ephemeris Dates.
#
#  Discussion:
#
#    The JED (Julian Ephemeris Date) is a calendrical system which counts days,
#    starting from noon on 1 January 4713 BCE.
#
#    The MJD (Modified Julian Day) counts days starting from midnight, 
#    17 November 1858.  This essentially subtracts 2400000.5 days from the JED.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Edward Reingold and Nachum Dershowitz,
#    Calendrical Calculations: The Millennium Edition,
#    Cambridge University Press, 2001,
#    ISBN: 0 521 77752 6
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real JED, the Julian Ephemeris Date.
#
#    real MJD, the Modified Julian Ephemeris Date.
#
  import numpy as np

  n_max = 33

  jed_vec = np.array ( ( \
     1507231.5E+00, \
     1660037.5E+00, \
     1746893.5E+00, \
     1770641.5E+00, \
     1892731.5E+00, \
     1931579.5E+00, \
     1974851.5E+00, \
     2091164.5E+00, \
     2121509.5E+00, \
     2155779.5E+00, \
     2174029.5E+00, \
     2191584.5E+00, \
     2195261.5E+00, \
     2229274.5E+00, \
     2245580.5E+00, \
     2266100.5E+00, \
     2288542.5E+00, \
     2290901.5E+00, \
     2323140.5E+00, \
     2334848.5E+00, \
     2348020.5E+00, \
     2366978.5E+00, \
     2385648.5E+00, \
     2392825.5E+00, \
     2416223.5E+00, \
     2425848.5E+00, \
     2430266.5E+00, \
     2430833.5E+00, \
     2431004.5E+00, \
     2448698.5E+00, \
     2450138.5E+00, \
     2465737.5E+00, \
     2486076.5E+00 ))

  mjd_vec = np.array ( ( \
     -892769.0E+00, \
     -739963.0E+00, \
     -653107.0E+00, \
     -629359.0E+00, \
     -507269.0E+00, \
     -468421.0E+00, \
     -425149.0E+00, \
     -308836.0E+00, \
     -278491.0E+00, \
     -244221.0E+00, \
     -225971.0E+00, \
     -208416.0E+00, \
     -204739.0E+00, \
     -170726.0E+00, \
     -154420.0E+00, \
     -133900.0E+00, \
     -111458.0E+00, \
     -109099.0E+00, \
      -76860.0E+00, \
      -65152.0E+00, \
      -51980.0E+00, \
      -33022.0E+00, \
      -14352.0E+00, \
       -7175.0E+00, \
       16223.0E+00, \
       25848.0E+00, \
       30266.0E+00, \
       30833.0E+00, \
       31004.0E+00, \
       48698.0E+00, \
       50138.0E+00, \
       65737.0E+00, \
       86076.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    jed = 0.0
    mjd = 0.0
  else:
    jed = jed_vec[n_data]
    mjd = mjd_vec[n_data]
    n_data = n_data + 1

  return n_data, jed, mjd

def jed_mjd_values_test ( ):

#*****************************************************************************80
#
## jed_mjd_values_test() tests jed_mjd_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'jed_mjd_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  jed_mjd_values stores values of the Modified Julian Date.' )
  print ( '' )
  print ( '    JED         MJD(JED)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, jed, mjd = jed_mjd_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( jed, mjd ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'jed_mjd_values_test:' )
  print ( '  Normal end of execution.' )
  return

def jed_rd_values ( n_data ):

#*****************************************************************************80
#
## jed_rd_values returns the RD for Julian Ephemeris Dates.
#
#  Discussion:
#
#    The JED (Julian Ephemeris Date) is a calendrical system which counts days,
#    starting from noon on 1 January 4713 BCE.
#
#    The RD is the Reingold Dershowitz Date, which counts days from
#    midnight, 1 January year 1 in the Gregorian calendar.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Edward Reingold and Nachum Dershowitz,
#    Calendrical Calculations: The Millennium Edition,
#    Cambridge University Press, 2001,
#    ISBN: 0 521 77752 6
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real JED, the Julian Ephemeris Date.
#
#    real RD, the Modified Julian Ephemeris Date.
#
  import numpy as np

  n_max = 33

  jed_vec = np.array ( ( \
     1507231.5E+00, \
     1660037.5E+00, \
     1746893.5E+00, \
     1770641.5E+00, \
     1892731.5E+00, \
     1931579.5E+00, \
     1974851.5E+00, \
     2091164.5E+00, \
     2121509.5E+00, \
     2155779.5E+00, \
     2174029.5E+00, \
     2191584.5E+00, \
     2195261.5E+00, \
     2229274.5E+00, \
     2245580.5E+00, \
     2266100.5E+00, \
     2288542.5E+00, \
     2290901.5E+00, \
     2323140.5E+00, \
     2334848.5E+00, \
     2348020.5E+00, \
     2366978.5E+00, \
     2385648.5E+00, \
     2392825.5E+00, \
     2416223.5E+00, \
     2425848.5E+00, \
     2430266.5E+00, \
     2430833.5E+00, \
     2431004.5E+00, \
     2448698.5E+00, \
     2450138.5E+00, \
     2465737.5E+00, \
     2486076.5E+00 ))

  rd_vec = np.array ( ( \
    -214193.0E+00, \
     -61387.0E+00, \
      25469.0E+00, \
      49217.0E+00, \
     171307.0E+00, \
     210155.0E+00, \
     253427.0E+00, \
     369740.0E+00, \
     400085.0E+00, \
     434355.0E+00, \
     452605.0E+00, \
     470160.0E+00, \
     473837.0E+00, \
     507850.0E+00, \
     524156.0E+00, \
     544676.0E+00, \
     567118.0E+00, \
     569477.0E+00, \
     601716.0E+00, \
     613424.0E+00, \
     626596.0E+00, \
     645554.0E+00, \
     664224.0E+00, \
     671401.0E+00, \
     694799.0E+00, \
     704424.0E+00, \
     708842.0E+00, \
     709409.0E+00, \
     709580.0E+00, \
     727274.0E+00, \
     728714.0E+00, \
     744313.0E+00, \
     764652.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    jed = 0.0
    rd = 0.0
  else:
    jed = jed_vec[n_data]
    rd = rd_vec[n_data]
    n_data = n_data + 1

  return n_data, jed, rd

def jed_rd_values_test ( ):

#*****************************************************************************80
#
## jed_rd_values_test() tests jed_rd_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'jed_rd_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  jed_rd_values stores values of the Reingold Dershowitz Date.' )
  print ( '' )
  print ( '    JED         RD(JED)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, jed, rd = jed_rd_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( jed, rd ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'jed_rd_values_test:' )
  print ( '  Normal end of execution.' )
  return

def jed_weekday_values ( n_data ):

#*****************************************************************************80
#
## jed_weekday_values returns the day of the week for Julian Ephemeris Dates.
#
#  Discussion:
#
#    The JED (Julian Ephemeris Date) is a calendrical system which counts days,
#    starting from noon on 1 January 4713 BCE.
#
#    Weekdays are numbered as follows:
#
#    1  Sunday
#    2  Monday
#    3  Tuesday
#    4  Wednesday
#    5  Thursday
#    6  Friday
#    7  Saturday
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Edward Reingold and Nachum Dershowitz,
#    Calendrical Calculations: The Millennium Edition,
#    Cambridge University Press, 2001,
#    ISBN: 0 521 77752 6
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real JED, the Julian Ephemeris Date.
#
#    integer WEEKDAY, the day of the week.
#
  import numpy as np

  n_max = 33

  jed_vec = np.array ( (\
    1507231.5E+00, \
    1660037.5E+00, \
    1746893.5E+00, \
    1770641.5E+00, \
    1892731.5E+00, \
    1931579.5E+00, \
    1974851.5E+00, \
    2091164.5E+00, \
    2121509.5E+00, \
    2155779.5E+00, \
    2174029.5E+00, \
    2191584.5E+00, \
    2195261.5E+00, \
    2229274.5E+00, \
    2245580.5E+00, \
    2266100.5E+00, \
    2288542.5E+00, \
    2290901.5E+00, \
    2323140.5E+00, \
    2334848.5E+00, \
    2348020.5E+00, \
    2366978.5E+00, \
    2385648.5E+00, \
    2392825.5E+00, \
    2416223.5E+00, \
    2425848.5E+00, \
    2430266.5E+00, \
    2430833.5E+00, \
    2431004.5E+00, \
    2448698.5E+00, \
    2450138.5E+00, \
    2465737.5E+00, \
    2486076.5E+00 ))

  weekday_vec = np.array ( (\
    1, 4, 4, 1, 4, \
    2, 7, 1, 1, 6, \
    7, 6, 1, 1, 4, \
    7, 7, 7, 4, 1, \
    6, 1, 2, 4, 1, \
    1, 2, 2, 5, 3, \
    1, 4, 1 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    jed = 0.0
    weekday = 0
  else:
    jed = jed_vec[n_data]
    weekday = weekday_vec[n_data]
    n_data = n_data + 1

  return n_data, jed, weekday

def jed_weekday_values_test ( ):

#*****************************************************************************80
#
## jed_weekday_values_test() tests jed_weekday_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'jed_weekday_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  jed_weekday_values stores values of the Weekday for a given JED.' )
  print ( '' )
  print ( '    JED         WEEKDAY(JED)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, jed, weekday = jed_weekday_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %d' % ( jed, weekday ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'jed_weekday_values_test:' )
  print ( '  Normal end of execution.' )
  return

def kei0_values ( n_data ):

#*****************************************************************************80
#
## kei0_values returns some values of the Kelvin kei function of order NU = 0.
#
#  Discussion:
#
#    The function is defined by:
#
#      KER(NU,X) + i * kei(NU,X) = exp(-nu*Pi*I/2) * K(NU,X*exp(PI*I/4))
#
#    where K(NU,X) is the K Bessel function.
#
#    In Mathematica, kei(NU,X) can be defined by:
#
#      Im [ Exp [ -NU * Pi * I / 2 ] * BesselK [ NU, X * Exp[ Pi * I / 4 ] ] ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    LC: QA47.A34,
#    ISBN: 0-486-61272-4.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    LC: QA76.95.W65,
#    ISBN: 0-521-64314-7.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 11

  f_vec = np.array ( ( \
    0.0000000000000000, \
    -0.6715816950943676, \
    -0.4949946365187199, \
    -0.3313955623385585, \
    -0.2024000677647043, \
    -0.1106960991556749, \
   -0.05112188404598678, \
   -0.01600256851827124, \
   0.002198399294972520, \
   0.009720918540151990, \
   0.01118758650986964 ))

  x_vec = np.array ( ( \
    0.0, \
    0.5, \
    1.0, \
    1.5, \
    2.0, \
    2.5, \
    3.0, \
    3.5, \
    4.0, \
    4.5, \
    5.0  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def kei0_values_test ( ):

#*****************************************************************************80
#
## kei0_values_test() tests kei0_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'kei0_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  kei0_values stores values of the Kelvin kei function. of order 0.' )
  print ( '' )
  print ( '      X         kei(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = kei0_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'kei0_values_test:' )
  print ( '  Normal end of execution.' )
  return

def kei1_values ( n_data ):

#*****************************************************************************80
#
## kei0_values returns some values of the Kelvin kei function of order NU = 1.
#
#  Discussion:
#
#    The function is defined by:
#
#      KER(NU,X) + i * kei(NU,X) = exp(-nu*Pi*I/2) * K(NU,X*exp(PI*I/4))
#
#    where K(NU,X) is the K Bessel function.
#
#    In Mathematica, kei(NU,X) can be defined by:
#
#      Im [ Exp [ -NU * Pi * I / 2 ] * BesselK [ NU, X * Exp[ Pi * I / 4 ] ] ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    LC: QA47.A34,
#    ISBN: 0-486-61272-4.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    LC: QA76.95.W65,
#    ISBN: 0-521-64314-7.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 10

  f_vec = np.array ( ( \
    -1.051182085412523, \
    -0.2419959664297382, \
    0.001008680985009855, \
    0.08004939780706674, \
    0.09331378813535750, \
   0.08027022252392219, \
   0.05937625647622691, \
   0.03916601076917133, \
   0.02300216024690250, \
   0.01157775439325247 ))

  x_vec = np.array ( ( \
    0.5, \
    1.0, \
    1.5, \
    2.0, \
    2.5, \
    3.0, \
    3.5, \
    4.0, \
    4.5, \
    5.0  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def kei1_values_test ( ):

#*****************************************************************************80
#
## kei1_values_test() tests kei1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'kei1_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  kei1_values stores values of the Kelvin kei function of order 1.' )
  print ( '' )
  print ( '      X         kei(1,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = kei1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'kei1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def ker0_values ( n_data ):

#*****************************************************************************80
#
## ker0_values returns some values of the Kelvin KER function of order NU = 0.
#
#  Discussion:
#
#    The function is defined by:
#
#      KER(NU,X) + i * kei(NU,X) = exp(-nu*Pi*I/2) * K(NU,X*exp(PI*I/4))
#
#    where K(NU,X) is the K Bessel function.
#
#    In Mathematica, KER(NU,X) can be defined by:
#
#      Re [ Exp [ -NU * Pi * I / 2 ] * BesselK [ NU, X * Exp[ Pi * I / 4 ] ] ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    LC: QA47.A34,
#    ISBN: 0-486-61272-4.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    LC: QA76.95.W65,
#    ISBN: 0-521-64314-7.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 10

  f_vec = np.array ( ( \
    0.8559058721186342, \
    0.2867062087283160, \
    0.05293491548771044, \
   -0.04166451399150953, \
   -0.06968797258904534, \
   -0.06702923330379870, \
   -0.05263927724224119, \
   -0.03617884789954761, \
   -0.02199987504667382, \
   -0.01151172719949066 ))

  x_vec = np.array ( ( \
    0.5, \
    1.0, \
    1.5, \
    2.0, \
    2.5, \
    3.0, \
    3.5, \
    4.0, \
    4.5, \
    5.0  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def ker0_values_test ( ):

#*****************************************************************************80
#
## ker0_values_test() tests ker0_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'ker0_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  ker0_values stores values of the Kelvin KER function. of order 0.' )
  print ( '' )
  print ( '      X         KER(0,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = ker0_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'ker0_values_test:' )
  print ( '  Normal end of execution.' )
  return

def ker1_values ( n_data ):

#*****************************************************************************80
#
## ker1_values returns some values of the Kelvin KER function of order NU = 1.
#
#  Discussion:
#
#    The function is defined by:
#
#      KER(NU,X) + i * kei(NU,X) = exp(-nu*Pi*I/2) * K(NU,X*exp(PI*I/4))
#
#    where K(NU,X) is the K Bessel function.
#
#    In Mathematica, KER(NU,X) can be defined by:
#
#      Re [ Exp [ -NU * Pi * I / 2 ] * BesselK [ NU, X * Exp[ Pi * I / 4 ] ] ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    LC: QA47.A34,
#    ISBN: 0-486-61272-4.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    LC: QA76.95.W65,
#    ISBN: 0-521-64314-7.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 10

  f_vec = np.array (( \
   -1.522403406532090, \
   -0.7403222768419827, \
   -0.4170442851662574, \
   -0.2308059295181230, \
   -0.1172561358598705, \
   -0.04989830778751491, \
   -0.01272324936181659, \
    0.005351296460277448, \
    0.01209090413515866, \
    0.01273739048421857 ))

  x_vec = np.array ( ( \
    0.5, \
    1.0, \
    1.5, \
    2.0, \
    2.5, \
    3.0, \
    3.5, \
    4.0, \
    4.5, \
    5.0  ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def ker1_values_test ( ):

#*****************************************************************************80
#
## ker1_values_test() tests ker1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'ker1_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  ker1_values stores values of the Kelvin KER function of order 1.' )
  print ( '' )
  print ( '      X         KER(1,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, fx = ker1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16g' % ( x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'ker1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def laguerre_associated_values ( n_data ):

#*****************************************************************************80
#
## laguerre_associated_values returns some values of the associated Laguerre polynomials.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      LaguerreL[n,m,x]
#
#    The associated Laguerre polynomials may be generalized so that the 
#    parameter M is allowed to take on arbitrary noninteger values.
#    The resulting function is known as the generalized Laguerre function.
#    
#    The polynomials satisfy the differential equation:
#
#      X * Y'' + (M+1-X) * Y' + (N-M) * Y = 0
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    integer M, the parameter.
#
#    real X, the point where the function is evaluated.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1500000000000000E+01, \
     0.1625000000000000E+01, \
     0.1479166666666667E+01, \
     0.1148437500000000E+01, \
     0.4586666666666667E+00, \
     0.2878666666666667E+01, \
     0.8098666666666667E+01, \
     0.1711866666666667E+02, \
     0.1045328776041667E+02, \
     0.1329019368489583E+02, \
     0.5622453647189670E+02, \
     0.7484729341779436E+02, \
     0.3238912982762806E+03, \
     0.4426100000097533E+03, \
     0.1936876572288250E+04 ))

  m_vec = np.array ( ( \
    0, 0, 0, 0, \
    0, 1, 1, 1, \
    1, 0, 1, 2, \
    3, 2, 2, 3, \
    3, 4, 4, 5 ))

  n_vec = np.array ( ( \
    1,  2,  3,  4, \
    5,  1,  2,  3, \
    4,  3,  3,  3, \
    3,  4,  5,  6, \
    7,  8,  9, 10 ))

  x_vec = np.array ( ( \
     0.00E+00, \
     0.00E+00, \
     0.00E+00, \
     0.00E+00, \
     0.00E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.20E+00, \
     0.20E+00, \
     0.20E+00, \
     0.20E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    m = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    m = m_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, m, x, f

def laguerre_associated_values_test ( ):

#*****************************************************************************80
#
## laguerre_associated_values_test() tests laguerre_associated_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'laguerre_associated_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  laguerre_associated_values stores values of the associated Laguerre function.' )
  print ( '' )
  print ( '      N       M            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, m, x, f = laguerre_associated_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %6d  %12f  %24.16g' % ( n, m, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'laguerre_associated_values_test:' )
  print ( '  Normal end of execution.' )
  return

def laguerre_general_values ( n_data ):

#*****************************************************************************80
#
## laguerre_general_values: values of the generalized Laguerre polynomials.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      LaguerreL[n,a,x]
#
#    The functions satisfy the following differential equation:
#
#      X * Y'' + (ALPHA+1-X) * Y' + N * Y = 0
#
#    Function values can be generated by the recursion:
#
#      L(0,ALPHA)(X) = 1
#      L(1,ALPHA)(X) = 1+ALPHA-X
#
#      L(N,ALPHA)(X) = ( (2*N-1+ALPHA-X) * L(N-1,ALPHA)(X) 
#                     - (N-1+ALPHA) * L(N-2,ALPHA)(X) ) / N
#
#    The parameter ALPHA is required to be greater than -1.
#
#    For ALPHA = 0, the generalized Laguerre function L(N,ALPHA)(X)
#    is equal to the Laguerre polynomial L(N)(X).
#
#    For ALPHA integral, the generalized Laguerre function
#    L(N,ALPHA)(X) equals the associated Laguerre polynomial L(N,ALPHA)(X).
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real A, the parameter.
#
#    real X, the point where the function is evaluated.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  a_vec = np.array ( ( \
     0.00E+00, \
     0.25E+00, \
     0.50E+00, \
     0.75E+00, \
     1.50E+00, \
     2.50E+00, \
     5.00E+00, \
     1.20E+00, \
     1.20E+00, \
     1.20E+00, \
     1.20E+00, \
     1.20E+00, \
     1.20E+00, \
     5.20E+00, \
     5.20E+00, \
     5.20E+00, \
     5.20E+00, \
     5.20E+00, \
     5.20E+00, \
     5.20E+00 ))

  f_vec = np.array ( ( \
      0.3726399739583333E-01, \
      0.3494791666666667E+00, \
      0.8710042317708333E+00, \
      0.1672395833333333E+01, \
      0.6657625325520833E+01, \
      0.2395726725260417E+02, \
      0.2031344319661458E+03, \
      0.1284193996800000E+02, \
      0.5359924801587302E+01, \
      0.9204589064126984E+00, \
     -0.1341585114857143E+01, \
     -0.2119726307555556E+01, \
     -0.1959193658349206E+01, \
      0.1000000000000000E+01, \
      0.5450000000000000E+01, \
      0.1720125000000000E+02, \
      0.4110393750000000E+02, \
      0.8239745859375000E+02, \
      0.1460179186171875E+03, \
      0.2359204608298828E+03 ))

  n_vec = np.array ( ( \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     5, \
     8, \
     8, \
     8, \
     8, \
     8, \
     8, \
     0, \
     1, \
     2, \
     3, \
     4, \
     5, \
     6 ))

  x_vec = np.array ( ( \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.00E+00, \
     0.20E+00, \
     0.40E+00, \
     0.60E+00, \
     0.80E+00, \
     1.00E+00, \
     0.75E+00, \
     0.75E+00, \
     0.75E+00, \
     0.75E+00, \
     0.75E+00, \
     0.75E+00, \
     0.75E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    a = 0.0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    a = a_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, a, x, f

def laguerre_general_values_test ( ):

#*****************************************************************************80
#
## laguerre_general_values_test() tests laguerre_general_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'laguerre_general_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  laguerre_general_values stores values of the general Laguerre function.' )
  print ( '' )
  print ( '      N             A            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, a, x, f = laguerre_general_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %12f  %24.16g' % ( n, a, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'laguerre_general_values_test:' )
  print ( '  Normal end of execution.' )
  return

def laguerre_polynomial_values ( n_data ):

#*****************************************************************************80
#
## laguerre_polynomial_values returns some values of the Laguerre polynomial.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      LaguerreL[n,x]
#
#  Differential equation:
#
#    X * Y'' + (1-X) * Y' + N * Y = 0
#
#  First terms:
#
#      1
#     -X   +  1
#   (  X^2 -  4 X   +   2 ) / 2
#   ( -X^3 +  9 X^2 -  18 X   +    6 ) / 6
#   (  X^4 - 16 X^3 +  72 X^2 -   96 X +      24 ) / 24
#   ( -X^5 + 25 X^4 - 200 X^3 +  600 X^2 -   600 X   +   120 ) / 120
#   (  X^6 - 36 X^5 + 450 X^4 - 2400 X^3 +  5400 X^2 -  4320 X   +   720 ) / 720
#   ( -X^7 + 49 X^6 - 882 X^5 + 7350 X^4 - 29400 X^3 + 52920 X^2 - 35280 X + 5040 ) / 5040
#
#  Recursion:
#
#    L(0)(X) = 1,
#    L(1)(X) = 1-X,
#    N * L(N)(X) = (2*N-1-X) * L(N-1)(X) - (N-1) * L(N-2)(X)
#
#  Orthogonality:
#
#    Integral ( 0 <= X < oo ) exp ( - X ) * L(N)(X) * L(M)(X) dX
#    = 0 if N /= M
#    = 1 if N == M
#
#  Special values:
#
#    L(N)(0) = 1.
#
#  Relations:
#
#    L(N)(X) = (-1)^N / N! * exp ( x ) * (d/dx)^n ( exp ( - x ) * X^n )  
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the polynomial.
#
#    real X, the point where the polynomial is evaluated.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 17

  f_vec = np.array ( ( \
      0.1000000000000000E+01, \
      0.0000000000000000E+00, \
     -0.5000000000000000E+00, \
     -0.6666666666666667E+00, \
     -0.6250000000000000E+00, \
     -0.4666666666666667E+00, \
     -0.2569444444444444E+00, \
     -0.4047619047619048E-01, \
      0.1539930555555556E+00, \
      0.3097442680776014E+00, \
      0.4189459325396825E+00, \
      0.4801341790925124E+00, \
      0.4962122235082305E+00, \
     -0.4455729166666667E+00, \
      0.8500000000000000E+00, \
     -0.3166666666666667E+01, \
      0.3433333333333333E+02 ))

  n_vec = np.array ( ( \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10, 11, \
    12,  5,  5, \
     5,  5 ))

  x_vec = np.array ( ( \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     0.5E+00, \
     3.0E+00, \
     5.0E+00, \
     1.0E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, f

def laguerre_polynomial_values_test ( ):

#*****************************************************************************80
#
## laguerre_polynomial_values_test demonstrates laguerre_polynomial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'laguerre_polynomial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  laguerre_polynomial_values stores values of' )
  print ( '  the Laguerre polynomials.' )
  print ( '' )
  print ( '     N    X            L(N)(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    [ n_data, n, x, f ] = laguerre_polynomial_values ( n_data );

    if ( n_data == 0 ):
      break

    print ( '  %4d  %12f  %24.16f' % (  n, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'laguerre_polynomial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def lambert_w_values ( n_data ):

#*****************************************************************************80
#
## lambert_w_values returns some values of the Lambert W function.
#
#  Discussion:
#
#    The function W(X) is defined implicitly by:
#
#      W(X) * e^W(X) = X
#
#    The function is also known as the "Omega" function.
#
#    In Mathematica, the function can be evaluated by:
#
#      W = ProductLog [ X ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Brian Hayes,
#    "Why W?",
#    The American Scientist,
#    Volume 93, March-April 2005, pages 104-108.
#
#    Eric Weisstein,
#    "Lambert's W-Function",
#    CRC Concise Encyclopedia of Mathematics,
#    CRC Press, 1998.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 22

  f_vec = np.array ( ( \
    0.0000000000000000E+00, \
    0.3517337112491958E+00, \
    0.5671432904097839E+00, \
    0.7258613577662263E+00, \
    0.8526055020137255E+00, \
    0.9585863567287029E+00, \
    0.1000000000000000E+01, \
    0.1049908894964040E+01, \
    0.1130289326974136E+01, \
    0.1202167873197043E+01, \
    0.1267237814307435E+01, \
    0.1326724665242200E+01, \
    0.1381545379445041E+01, \
    0.1432404775898300E+01, \
    0.1479856830173851E+01, \
    0.1524345204984144E+01, \
    0.1566230953782388E+01, \
    0.1605811996320178E+01, \
    0.1745528002740699E+01, \
    0.3385630140290050E+01, \
    0.5249602852401596E+01, \
    0.1138335808614005E+02 ))

  x_vec = np.array ( ( \
    0.0000000000000000E+00, \
    0.5000000000000000E+00, \
    0.1000000000000000E+01, \
    0.1500000000000000E+01, \
    0.2000000000000000E+01, \
    0.2500000000000000E+01, \
    0.2718281828459045E+01, \
    0.3000000000000000E+01, \
    0.3500000000000000E+01, \
    0.4000000000000000E+01, \
    0.4500000000000000E+01, \
    0.5000000000000000E+01, \
    0.5500000000000000E+01, \
    0.6000000000000000E+01, \
    0.6500000000000000E+01, \
    0.7000000000000000E+01, \
    0.7500000000000000E+01, \
    0.8000000000000000E+01, \
    0.1000000000000000E+02, \
    0.1000000000000000E+03, \
    0.1000000000000000E+04, \
    0.1000000000000000E+07 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def lambert_w_values_test ( ):

#*****************************************************************************80
#
## lambert_w_values_test() tests lambert_w_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'lambert_w_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  lambert_w_values stores values of the Lambert W function.' )
  print ( '' )
  print ( '      X         lambert_w(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = lambert_w_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'lambert_w_values_test:' )
  print ( '  Normal end of execution.' )
  return

def laplace_cdf_values ( n_data ):

#*****************************************************************************80
#
## laplace_cdf_values returns some values of the Laplace CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = LaplaceDistribution [ mu, beta ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real MU, the mean of the distribution.
#
#    real BETA, the shape parameter.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 12

  beta_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01 ))

  f_vec = np.array ( ( \
     0.5000000000000000E+00, \
     0.8160602794142788E+00, \
     0.9323323583816937E+00, \
     0.9751064658160680E+00, \
     0.6967346701436833E+00, \
     0.6417343447131054E+00, \
     0.6105996084642976E+00, \
     0.5906346234610091E+00, \
     0.5000000000000000E+00, \
     0.3032653298563167E+00, \
     0.1839397205857212E+00, \
     0.1115650800742149E+00 ))

  mu_vec = np.array ( ( \
     0.0000000000000000E+01, \
     0.0000000000000000E+01, \
     0.0000000000000000E+01, \
     0.0000000000000000E+01, \
     0.0000000000000000E+01, \
     0.0000000000000000E+01, \
     0.0000000000000000E+01, \
     0.0000000000000000E+01, \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01 ))

  x_vec = np.array ( ( \
     0.0000000000000000E+01, \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    mu = 0.0
    beta = 0.0
    x = 0.0
    f = 0.0
  else:
    mu = mu_vec[n_data]
    beta = beta_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, mu, beta, x, f

def laplace_cdf_values_test ( ):

#*****************************************************************************80
#
## laplace_cdf_values_test() tests laplace_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'laplace_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  laplace_cdf_values stores values of the LAPLACE CDF.' )
  print ( '' )
  print ( '        Mu            Beta         X            F(Mu,Beta,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, mu, beta, x, f = laplace_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16g' % ( mu, beta, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'laplace_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def legendre_associated_normalized_sphere_values ( n_data ):

#*****************************************************************************80
#
## legendre_associated_normalized_sphere_values does what it says.
#
#  Discussion:
#
#    The function considered is the associated Legendre polynomial P^M_N(X).
#
#    In Mathematica, the function can be evaluated by:
#
#      LegendreP [ n, m, x ]
#
#    The function is normalized for the unit sphere by dividing by
#
#      sqrt ( 4 * pi * ( n + m )! / ( 2 * n + 1 ) / ( n - m )! )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, integer M, real X, 
#    the arguments of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 21

  f_vec = np.array ( ( \
     0.2820947917738781, \
     0.2443012559514600, \
    -0.2992067103010745, \
    -0.07884789131313000, \
    -0.3345232717786446, \
     0.2897056515173922, \
    -0.3265292910163510, \
    -0.06997056236064664, \
     0.3832445536624809, \
    -0.2709948227475519, \
    -0.2446290772414100, \
     0.2560660384200185, \
     0.1881693403754876, \
    -0.4064922341213279, \
     0.2489246395003027, \
     0.08405804426339821, \
     0.3293793022891428, \
    -0.1588847984307093, \
    -0.2808712959945307, \
     0.4127948151484925, \
    -0.2260970318780046  ))

  m_vec = np.array ( ( \
    0, 0, 1, 0, \
    1, 2, 0, 1, \
    2, 3, 0, 1, \
    2, 3, 4, 0, \
    1, 2, 3, 4, \
    5 ))

  n_vec = np.array ( ( \
    0,  1,  1,  2, \
    2,  2,  3,  3, \
    3,  3,  4,  4, \
    4,  4,  4,  5, \
    5,  5,  5,  5, \
    5 ))

  x_vec = np.array ( ( \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    m = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    m = m_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, m, x, f

def legendre_associated_normalized_sphere_values_test ( ):

#*****************************************************************************80
#
## legendre_associated_normalized_sphere_values_test demonstrates legendre_associated_normalized_sphere_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'legendre_associated_normalized_sphere_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  legendre_associated_normalized_sphere_values stores values of the ' )
  print ( '  associated Legendre function normalized for the surface of a sphere.' )
  print ( '' )
  print ( '      N       M            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, m, x, f = legendre_associated_normalized_sphere_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %6d  %12f  %24.16g' % ( n, m, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'legendre_associated_normalized_sphere_values_test:' )
  print ( '  Normal end of execution.' )
  return

def legendre_associated_normalized_values ( n_data ):

#*****************************************************************************80
#
## legendre_associated_normalized_values returns values of associated Legendre functions.
#
#  Discussion:
#
#    The function considered is the associated Legendre polynomial P^M_N(X).
#
#    In Mathematica, the function can be evaluated by:
#
#      LegendreP [ n, m, x ]
#
#    The function is normalized by dividing by
#
#      sqrt ( 2 * ( n + m )! / ( 2 * n + 1 ) / ( n - m )! )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, integer M, real X, 
#    the arguments of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 21

  f_vec = np.array ( ( \
    0.7071067811865475E+00, \
    0.6123724356957945E+00, \
   -0.7500000000000000E+00, \
   -0.1976423537605237E+00, \
   -0.8385254915624211E+00, \
    0.7261843774138907E+00, \
   -0.8184875533567997E+00, \
   -0.1753901900050285E+00, \
    0.9606516343087123E+00, \
   -0.6792832849776299E+00, \
   -0.6131941618102092E+00, \
    0.6418623720763665E+00, \
    0.4716705890038619E+00, \
   -0.1018924927466445E+01, \
    0.6239615396237876E+00, \
    0.2107022704608181E+00, \
    0.8256314721961969E+00, \
   -0.3982651281554632E+00, \
   -0.7040399320721435E+00, \
    0.1034723155272289E+01, \
   -0.5667412129155530E+00 ))

  m_vec = np.array ( ( \
    0, 0, 1, 0, \
    1, 2, 0, 1, \
    2, 3, 0, 1, \
    2, 3, 4, 0, \
    1, 2, 3, 4, \
    5 ))

  n_vec = np.array ( ( \
    0,  1,  1,  2, \
    2,  2,  3,  3, \
    3,  3,  4,  4, \
    4,  4,  4,  5, \
    5,  5,  5,  5, \
    5 ))

  x_vec = np.array ( ( \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    m = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    m = m_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, m, x, f

def legendre_associated_normalized_values_test ( ):

#*****************************************************************************80
#
## legendre_associated_normalized_values_test demonstrates legendre_associated_normalized_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'legendre_associated_normalized_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  legendre_associated_normalized_values stores values of the ' )
  print ( '  normalized associated Legendre function.' )
  print ( '' )
  print ( '      N       M            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, m, x, f = legendre_associated_normalized_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %6d  %12f  %24.16g' % ( n, m, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'legendre_associated_normalized_values_test:' )
  print ( '  Normal end of execution.' )
  return

def legendre_associated_values ( n_data ):

#*****************************************************************************80
#
## legendre_associated_values returns values of associated Legendre functions.
#
#  Discussion:
#
#    The function considered is the associated Legendre polynomial P^M_N(X).
#
#    In Mathematica, the function can be evaluated by:
#
#      LegendreP [ n, m, x ]
#
#  Differential equation:
#
#    (1-X*X) * Y'' - 2 * X * Y + ( N (N+1) - (M*M/(1-X*X)) * Y = 0
#
#  First terms:
#
#    M = 0  ( = Legendre polynomials of first kind P(N)(X) )
#
#    P00 =    1
#    P10 =    1 X
#    P20 = (  3 X^2 -   1)/2
#    P30 = (  5 X^3 -   3 X)/2
#    P40 = ( 35 X^4 -  30 X^2 +   3)/8
#    P50 = ( 63 X^5 -  70 X^3 +  15 X)/8
#    P60 = (231 X^6 - 315 X^4 + 105 X^2 -  5)/16
#    P70 = (429 X^7 - 693 X^5 + 315 X^3 - 35 X)/16
#
#    M = 1
#
#    p01 =   0
#    P11 =   1 * SQRT(1-X*X)
#    P21 =   3 * SQRT(1-X*X) * X
#    P31 = 1.5 * SQRT(1-X*X) * (5*X*X-1)
#    P41 = 2.5 * SQRT(1-X*X) * (7*X*X*X-3*X)
#
#    M = 2
#
#    P02 =   0
#    P12 =   0
#    P22 =   3 * (1-X*X)
#    P32 =  15 * (1-X*X) * X
#    P42 = 7.5 * (1-X*X) * (7*X*X-1)
#
#    M = 3
#
#    P03 =   0
#    P13 =   0
#    P23 =   0
#    P33 =  15 * (1-X*X)^1.5
#    P43 = 105 * (1-X*X)^1.5 * X
#
#    M = 4
#
#    P04 =   0
#    P14 =   0
#    P24 =   0
#    P34 =   0
#    P44 = 105 * (1-X*X)^2
#
#  Recursion:
#
#    if N < M:
#      P(N,M) = 0
#    if N = M:
#      P(N,M) = (2*M-1)!! * (1-X*X)^(M/2) where N!! means the product of
#      all the odd integers less than or equal to N.
#    if N = M+1:
#      P(N,M) = X*(2*M+1)*P(M,M)
#    if M+1 < N:
#      P(N,M) = ( X*(2*N-1)*P(N-1,M) - (N+M-1)*P(N-2,M) )/(N-M)
#
#  Restrictions:
#
#    -1 <= X <= 1
#     0 <= M <= N
#
#  Special values:
#
#    P(N,0)(X) = P(N)(X), that is, for M=0, the associated Legendre
#    polynomial of the first kind equals the Legendre polynomial of the
#    first kind.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, integer M, real X, 
#    the arguments of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
      0.0000000000000000E+00, \
     -0.5000000000000000E+00, \
      0.0000000000000000E+00, \
      0.3750000000000000E+00, \
      0.0000000000000000E+00, \
     -0.8660254037844386E+00, \
     -0.1299038105676658E+01, \
     -0.3247595264191645E+00, \
      0.1353164693413185E+01, \
     -0.2800000000000000E+00, \
      0.1175755076535925E+01, \
      0.2880000000000000E+01, \
     -0.1410906091843111E+02, \
     -0.3955078125000000E+01, \
     -0.9997558593750000E+01, \
      0.8265311444100484E+02, \
      0.2024442836815152E+02, \
     -0.4237997531890869E+03, \
      0.1638320624828339E+04, \
     -0.2025687389227225E+05  ))

  m_vec = np.array ( ( \
    0, 0, 0, 0, \
    0, 1, 1, 1, \
    1, 0, 1, 2, \
    3, 2, 2, 3, \
    3, 4, 4, 5 ))

  n_vec = np.array ( ( \
    1,  2,  3,  4, \
    5,  1,  2,  3, \
    4,  3,  3,  3, \
    3,  4,  5,  6, \
    7,  8,  9, 10 ))

  x_vec = np.array ( ( \
     0.00E+00, \
     0.00E+00, \
     0.00E+00, \
     0.00E+00, \
     0.00E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.20E+00, \
     0.20E+00, \
     0.20E+00, \
     0.20E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00 ))
  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    m = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    m = m_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, m, x, f

def legendre_associated_values_test ( ):

#*****************************************************************************80
#
## legendre_associated_values_test() tests legendre_associated_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'legendre_associated_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  legendre_associated_values stores values of the associated Legendre function.' )
  print ( '' )
  print ( '      N       M            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, m, x, f = legendre_associated_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %6d  %12f  %24.16g' % ( n, m, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'legendre_associated_values_test:' )
  print ( '  Normal end of execution.' )
  return

def legendre_function_q_values ( n_data ):

#*****************************************************************************80
#
## legendre_function_q_values returns values of the Legendre Q function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      LegendreQ[n,x]
#
#  Differential equation:
#
#    (1-X*X) Y'' - 2 X Y' + N (N+1) = 0
#
#  First terms:
#
#    Q(0)(X) = 0.5 * log((1+X)/(1-X))
#    Q(1)(X) = Q(0)(X)*X - 1 
#    Q(2)(X) = Q(0)(X)*(3*X*X-1)/4 - 1.5*X
#    Q(3)(X) = Q(0)(X)*(5*X*X*X-3*X)/4 - 2.5*X^2 + 2/3
#    Q(4)(X) = Q(0)(X)*(35*X^4-30*X^2+3)/16 - 35/8 * X^3 + 55/24 * X
#    Q(5)(X) = Q(0)(X)*(63*X^5-70*X^3+15*X)/16 - 63/8*X^4 + 49/8*X^2 - 8/15
#
#  Recursion:
#
#    Q(0) = 0.5 * log ( (1+X) / (1-X) )
#    Q(1) = 0.5 * X * log ( (1+X) / (1-X) ) - 1.0
#
#    Q(N) = ( (2*N-1) * X * Q(N-1) - (N-1) * Q(N-2) ) / N
#
#  Restrictions:
#
#    -1 < X < 1
#
#  Special values:
#
#    Note that the Legendre function Q(N)(X) is equal to the
#    associated Legendre function of the second kind,
#    Q(N,M)(X) with M = 0.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 21

  f_vec = np.array ( ( \
      0.2554128118829953E+00, \
     -0.9361467970292512E+00, \
     -0.4787614548274669E+00, \
      0.4246139251747229E+00, \
      0.5448396833845414E+00, \
     -0.9451328261673470E-01, \
     -0.4973516573531213E+00, \
     -0.1499018843853194E+00, \
      0.3649161918783626E+00, \
      0.3055676545072885E+00, \
     -0.1832799367995643E+00, \
      0.6666666666666667E+00, \
      0.6268672028763330E+00, \
      0.5099015515315237E+00, \
      0.3232754180589764E+00, \
      0.8026113738148187E-01, \
     -0.1986547714794823E+00, \
     -0.4828663183349136E+00, \
     -0.7252886849144386E+00, \
     -0.8454443502398846E+00, \
     -0.6627096245052618E+00 ))

  n_vec = np.array ( ( \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3 ))

  x_vec = np.array ( ( \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.00E+00, \
     0.10E+00, \
     0.20E+00, \
     0.30E+00, \
     0.40E+00, \
     0.50E+00, \
     0.60E+00, \
     0.70E+00, \
     0.80E+00, \
     0.90E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, f

def legendre_function_q_values_test ( ):

#*****************************************************************************80
#
## legendre_function_q_values_test() tests legendre_function_q_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'legendre_function_q_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  legendre_function_q_values stores values of the Legendre Q function' )
  print ( '' )
  print ( '      N            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, f = legendre_function_q_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'legendre_function_q_values_test:' )
  print ( '  Normal end of execution.' )
  return

def legendre_normalized_polynomial_values ( n_data ):

#*****************************************************************************80
#
## legendre_normalized_polynomial_values returns values of the normalized Legendre polynomials.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 March 2016
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 22

  f_vec = np.array ( ( \
    0.7071067811865475, \
    0.3061862178478972, \
   -0.642337649721702, \
   -0.6284815141846855, \
    0.3345637065282053, \
    0.7967179601799685, \
    0.06189376866246124, \
   -0.766588850921089, \
   -0.4444760242953344, \
    0.5450094674858101, \
    0.7167706229835538, \
    0.0000000000000000, \
   -0.2759472322745781, \
   -0.5238320341483518, \
   -0.7155919752205163, \
   -0.823164625090267, \
   -0.8184875533567997, \
   -0.6734983296193094, \
   -0.360134523476992, \
    0.1496662954709581, \
    0.8839665576253438, \
    1.870828693386971 ))

  n_vec = np.array ( ( \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3 ))

  x_vec = np.array ( ( \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.00E+00, \
     0.10E+00, \
     0.20E+00, \
     0.30E+00, \
     0.40E+00, \
     0.50E+00, \
     0.60E+00, \
     0.70E+00, \
     0.80E+00, \
     0.90E+00, \
     1.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, f

def legendre_normalized_polynomial_values_test ( ):

#*****************************************************************************80
#
## legendre_normalized_polynomial_values_test() tests legendre_normalized_polynomial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 March 2016
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'legendre_normalized_polynomial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  legendre_normalized_polynomial_values stores values of the normalized Legendre polynomials.' )
  print ( '' )
  print ( '      N            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, f = legendre_normalized_polynomial_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12g  %24.16g' % ( n, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'legendre_normalized_polynomial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def legendre_polynomial_values ( n_data ):

#*****************************************************************************80
#
## legendre_polynomial_values returns values of the Legendre polynomials.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      LegendreP [ n, x ]
#
#  Differential equation:
#
#    (1-X*X) * P(N,X)'' - 2 * X * P(N,X)' + N * (N+1) = 0
#
#  First terms:
#
#    P( 0,X) =       1
#    P( 1,X) =       1 X
#    P( 2,X) =  (    3 X^2 -       1)/2
#    P( 3,X) =  (    5 X^3 -     3 X)/2
#    P( 4,X) =  (   35 X^4 -    30 X^2 +     3)/8
#    P( 5,X) =  (   63 X^5 -    70 X^3 +    15 X)/8
#    P( 6,X) =  (  231 X^6 -   315 X^4 +   105 X^2 -     5)/16
#    P( 7,X) =  (  429 X^7 -   693 X^5 +   315 X^3 -    35 X)/16
#    P( 8,X) =  ( 6435 X^8 - 12012 X^6 +  6930 X^4 -  1260 X^2 +   35)/128
#    P( 9,X) =  (12155 X^9 - 25740 X^7 + 18018 X^5 -  4620 X^3 +  315 X)/128
#    P(10,X) =  (46189 X^10-109395 X^8 + 90090 X^6 - 30030 X^4 + 3465 X^2-63 ) /256
#
#  Recursion:
#
#    P(0,X) = 1
#    P(1,X) = X
#    P(N,X) = ( (2*N-1)*X*P(N-1,X)-(N-1)*P(N-2,X) ) / N
#
#    P'(0,X) = 0
#    P'(1,X) = 1
#    P'(N,X) = ( (2*N-1)*(P(N-1,X)+X*P'(N-1,X)-(N-1)*P'(N-2,X) ) / N
#
#  Formula:
#
#    P(N,X) = (1/2**N) * sum ( 0 <= M <= N/2 ) C(N,M) C(2N-2M,N) X^(N-2*M)
#
#  Orthogonality:
#
#    Integral ( -1 <= X <= 1 ) P(I,X) * P(J,X) dX
#      = 0 if I =/= J
#      = 2 / ( 2*I+1 ) if I = J.
#
#  Approximation:
#
#    A function F(X) defined on [-1,1] may be approximated by the series
#
#      C0*P(0,X) + C1*P(1,X) + \ + CN*P(N,X)
#
#    where
#
#      C(I) = (2*I+1)/(2) * Integral ( -1 <= X <= 1 ) F(X) P(I,X) dx.
#
#  Special values:
#
#    P(N,1) = 1.
#    P(N,-1) = (-1)^N.
#    | P(N,X) | <= 1 in [-1,1].
#
#    P(N,0,X) = P(N,X), that is, for M=0, the associated Legendre
#    function of the first kind and order N equals the Legendre polynomial
#    of the first kind and order N.
#
#    The N zeroes of P(N,X) are the abscissas used for Gauss-Legendre
#    quadrature of the integral of a function F(X) with weight function 1
#    over the interval [-1,1].
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 22

  f_vec = np.array ( ( \
      0.1000000000000000E+01, \
      0.2500000000000000E+00, \
     -0.4062500000000000E+00, \
     -0.3359375000000000E+00, \
      0.1577148437500000E+00, \
      0.3397216796875000E+00, \
      0.2427673339843750E-01, \
     -0.2799186706542969E+00, \
     -0.1524540185928345E+00, \
      0.1768244206905365E+00, \
      0.2212002165615559E+00, \
      0.0000000000000000E+00, \
     -0.1475000000000000E+00, \
     -0.2800000000000000E+00, \
     -0.3825000000000000E+00, \
     -0.4400000000000000E+00, \
     -0.4375000000000000E+00, \
     -0.3600000000000000E+00, \
     -0.1925000000000000E+00, \
      0.8000000000000000E-01, \
      0.4725000000000000E+00, \
      0.1000000000000000E+01 ))

  n_vec = np.array ( ( \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3 ))

  x_vec = np.array ( ( \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.00E+00, \
     0.10E+00, \
     0.20E+00, \
     0.30E+00, \
     0.40E+00, \
     0.50E+00, \
     0.60E+00, \
     0.70E+00, \
     0.80E+00, \
     0.90E+00, \
     1.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, f

def legendre_polynomial_values_test ( ):

#*****************************************************************************80
#
## legendre_polynomial_values_test() tests legendre_polynomial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'legendre_polynomial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  legendre_polynomial_values stores values of the Legendre polynomials.' )
  print ( '' )
  print ( '      N            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, f = legendre_polynomial_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'legendre_polynomial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def legendre_poly_values ( n_data ):

#*****************************************************************************80
#
## legendre_poly_values returns values of the Legendre polynomials.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      LegendreP [ n, x ]
#
#  Differential equation:
#
#    (1-X*X) * P(N,X)'' - 2 * X * P(N,X)' + N * (N+1) = 0
#
#  First terms:
#
#    P( 0,X) =       1
#    P( 1,X) =       1 X
#    P( 2,X) =  (    3 X^2 -       1)/2
#    P( 3,X) =  (    5 X^3 -     3 X)/2
#    P( 4,X) =  (   35 X^4 -    30 X^2 +     3)/8
#    P( 5,X) =  (   63 X^5 -    70 X^3 +    15 X)/8
#    P( 6,X) =  (  231 X^6 -   315 X^4 +   105 X^2 -     5)/16
#    P( 7,X) =  (  429 X^7 -   693 X^5 +   315 X^3 -    35 X)/16
#    P( 8,X) =  ( 6435 X^8 - 12012 X^6 +  6930 X^4 -  1260 X^2 +   35)/128
#    P( 9,X) =  (12155 X^9 - 25740 X^7 + 18018 X^5 -  4620 X^3 +  315 X)/128
#    P(10,X) =  (46189 X^10-109395 X^8 + 90090 X^6 - 30030 X^4 + 3465 X^2-63 ) /256
#
#  Recursion:
#
#    P(0,X) = 1
#    P(1,X) = X
#    P(N,X) = ( (2*N-1)*X*P(N-1,X)-(N-1)*P(N-2,X) ) / N
#
#    P'(0,X) = 0
#    P'(1,X) = 1
#    P'(N,X) = ( (2*N-1)*(P(N-1,X)+X*P'(N-1,X)-(N-1)*P'(N-2,X) ) / N
#
#  Formula:
#
#    P(N,X) = (1/2^N) * sum ( 0 <= M <= N/2 ) C(N,M) C(2N-2M,N) X^(N-2*M)
#
#  Orthogonality:
#
#    Integral ( -1 <= X <= 1 ) P(I,X) * P(J,X) dX
#      = 0 if I =/= J
#      = 2 / ( 2*I+1 ) if I = J.
#
#  Approximation:
#
#    A function F(X) defined on [-1,1] may be approximated by the series
#
#      C0*P(0,X) + C1*P(1,X) + \ + CN*P(N,X)
#
#    where
#
#      C(I) = (2*I+1)/(2) * Integral ( -1 <= X <= 1 ) F(X) P(I,X) dx.
#
#  Special values:
#
#    P(N,1) = 1.
#    P(N,-1) = (-1)^N.
#    | P(N,X) | <= 1 in [-1,1].
#
#    P(N,0,X) = P(N,X), that is, for M=0, the associated Legendre
#    function of the first kind and order N equals the Legendre polynomial
#    of the first kind and order N.
#
#    The N zeroes of P(N,X) are the abscissas used for Gauss-Legendre
#    quadrature of the integral of a function F(X) with weight function 1
#    over the interval [-1,1].
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 22

  f_vec = np.array ( ( \
      0.1000000000000000E+01, \
      0.2500000000000000E+00, \
     -0.4062500000000000E+00, \
     -0.3359375000000000E+00, \
      0.1577148437500000E+00, \
      0.3397216796875000E+00, \
      0.2427673339843750E-01, \
     -0.2799186706542969E+00, \
     -0.1524540185928345E+00, \
      0.1768244206905365E+00, \
      0.2212002165615559E+00, \
      0.0000000000000000E+00, \
     -0.1475000000000000E+00, \
     -0.2800000000000000E+00, \
     -0.3825000000000000E+00, \
     -0.4400000000000000E+00, \
     -0.4375000000000000E+00, \
     -0.3600000000000000E+00, \
     -0.1925000000000000E+00, \
      0.8000000000000000E-01, \
      0.4725000000000000E+00, \
      0.1000000000000000E+01 ))

  n_vec = np.array ( ( \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3 ))

  x_vec = np.array ( ( \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.00E+00, \
     0.10E+00, \
     0.20E+00, \
     0.30E+00, \
     0.40E+00, \
     0.50E+00, \
     0.60E+00, \
     0.70E+00, \
     0.80E+00, \
     0.90E+00, \
     1.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, f

def legendre_poly_values_test ( ):

#*****************************************************************************80
#
## legendre_poly_values_test() tests legendre_poly_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'legendre_poly_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  legendre_poly_values stores values of the Legendre polynomials.' )
  print ( '' )
  print ( '      N            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, f = legendre_poly_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'legendre_poly_values_test:' )
  print ( '  Normal end of execution.' )
  return

def legendre_shifted_polynomial_values ( n_data ):

#*****************************************************************************80
#
## legendre_shifted_polynomial_values returns values of the Legendre polynomials.
#
#  Discussion:
#
#    If we denote the Legendre polynomial by P(n)(x), and the shifted 
#    Legendre polynomial by p01(n)(x), then
#
#      p01(n)(x) = P(n)(2*x-1)
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 March 2016
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 22

  f_vec = np.array ( ( \
      0.1000000000000000E+01, \
      0.2500000000000000E+00, \
     -0.4062500000000000E+00, \
     -0.3359375000000000E+00, \
      0.1577148437500000E+00, \
      0.3397216796875000E+00, \
      0.2427673339843750E-01, \
     -0.2799186706542969E+00, \
     -0.1524540185928345E+00, \
      0.1768244206905365E+00, \
      0.2212002165615559E+00, \
      0.0000000000000000E+00, \
     -0.1475000000000000E+00, \
     -0.2800000000000000E+00, \
     -0.3825000000000000E+00, \
     -0.4400000000000000E+00, \
     -0.4375000000000000E+00, \
     -0.3600000000000000E+00, \
     -0.1925000000000000E+00, \
      0.8000000000000000E-01, \
      0.4725000000000000E+00, \
      0.1000000000000000E+01 ))

  n_vec = np.array ( ( \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3 ))

  x_vec = np.array ( ( \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.50E+00, \
     0.55E+00, \
     0.60E+00, \
     0.65E+00, \
     0.70E+00, \
     0.75E+00, \
     0.80E+00, \
     0.85E+00, \
     0.90E+00, \
     0.95E+00, \
     1.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, f

def legendre_shifted_polynomial_values_test ( ):

#*****************************************************************************80
#
## legendre_shifted_polynomial_values_test() tests legendre_shifted_polynomial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 March 2016
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'legendre_shifted_polynomial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  legendre_shifted_polynomial_values stores values of the shifted Legendre polynomials.' )
  print ( '' )
  print ( '      N            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, f = legendre_shifted_polynomial_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12g  %24.16g' % ( n, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'legendre_shifted_polynomial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def lerch_values ( n_data ):

#*****************************************************************************80
#
## lerch_values returns some values of the Lerch transcendent function.
#
#  Discussion:
#
#    The Lerch function is defined as
#
#      Phi(z,s,a) = Sum ( 0 <= k < Infinity ) z^k / ( a + k )^s
#
#    omitting any terms with ( a + k ) = 0.
#
#    In Mathematica, the function can be evaluated by:
#
#      LerchPhi[z,s,a]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real Z, the parameters of the function.
#
#    integer S, the parameters of the function.
#
#    real A, the parameters of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 12

  a_vec = np.array ( ( \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     2.0E+00, \
     2.0E+00, \
     2.0E+00, \
     3.0E+00, \
     3.0E+00, \
     3.0E+00 ))

  f_vec = np.array ( ( \
     0.1644934066848226E+01, \
     0.1202056903159594E+01, \
     0.1000994575127818E+01, \
     0.1164481052930025E+01, \
     0.1074426387216080E+01, \
     0.1000492641212014E+01, \
     0.2959190697935714E+00, \
     0.1394507503935608E+00, \
     0.9823175058446061E-03, \
     0.1177910993911311E+00, \
     0.3868447922298962E-01, \
     0.1703149614186634E-04 ))

  s_vec = np.array ( ( \
     2, 3, 10, \
     2, 3, 10, \
     2, 3, 10, \
     2, 3, 10 ))

  z_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.3333333333333333E+00, \
     0.3333333333333333E+00, \
     0.3333333333333333E+00, \
     0.1000000000000000E+00, \
     0.1000000000000000E+00, \
     0.1000000000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    z = 0.0
    s = 0
    a = 0.0
    f = 0.0
  else:
    z = z_vec[n_data]
    s = s_vec[n_data]
    a = a_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, z, s, a, f

def lerch_values_test ( ):

#*****************************************************************************80
#
## lerch_values_test() tests lerch_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'lerch_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  lerch_values stores values of the Lerch function.' )
  print ( '' )
  print ( '        Z            S        A               F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, z, s, a, f = lerch_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %6d  %12f  %24.16f' % ( z, s, a, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'lerch_values_test:' )
  print ( '  Normal end of execution.' )
  return

def lobachevsky_values ( n_data ):

#*****************************************************************************80
#
## lobachevsky_values returns some values of the Lobachevsky function.
#
#  Discussion:
#
#    The function is defined by:
#
#      LOBACHEVSKY(x) = Integral ( 0 <= t <= x ) -ln ( abs ( cos ( t ) ) dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
     0.12417639065161393857E-08, \
     0.79473344770001088225E-07, \
     0.50867598186208834198E-05, \
     0.32603097901207200319E-03, \
     0.21380536815408214419E-01, \
     0.18753816902083824050E+00, \
     0.83051199971883645115E+00, \
     0.18854362426679034904E+01, \
     0.21315988986516411053E+01, \
     0.21771120185613427221E+01, \
     0.22921027921896650849E+01, \
     0.39137195028784495586E+01, \
     0.43513563983836427904E+01, \
     0.44200644968478185898E+01, \
     0.65656013133623829156E+01, \
     0.10825504661504599479E+02, \
     0.13365512855474227325E+02, \
     0.21131002685639959927E+02, \
     0.34838236589449117389E+02, \
     0.69657062437837394278E+02 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0078125000E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       5.0000000000E+00, \
       6.0000000000E+00, \
       7.0000000000E+00, \
      10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00, \
     100.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def lobachevsky_values_test ( ):

#*****************************************************************************80
#
## lobachevsky_values_test() tests lobachevsky_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'lobachevsky_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  lobachevsky_values stores values of the LOBACHEVSKY function.' )
  print ( '' )
  print ( '      X         LOBACHEVSKY(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = lobachevsky_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'lobachevsky_values_test:' )
  print ( '  Normal end of execution.' )
  return

def lobatto_polynomial_derivatives ( n_data ):

#*****************************************************************************80
#
## lobatto_polynomial_derivatives: derivatives of completed Lobatto polynomials.
#
#  Discussion:
#
#    In Mathematica, the completed Lobatto polynomial can be evaluated by:
#
#      n * LegendreP [ n - 1, x ] - n * x * LegendreP [ n, x ]
#
#    The derivative is:
#
#        n * D[LegendreP [ n - 1, x ], {x} ] 
#      - n * LegendreP [ n, x ] 
#      - n * x * D[LegendreP [ n, x ], {x}]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 November 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 31;

  fx_vec = np.array ( ( \
     -0.5, \
      2.437500000000000, \
      4.031250000000000, \
     -3.154296875000000, \
    -10.19165039062500, \
     -1.019622802734375, \
     15.67544555664063, \
     10.97668933868408, \
    -15.91419786214828, \
    -24.33202382177114, \
     12.00000000000000, \
      5.670000000000000, \
      0.9600000000000000, \
     -2.310000000000000, \
     -4.320000000000000, \
     -5.250000000000000, \
     -5.280000000000000, \
     -4.590000000000000, \
     -3.360000000000000, \
     -1.770000000000000, \
      0.0, \
      1.770000000000000, \
      3.360000000000000, \
      4.590000000000000, \
      5.280000000000000, \
      5.250000000000000, \
      4.320000000000000, \
      2.310000000000000, \
     -0.9600000000000000, \
     -5.670000000000000, \
    -12.00000000000000 ))

  n_vec = np.array ( ( \
     1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3 ))

  x_vec = np.array ( ( \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
   -1.00, \
   -0.90, \
   -0.80, \
   -0.70, \
   -0.60, \
   -0.50, \
   -0.40, \
   -0.30, \
   -0.20, \
   -0.10, \
    0.00, \
    0.10, \
    0.20, \
    0.30, \
    0.40, \
    0.50, \
    0.60, \
    0.70, \
    0.80, \
    0.90, \
    1.00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    fx = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, fx

def lobatto_polynomial_derivatives_test ( ):

#*****************************************************************************80
#
## lobatto_polynomial_derivatives_test() tests lobatto_polynomial_derivatives.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 November 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'lobatto_polynomial_derivatives_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  lobatto_polynomial_derivatives stores derivatives of' )
  print ( '  the completed Lobatto polynomials.' )
  print ( '' )
  print ( '     N    X            Lo\'(N)(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, fx = lobatto_polynomial_derivatives ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4d  %12f  %24.16f' % (  n, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'lobatto_polynomial_derivatives_test:' )
  print ( '  Normal end of execution.' )
  return

def lobatto_polynomial_values ( n_data ):

#*****************************************************************************80
#
## lobatto_polynomial_values returns values of the completed Lobatto polynomials.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      n * LegendreP [ n - 1, x ] - n * x * LegendreP [ n, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    02 May 2013
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 31

  fx_vec = np.array ( ( \
    0.9375000000000000, \
    0.7031250000000000, \
   -0.9667968750000000, \
   -1.501464843750000, \
    0.3639221191406250, \
    2.001914978027344, \
    0.6597948074340820, \
   -1.934441328048706, \
   -1.769941113889217, \
    1.215243665501475, \
    0.000000000000000, \
    0.8692500000000000, \
    1.188000000000000, \
    1.109250000000000, \
    0.7680000000000000, \
    0.2812500000000000, \
   -0.2520000000000000, \
   -0.7507500000000000, \
   -1.152000000000000, \
   -1.410750000000000, \
   -1.500000000000000, \
   -1.410750000000000, \
   -1.152000000000000, \
   -0.7507500000000000, \
   -0.2520000000000000, \
    0.2812500000000000, \
    0.7680000000000000, \
    1.109250000000000, \
    1.188000000000000, \
    0.8692500000000000, \
    0.000000000000000 ) )

  n_vec = np.array ( ( \
     1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3 ) )

  x_vec = np.array ( ( \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
    0.25, \
   -1.00, \
   -0.90, \
   -0.80, \
   -0.70, \
   -0.60, \
   -0.50, \
   -0.40, \
   -0.30, \
   -0.20, \
   -0.10, \
    0.00, \
    0.10, \
    0.20, \
    0.30, \
    0.40, \
    0.50, \
    0.60, \
    0.70, \
    0.80, \
    0.90, \
    1.00 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    fx = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, fx

def lobatto_polynomial_values_test ( ):

#*****************************************************************************80
#
## lobatto_polynomial_values_test() tests lobatto_polynomial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 November 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'lobatto_polynomial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  lobatto_polynomial_values stores values of' )
  print ( '  the completed Lobatto polynomials.' )
  print ( '' )
  print ( '     N    X            Lo(N)(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    [ n_data, n, x, fx ] = lobatto_polynomial_values ( n_data );

    if ( n_data == 0 ):
      break

    print ( '  %4d  %12f  %24.16f' % (  n, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'lobatto_polynomial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def log10_values ( n_data ):

#*****************************************************************************80
#
## log10_values returns some values of the logarithm 10 function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      log10[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
   -5.0000000000000000000, \
   -2.0000000000000000000, \
   -1.0000000000000000000, \
   -0.69897000433601880479, \
   -0.52287874528033756270, \
   -0.39794000867203760957, \
   -0.30102999566398119521, \
   -0.22184874961635636749, \
   -0.15490195998574316929, \
   -0.096910013008056414359, \
   -0.045757490560675125410, \
    0.000000000000000000000, \
    0.30102999566398119521, \
    0.47712125471966243730, \
    0.49714987269413385435, \
    0.69897000433601880479, \
    1.0000000000000000000, \
    1.3010299956639811952, \
    2.0000000000000000000, \
    8.0915149771692704475 ))

  x_vec = np.array ( ( \
   1.0E-05,  \
   1.0E-02,  \
   0.1,  \
   0.2,  \
   0.3,  \
   0.4,  \
   0.5,  \
   0.6,  \
   0.7,  \
   0.8,  \
   0.9,  \
   1.0,  \
   2.0,  \
   3.0,  \
   3.1415926535897932385,  \
   5.0,  \
   10.0,  \
   20.0, \
   100.0, \
   123456789.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def log10_values_test ( ):

#*****************************************************************************80
#
## log10_values_test() tests log10_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'log10_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  log10_values stores values of the log10 function.' )
  print ( '' )
  print ( '      X         log10(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = log10_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'log10_values_test:' )
  print ( '  Normal end of execution.' )
  return

def logarithmic_integral_values ( n_data ):

#*****************************************************************************80
#
## logarithmic_integral_values returns values of the logarithmic integral LI(X).
#
#  Discussion:
#
#    The logarithmic integral is defined as:
#
#      LI(X) = integral ( 0 <= T <= Z ) dT / log ( T )
#
#    The principal value of the integral is taken.  There is a
#    branch cut discontinuity in the complex plane from -infinity
#    to +1.
#
#    Abramowitz and Stegun assume 1 < X.
#
#    In Mathematica, the function can be evaluated by:
#
#      LogIntegral[x]
#
#    There is a simple relationship with the exponential integral EI:
#
#      LI(X) = EI(LN(X))
#
#    The function LI(X) provides a good approximation to PI(X),
#    the number of primes less than or equal to X.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 28

  f_vec = np.array ( ( \
      0.0000000000000000E+00, \
     -0.3238978959329102E-01, \
     -0.8512648672879405E-01, \
     -0.1574149028946895E+00, \
     -0.2529494192126213E+00, \
     -0.3786710430610880E+00, \
     -0.5468514142104170E+00, \
     -0.7809468775455607E+00, \
     -0.1134011957382327E+01, \
     -0.1775800683423525E+01, \
     -0.2443622553873225E+01, \
     -0.3124190050507211E+01, \
     -0.2872935510329120E+01, \
     -0.2164282524138207E+01, \
     -0.1440351296279408E+01, \
     -0.6864884538258716E+00, \
      0.1250649863152964E+00, \
      0.1045163780117493E+01, \
      0.2967585095039051E+01, \
      0.5253718299558931E+01, \
      0.8519716463711059E+01, \
      0.1360509217709172E+02, \
      0.2193466832805100E+02, \
      0.3604254831722944E+02, \
      0.6051306533791733E+02, \
      0.1037211171690373E+03, \
      0.1810780396816945E+03, \
      0.3211144156746837E+03 ))

  x_vec = np.array ( ( \
     0.000000E+00, \
     0.100000E+00, \
     0.200000E+00, \
     0.300000E+00, \
     0.400000E+00, \
     0.500000E+00, \
     0.600000E+00, \
     0.700000E+00, \
     0.800000E+00, \
     0.900000E+00, \
     0.950000E+00, \
     0.975000E+00, \
     0.103125E+01, \
     0.106250E+01, \
     0.112500E+01, \
     0.125000E+01, \
     0.150000E+01, \
     0.200000E+01, \
     0.400000E+01, \
     0.800000E+01, \
     0.160000E+02, \
     0.320000E+02, \
     0.640000E+02, \
     0.128000E+03, \
     0.256000E+03, \
     0.512000E+03, \
     0.102400E+04, \
     0.204800E+04 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def logarithmic_integral_values_test ( ):

#*****************************************************************************80
#
## logarithmic_integral_values_test() tests logarithmic_integral_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'logarithmic_integral_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  logarithmic_integral_values stores values of the logarithmic_integral function.' )
  print ( '' )
  print ( '      X         logarithmic_integral(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = logarithmic_integral_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'logarithmic_integral_values_test:' )
  print ( '  Normal end of execution.' )
  return

def logistic_cdf_values ( n_data ):

#*****************************************************************************80
#
## logistic_cdf_values returns some values of the Logistic CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = LogisticDistribution [ mu, beta ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real MU, the mean of the distribution.
#
#    real BETA, the shape parameter of the distribution.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 12

  beta_vec = np.array ( ( \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01 ))

  f_vec = np.array ( ( \
     0.5000000000000000E+00, \
     0.8807970779778824E+00, \
     0.9820137900379084E+00, \
     0.9975273768433652E+00, \
     0.6224593312018546E+00, \
     0.5825702064623147E+00, \
     0.5621765008857981E+00, \
     0.5498339973124779E+00, \
     0.6224593312018546E+00, \
     0.5000000000000000E+00, \
     0.3775406687981454E+00, \
     0.2689414213699951E+00 ))

  mu_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01 ))

  x_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    mu = 0.0
    beta = 0.0
    x = 0.0
    f = 0.0
  else:
    mu = mu_vec[n_data]
    beta = beta_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, mu, beta, x, f

def logistic_cdf_values_test ( ):

#*****************************************************************************80
#
## logistic_cdf_values_test() tests logistic_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'logistic_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  logistic_cdf_values stores values of the LOGISTIC CDF.' )
  print ( '' )
  print ( '        Mu            Beta         X            F(Mu,Beta,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, mu, beta, x, f = logistic_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16g' % ( mu, beta, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'logistic_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def log_normal_cdf_values ( n_data ):

#*****************************************************************************80
#
## log_normal_cdf_values returns some values of the Log Normal CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = LogNormalDistribution [ mu, sigma ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real MU, the mean of the distribution.
#
#    real SIGMA, the shape parameter of the distribution.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 12

  f_vec = np.array ( ( \
     0.2275013194817921E-01, \
     0.2697049307349095E+00, \
     0.5781741008028732E+00, \
     0.7801170895122241E+00, \
     0.4390310097476894E+00, \
     0.4592655190218048E+00, \
     0.4694258497695908E+00, \
     0.4755320473858733E+00, \
     0.3261051056816658E+00, \
     0.1708799040927608E+00, \
     0.7343256357952060E-01, \
     0.2554673736161761E-01 ))

  mu_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01 ))

  sigma_vec = np.array ( ( \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01 ))

  x_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    mu = 0.0
    sigma = 0.0
    x = 0.0
    f = 0.0
  else:
    mu = mu_vec[n_data]
    sigma = sigma_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, mu, sigma, x, f

def log_normal_cdf_values_test ( ):

#*****************************************************************************80
#
## log_normal_cdf_values_test() tests log_normal_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'log_normal_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  log_normal_cdf_values stores values of the log_NORMAL CDF.' )
  print ( '' )
  print ( '      Mu        Sigma      X        F(Mu,Sigma,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, mu, sigma, x, f = log_normal_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16g' % ( mu, sigma, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'log_normal_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def log_series_cdf_values ( n_data ):

#*****************************************************************************80
#
## log_series_cdf_values returns some values of the log series CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`DiscreteDistributions`]
#      dist = LogSeriesDistribution [ t ]
#      CDF [ dist, n ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real T, the parameter of the function.
#
#    integer N, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 29

  f_vec = np.array ( ( \
     0.9491221581029903E+00, \
     0.9433541128559735E+00, \
     0.9361094611773272E+00, \
     0.9267370278044118E+00, \
     0.9141358246245129E+00, \
     0.8962840235449100E+00, \
     0.8690148741955517E+00, \
     0.8221011541254772E+00, \
     0.7213475204444817E+00, \
     0.6068261510845583E+00, \
     0.5410106403333613E+00, \
     0.4970679476476894E+00, \
     0.4650921887927060E+00, \
     0.4404842934597863E+00, \
     0.4207860535926143E+00, \
     0.4045507673897055E+00, \
     0.3908650337129266E+00, \
     0.2149757685421097E+00, \
     0.0000000000000000E+00, \
     0.2149757685421097E+00, \
     0.3213887739704539E+00, \
     0.3916213575531612E+00, \
     0.4437690508633213E+00, \
     0.4850700239649681E+00, \
     0.5191433267738267E+00, \
     0.5480569580144867E+00, \
     0.5731033910767085E+00, \
     0.5951442521714636E+00, \
     0.6147826594068904E+00 ))

  n_vec = np.array ( ( \
     1, 1, 1, 1, 1, \
     1, 1, 1, 1, 1, \
     1, 1, 1, 1, 1, \
     1, 1, 1, 0, 1, \
     2, 3, 4, 5, 6, \
     7, 8, 9, 10 ))

  t_vec = np.array ( ( \
     0.1000000000000000E+00, \
     0.1111111111111111E+00, \
     0.1250000000000000E+00, \
     0.1428571428571429E+00, \
     0.1666666666666667E+00, \
     0.2000000000000000E+00, \
     0.2500000000000000E+00, \
     0.3333333333333333E+00, \
     0.5000000000000000E+00, \
     0.6666666666666667E+00, \
     0.7500000000000000E+00, \
     0.8000000000000000E+00, \
     0.8333333333333333E+00, \
     0.8571485714857149E+00, \
     0.8750000000000000E+00, \
     0.8888888888888889E+00, \
     0.9000000000000000E+00, \
     0.9900000000000000E+00, \
     0.9900000000000000E+00, \
     0.9900000000000000E+00, \
     0.9900000000000000E+00, \
     0.9900000000000000E+00, \
     0.9900000000000000E+00, \
     0.9900000000000000E+00, \
     0.9900000000000000E+00, \
     0.9900000000000000E+00, \
     0.9900000000000000E+00, \
     0.9900000000000000E+00, \
     0.9900000000000000E+00  ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    t = 0.0
    n = 0
    f = 0.0
  else:
    t = t_vec[n_data]
    n = n_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, t, n, f

def log_series_cdf_values_test ( ):

#*****************************************************************************80
#
## log_series_cdf_values_test() tests log_series_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'log_series_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  log_series_cdf_values stores values of the log_series_cdf function.' )
  print ( '' )
  print ( '      T       N         log_series_cdf(T,N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, t, n, f = log_series_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %6d  %24.16f' % ( t, n, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'log_series_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def log_values ( n_data ):

#*****************************************************************************80
#
## log_values returns some values of the logarithm function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Log[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
    -11.512925464970228420E+00, \
     -4.6051701859880913680E+00, \
     -2.3025850929940456840E+00, \
     -1.6094379124341003746E+00, \
     -1.2039728043259359926E+00, \
     -0.91629073187415506518E+00, \
     -0.69314718055994530942E+00, \
     -0.51082562376599068321E+00, \
     -0.35667494393873237891E+00, \
     -0.22314355131420975577E+00, \
     -0.10536051565782630123E+00, \
      0.00000000000000000000E+00, \
      0.69314718055994530942E+00, \
      1.0986122886681096914E+00, \
      1.1447298858494001741E+00, \
      1.6094379124341003746E+00, \
      2.3025850929940456840E+00, \
      2.9957322735539909934E+00, \
      4.6051701859880913680E+00, \
      18.631401766168018033E+00 ))

  x_vec = np.array ( ( \
   1.0E-05,  \
   1.0E-02,  \
   0.1,  \
   0.2,  \
   0.3,  \
   0.4,  \
   0.5,  \
   0.6,  \
   0.7,  \
   0.8,  \
   0.9,  \
   1.0,  \
   2.0,  \
   3.0,  \
   3.1415926535897932385,  \
   5.0,  \
   10.0,  \
   20.0, \
   100.0, \
   123456789.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def log_values_test ( ):

#*****************************************************************************80
#
## log_values_test() tests log_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'log_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  log_values stores values of the LOG function.' )
  print ( '' )
  print ( '      X         LOG(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = log_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'log_values_test:' )
  print ( '  Normal end of execution.' )
  return

def lp_values ( n_data ):

#*****************************************************************************80
#
## lp_values returns values of the Legendre polynomials P(n,x).
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 October 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    int N, the order of the function.
#
#    double X, the point where the function is evaluated.
#
#    double FX, the value of the function.
#
  import numpy as np

  n_max = 22

  fx_vec = np.array ( [
      0.1000000000000000E+01,
      0.2500000000000000E+00,
     -0.4062500000000000E+00,
     -0.3359375000000000E+00,
      0.1577148437500000E+00,
      0.3397216796875000E+00,
      0.2427673339843750E-01,
     -0.2799186706542969E+00,
     -0.1524540185928345E+00,
      0.1768244206905365E+00,
      0.2212002165615559E+00,
      0.0000000000000000E+00,
     -0.1475000000000000E+00,
     -0.2800000000000000E+00,
     -0.3825000000000000E+00,
     -0.4400000000000000E+00,
     -0.4375000000000000E+00,
     -0.3600000000000000E+00,
     -0.1925000000000000E+00,
      0.8000000000000000E-01,
      0.4725000000000000E+00,
      0.1000000000000000E+01 ], dtype = np.float64 )

  n_vec = np.array ( [
     0,  1,  2,
     3,  4,  5,
     6,  7,  8,
     9, 10,  3,
     3,  3,  3,
     3,  3,  3,
     3,  3,  3,
     3 ], dtype = np.int32 )

  x_vec = np.array ( [
     0.25E+00,
     0.25E+00,
     0.25E+00,
     0.25E+00,
     0.25E+00,
     0.25E+00,
     0.25E+00,
     0.25E+00,
     0.25E+00,
     0.25E+00,
     0.25E+00,
     0.00E+00,
     0.10E+00,
     0.20E+00,
     0.30E+00,
     0.40E+00,
     0.50E+00,
     0.60E+00,
     0.70E+00,
     0.80E+00,
     0.90E+00,
     1.00E+00 ], dtype = np.float64 )

  if ( n_data < 0 ):
    n_data = 0

  n_data = n_data + 1

  if ( n_max < n_data ):
    n_data = 0
    n = 0
    x = 0.0
    fx = 0.0
  else:
    n = n_vec[n_data-1]
    x = x_vec[n_data-1]
    fx = fx_vec[n_data-1]

  return n_data, n, x, fx

def lp_values_test ( ):

#*****************************************************************************80
#
## lp_values_test() tests lp_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 October 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'lp_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  lp_values stores values of' )
  print ( '  the Legendre polynomial P(o,x).' )
  print ( '' )
  print ( '                        Tabulated' )
  print ( '     O        X           L(O,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, o, x, fx = lp_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4d  %12.8f  %24.16g' % ( o, x, fx ) )
#
#  Terminate.
#-
  print ( '' )
  print ( 'lp_values_test:' )
  print ( '  Normal end of execution.' )
  return

def mertens_values ( n_data ):

#*****************************************************************************80
#
## mertens_values returns some values of the Mertens function.
#
#  Discussion:
#
#    The Mertens function M(N) is the sum from 1 to N of the Moebius
#    function MU.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    M Deleglise, J Rivat,
#    Computing the Summation of the Moebius Function,
#    Experimental Mathematics,
#    Volume 5, 1996, pages 291-295.
#
#    Eric Weisstein,
#    CRC Concise Encyclopedia of Mathematics,
#    CRC Press, 2002,
#    Second edition,
#    ISBN: 1584883472,
#    LC: QA5.W45.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the argument of the Mertens function.
#
#    integer C, the value of the Mertens function.
#
  import numpy as np

  n_max = 15

  c_vec = np.array ( ( \
      1,   0,  -1,   -1,  -2,  -1,  -2,  -2,   -2,  -1, \
     -2,  -2,   1,    2, -23 ))

  n_vec = np.array ( ( \
      1,   2,   3,   4,   5,   6,   7,   8,   9,  10, \
     11,  12,  100, 1000, 10000 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    c = 0
  else:
    n = n_vec[n_data]
    c = c_vec[n_data]
    n_data = n_data + 1

  return n_data, n, c

def mertens_values_test ( ):

#*****************************************************************************80
#
## mertens_values_test() tests mertens_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'mertens_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  mertens_values stores values of the MERTENS function.' )
  print ( '' )
  print ( '             N    MERTENS(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, c = mertens_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12d' % ( n, c ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'mertens_values_test:' )
  print ( '  Normal end of execution.' )
  return

def mittag_leffler_eab_values ( n_data ):

#*****************************************************************************80
#
## mittag_leffler_eab_values: values of two-parameter Mittag Leffler function.
#
#  Discussion:
#
#    E(alpha,beta;z) = sum ( 0 <= k < oo ) z^k / Gamma ( alpha * k + beta )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2017
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, B, the parameters.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 18

  a_vec = np.array ( ( \
    1.0, \
    1.0, \
    1.0, \
    1.5, \
    1.5, \
    1.5, \
    3.0, \
    3.0, \
    3.0, \
    1.5, \
    1.5, \
    1.5, \
    1.5, \
    2.0, \
    2.5, \
    2.0, \
    2.0, \
    2.0 ))

  b_vec = np.array ( (\
    0.0, \
    2.5, \
    5.0, \
    0.0, \
    5.0, \
   10.0, \
    1.0, \
    1.1, \
    1.2, \
    5.0, \
   10.0, \
   15.0, \
    5.0, \
    5.0, \
    5.0, \
    1.0, \
    2.0, \
    3.0 ))

  fx_vec = np.array ( ( \
    -0.1947001957678512, \
     0.6821152851737027, \
     0.3966713294631294E-01, \
    -0.7783327874361643, \
     0.376189576668972E-01, \
     0.2653864659692168E-05, \
     0.5521129475536116, \
     0.6561318862220054, \
     0.7417555514147703, \
     0.283627999653323E-01, \
     0.2382766080122566E-05, \
     0.1057337628882522E-10, \
     0.6524069073077504E-01, \
     0.4926693884523065E-01, \
     0.4440848516337653E-01, \
     0.217818355660857E+01, \
     0.1368298872008591E+01, \
     0.5890917783042855 ))

  x_vec = np.array ( ( \
      -0.25, \
      -0.25, \
      -0.25, \
      -1.25, \
      -1.25, \
      -1.25, \
      -2.75, \
      -2.75, \
      -2.75, \
      -5.0, \
      -5.0, \
      -5.0, \
       5.0, \
       5.0, \
       5.0, \
       2.0, \
       2.0, \
       2.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    b = 0.0
    x = 0.0
    fx = 0.0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, x, fx

def mittag_leffler_eab_values_test ( ):

#*****************************************************************************80
#
## mittag_leffler_eab_values_test demonstrates mittag_leffler_eab_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    03 February 2017
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'mittag_leffler_eab_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  mittag_leffler_eab_values stores values of' )
  print ( '  the Mittag-Leffler three parameter function E(A;X).' )
  print ( '' )
  print ( '        A             B             X               E(A,B;X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, x, fx = mittag_leffler_eab_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16g' % ( a, b, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'mittag_leffler_eab_values_test:' )
  print ( '  Normal end of execution.' )
  return

def mittag_leffler_ea_values ( n_data ):

#*****************************************************************************80
#
## mittag_leffler_ea_values: values of one-parameter Mittag Leffler function.
#
#  Discussion:
#
#    E(alpha;z) = sum ( 0 <= k < oo ) z^k / Gamma ( alpha * k + 1 )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    02 February 2017
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, the parameter.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 25

  a_vec = np.array ( ( \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     1.75E+00, \
     1.75E+00, \
     1.75E+00, \
     1.75E+00, \
     1.75E+00, \
     2.25E+00, \
     2.25E+00, \
     2.25E+00, \
     2.25E+00, \
     2.25E+00, \
     1.0E+00, \
     2.0E+00, \
     3.0E+00, \
     4.0E+00, \
     5.0E+00, \
     6.0E+00, \
     7.0E+00, \
     8.0E+00, \
     9.0E+00, \
     10.0E+00 ))

  fx_vec = np.array ( ( \
      1.0, \
      0.2525646348870172, \
      0.1427989464258737, \
      0.994231091392936E-01, \
      0.762370352397216E-01, \
      1.0, \
     -0.2579027070618285, \
      0.2716853059670252, \
      0.1846579916604009E-01, \
     -0.139707389642194, \
      1.0, \
     -0.1022121843823497E+01, \
      0.1860844522589611E+01, \
      0.2644615445996891E+01, \
      0.7762512036620307, \
      0.6737946999045729E-02, \
     -0.6172728764571668, \
      0.2010457248089053, \
      0.7922864454196143, \
      0.958340222567225, \
      0.993055607747429, \
      0.999007936794713, \
      0.999875992064687, \
      0.999986221340384, \
      0.999998622134038 ))

  x_vec = np.array ( ( \
       0.0, \
      -2.5, \
      -5.0, \
      -7.5, \
     -10.0, \
       0.0, \
     -12.5, \
     -25.0, \
     -37.5, \
     -50.0, \
       0.0, \
     -25.0, \
     -50.0, \
     -75.0, \
    -100.0, \
      -5.0, \
      -5.0, \
      -5.0, \
      -5.0, \
      -5.0, \
      -5.0, \
      -5.0, \
      -5.0, \
      -5.0, \
      -5.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    x = 0.0
    fx = 0.0
  else:
    a = a_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, a, x, fx

def mittag_leffler_ea_values_test ( ):

#*****************************************************************************80
#
## mittag_leffler_ea_values_test demonstrates mittag_leffler_ea_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    02 February 2017
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'mittag_leffler_ea_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  mittag_leffler_ea_values stores values of' )
  print ( '  the Mittag-Leffler one parameter function E(A;X).' )
  print ( '' )
  print ( '        A             X               E(A;X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, x, fx = mittag_leffler_ea_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( a, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'mittag_leffler_ea_values_test:' )
  print ( '  Normal end of execution.' )
  return

def moebius_values ( n_data ):

#*****************************************************************************80
#
## moebius_values returns some values of the Moebius function.
#
#  Discussion:
#
#    MU(N) is defined as follows:
#
#      MU(N) = 1 if N = 1;
#              0 if N is divisible by the square of a prime;
#              (-1)^K, if N is the product of K distinct primes.
#
#    In Mathematica, the function can be evaluated by:
#
#      MoebiusMu[n]
#
#  First values:
#
#     N  MU(N)
#
#     1    1
#     2   -1
#     3   -1
#     4    0
#     5   -1
#     6    1
#     7   -1
#     8    0
#     9    0
#    10    1
#    11   -1
#    12    0
#    13   -1
#    14    1
#    15    1
#    16    0
#    17   -1
#    18    0
#    19   -1
#    20    0
#
#    As special cases, MU(N) is -1 if N is a prime, and MU(N) is 0
#    if N is a square, cube, etc.
#
#  Formula:
#
#    The Moebius function is related to Euler's totient function:
#
#      PHI(N) = Sum ( D divides N ) MU(D) * ( N / D ).
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the argument of the Moebius function.
#
#    integer C, the value of the Moebius function.
#
  import numpy as np

  n_max = 20

  c_vec = np.array ( ( \
      1,  -1,  -1,   0,  -1,   1,  -1,   0,   0,   1, \
     -1,   0,  -1,   1,   1,   0,  -1,   0,  -1,   0 ))

  n_vec = np.array ( ( \
      1,   2,   3,   4,   5,   6,   7,   8,   9,  10, \
     11,  12,  13,  14,  15,  16,  17,  18,  19,  20 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    c = 0
  else:
    n = n_vec[n_data]
    c = c_vec[n_data]
    n_data = n_data + 1

  return n_data, n, c

def moebius_values_test ( ):

#*****************************************************************************80
#
## moebius_values_test() tests moebius_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'moebius_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  moebius_values stores values of the MOEBIUS function.' )
  print ( '' )
  print ( '             N    MOEBIUS(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, c = moebius_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12d' % ( n, c ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'moebius_values_test:' )
  print ( '  Normal end of execution.' )
  return

def multinomial_pdf_sizes ( n_data ):

#*****************************************************************************80
#
## multinomial_pdf_sizes returns sizes of some multinomial PDF data.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer M, the size of the given problem.
#
  import numpy as np

  n_max = 10

  m_vec = np.array ( ( \
     2, 2, 2, 3, 5, \
     5, 5, 5, 5, 5 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    m = 0
  else:
    m = m_vec[n_data]
    n_data = n_data + 1

  return n_data, m

def multinomial_pdf_values ( n_data, m ):

#*****************************************************************************80
#
## multinomial_pdf_values returns some values of the multinomial PDF.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer M, the number of outcomes.
#
#    int N, the number of trials.
#
#    real P(M), the probability of each outcome on one trial.
#
#    integer X(M), the number of times each outcome occurred in
#    N trials.
#
#    real PDF, the probability of X.
#
  import numpy as np

  n_max = 10

  n_vec = np.array ( ( \
     3, 4, 3, 3, 3, \
     3, 3, 3, 3, 3 ))

  p_cell = ( \
    ( 0.7, 0.3 ), \
    ( 0.7, 0.3 ), \
    ( 0.5, 0.5 ), \
    ( 0.6, 0.0, 0.4 ), \
    ( 0.6, 0.1, 0.1, 0.1, 0.1 ), \
    ( 0.6, 0.1, 0.1, 0.1, 0.1 ), \
    ( 0.6, 0.1, 0.1, 0.1, 0.1 ), \
    ( 0.6, 0.1, 0.1, 0.1, 0.1 ), \
    ( 0.6, 0.1, 0.1, 0.1, 0.1 ), \
    ( 0.6, 0.1, 0.1, 0.1, 0.1 ) )

  x_cell = ( \
    ( 2, 1 ), \
    ( 2, 2 ), \
    ( 2, 1 ), \
    ( 1, 1, 1 ), \
    ( 3, 0, 0, 0, 0 ), \
    ( 2, 1, 0, 0, 0 ), \
    ( 1, 0, 2, 0, 0 ), \
    ( 1, 0, 0, 1, 1 ), \
    ( 0, 0, 0, 3, 0 ), \
    ( 0, 1, 1, 1, 0 ) )

  pdf_vec = np.array ( ( \
    0.441, \
    0.2646, \
    0.375, \
    0.0, \
    0.216, \
    0.108, \
    0.018, \
    0.036, \
    0.001, \
    0.006 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    p = []
    x = []
    pdf = 0.0
  else:
    n = n_vec[n_data]
    p = p_cell[n_data]
    x = x_cell[n_data]
    pdf = pdf_vec[n_data]
    n_data = n_data + 1

  return n_data, n, p, x, pdf

def multinomial_pdf_values_test ( ):

#*****************************************************************************80
#
##_multinomial_pdf_values_test() tests multinomial_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    31 July 2015
#
#  Author:
#
#    John Burkardt.
#
  import platform

  print ( '' )
  print ( 'multinomial_pdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  multinomial_pdf_values resturns some values of the multinomial PDF.' )
  print ( '  Given M possible outcomes on a single trial,' )
  print ( '  with each outcome having probability P,' )
  print ( '  PDF is the probability that after N trials,' )
  print ( '  outcome I occurred X(I) times.' )
  print ( '' )
  print ( '     N     M     I      P        X        PDF()' )
  
  n_data1 = 0
  n_data2 = 0

  while ( True ):

    n_data1, m            = multinomial_pdf_sizes ( n_data1 )
    n_data2, n, p, x, pdf = multinomial_pdf_values ( n_data2, m )

    if ( n_data1 == 0 ):
      break

    print ( '' )
    for i in range ( 0, m ):
      print ( '              %4d  %8.4f  %4d' % ( i, p[i], x[i] ) )
    print ( '  %4d  %4d                        %14.6g' % ( n, m, pdf ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'multinomial_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def negative_binomial_cdf_values ( n_data ):

#*****************************************************************************80
#
## negative_binomial_cdf_values returns values of the negative binomial CDF.
#
#  Discussion:
#
#    Assume that a coin has a probability P of coming up heads on
#    any one trial.  Suppose that we plan to flip the coin until we
#    achieve a total of S heads.  If we let F represent the number of
#    tails that occur in this process, then the value of F satisfies
#    a negative binomial PDF:
#
#      PDF(F,S,P) = Choose ( F from F+S-1 ) * P^S * (1-P)^F
#
#    The negative binomial CDF is the probability that there are F or
#    fewer failures upon the attainment of the S-th success.  Thus,
#
#      CDF(F,S,P) = sum ( 0 <= G <= F ) PDF(G,S,P)
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`DiscreteDistributions`]
#      dist = NegativeBinomialDistribution [ s, p ]
#      CDF [ dist, f ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    F C Powell,
#    Statistical Tables for Sociology, Biology and Physical Sciences,
#    Cambridge University Press, 1982.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer F, the maximum number of failures.
#
#    integer S, the number of successes.
#
#    real P, the probability of a success on one trial.
#
#    real CDF, the probability of at most F failures 
#    before the S-th success.
#
  import numpy as np

  n_max = 27

  cdf_vec = np.array ( ( \
     0.6367187500000000E+00, \
     0.3632812500000000E+00, \
     0.1445312500000000E+00, \
     0.5000000000000000E+00, \
     0.2265625000000000E+00, \
     0.6250000000000000E-01, \
     0.3437500000000000E+00, \
     0.1093750000000000E+00, \
     0.1562500000000000E-01, \
     0.1792000000000000E+00, \
     0.4096000000000000E-01, \
     0.4096000000000000E-02, \
     0.7047000000000000E-01, \
     0.1093500000000000E-01, \
     0.7290000000000000E-03, \
     0.9861587127990000E+00, \
     0.9149749500510000E+00, \
     0.7471846521450000E+00, \
     0.8499053647030009E+00, \
     0.5497160941090026E+00, \
     0.2662040052146710E+00, \
     0.6513215599000000E+00, \
     0.2639010709000000E+00, \
     0.7019082640000000E-01, \
     0.1000000000000000E+01, \
     0.1990000000000000E-01, \
     0.1000000000000000E-03 ))

  f_vec = np.array ( ( \
     4,  3,  2, \
     3,  2,  1, \
     2,  1,  0, \
     2,  1,  0, \
     2,  1,  0, \
    11, 10,  9, \
    17, 16, 15, \
     9,  8,  7, \
     2,  1,  0 ))

  p_vec = np.array ( ( \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.40E+00, \
     0.40E+00, \
     0.40E+00, \
     0.30E+00, \
     0.30E+00, \
     0.30E+00, \
     0.30E+00, \
     0.30E+00, \
     0.30E+00, \
     0.10E+00, \
     0.10E+00, \
     0.10E+00, \
     0.10E+00, \
     0.10E+00, \
     0.10E+00, \
     0.10E-01, \
     0.10E-01, \
     0.10E-01 ))

  s_vec = np.array ( ( \
    4, 5, 6, \
    4, 5, 6, \
    4, 5, 6, \
    4, 5, 6, \
    4, 5, 6, \
    1, 2, 3, \
    1, 2, 3, \
    1, 2, 3, \
    0, 1, 2 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    f = 0
    s = 0
    p = 0.0
    cdf = 0.0
  else:
    f = f_vec[n_data]
    s = s_vec[n_data]
    p = p_vec[n_data]
    cdf = cdf_vec[n_data]
    n_data = n_data + 1

  return n_data, f, s, p, cdf

def negative_binomial_cdf_values_test ( ):

#*****************************************************************************80
#
## negative_binomial_cdf_values_test() tests negative_binomial_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'negative_binomial_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  negative_binomial_cdf_values stores values of the unit normal CDF.' )
  print ( '' )
  print ( '       F       S        P            CDF()' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, f, s, p, cdf = negative_binomial_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %6d  %12f  %24.16f' % ( f, s, p, cdf ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'negative_binomial_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def nine_j_values ( n_data ):

#*****************************************************************************80
#
## nine_j_values returns some values of the Wigner 9J function.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real J1, J2, J3, J4, J5, J6, J7, J8, J9,
#    the arguments of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 9

  f_vec = np.array ( ( \
     0.0004270039294528318, \
    -0.001228915451058514, \
    -0.0001944260688400887, \
     0.003338419923885592, \
    -0.0007958936865080434, \
    -0.004338208690251972, \
     0.05379143536399187, \
     0.006211299937499411, \
     0.03042903097250921 ))
  j1_vec = np.array ( ( \
    1.0, \
    1.5, \
    2.0, \
    1.0, \
    1.5, \
    2.0, \
    0.5, \
    1.0, \
    1.5  ))
  j2_vec = np.array ( ( \
    8.0, \
    8.0, \
    8.0, \
    3.0, \
    3.0, \
    3.0, \
    0.5, \
    0.5, \
    0.5  ))
  j3_vec = np.array ( ( \
    7.0, \
    7.0, \
    7.0, \
    2.0, \
    2.0, \
    2.0, \
    1.0, \
    1.0, \
    1.0 ))
  j4_vec = np.array ( ( \
    6.5, \
    6.5, \
    6.5, \
    4.0, \
    4.0, \
    4.0, \
    2.0, \
    2.0, \
    2.0 ))
  j5_vec = np.array ( ( \
    7.5, \
    7.5, \
    7.5, \
    1.5, \
    1.5, \
    1.5, \
    1.0, \
    1.0, \
    1.0 ))
  j6_vec = np.array ( ( \
    7.5, \
    7.5, \
    7.5, \
    3.0, \
    3.0, \
    3.0, \
    1.5, \
    1.5, \
    1.5 ))
  j7_vec = np.array ( ( \
    6.0, \
    6.0, \
    6.0, \
    3.5, \
    3.5, \
    3.5, \
    1.5, \
    1.5, \
    1.5 ))
  j8_vec = np.array ( ( \
    10.0, \
    10.0, \
    10.0, \
     2.0, \
     2.0, \
     2.0, \
     0.5, \
     0.5, \
     0.5 ))
  j9_vec = np.array ( ( \
    6.0, \
    6.0, \
    6.0, \
    2.0, \
    2.0, \
    2.0, \
    1.5, \
    1.5, \
    1.5 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    j1 = 0.0
    j2 = 0.0
    j3 = 0.0
    j4 = 0.0
    j5 = 0.0
    j6 = 0.0
    j7 = 0.0
    j8 = 0.0
    j9 = 0.0
    f = 0.0
  else:
    j1 = j1_vec[n_data]
    j2 = j2_vec[n_data]
    j3 = j3_vec[n_data]
    j4 = j4_vec[n_data]
    j5 = j5_vec[n_data]
    j6 = j6_vec[n_data]
    j7 = j7_vec[n_data]
    j8 = j8_vec[n_data]
    j9 = j9_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, j1, j2, j3, j4, j5, j6, j7, j8, j9, f

def nine_j_values_test ( ):

#*****************************************************************************80
#
## nine_j_values_test() tests nine_j_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'nine_j_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  nine_j_values stores values of the nine_j function.' )
  print ( '' )
  print ( '    J1    J2    J3    J4    J5    J6    J7    J8    J9    nine_j(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, j1, j2, j3, j4, j5, j6, j7, j8, j9, f = nine_j_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4.1f  %4.1f  %4.1f  %4.1f  %4.1f  %4.1f  %4.1f  %4.1f  %4.1f  %24.16f' \
      % ( j1, j2, j3, j4, j5, j6, j7, j8, j9, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'nine_j_values_test:' )
  print ( '  Normal end of execution.' )
  return

def normal_01_cdf_values ( n_data ):

#*****************************************************************************80
#
## normal_01_cdf_values returns some values of the Normal 01 CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = NormalDistribution [ 0, 1 ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 17

  f_vec = np.array ( (\
     0.5000000000000000E+00, \
     0.5398278372770290E+00, \
     0.5792597094391030E+00, \
     0.6179114221889526E+00, \
     0.6554217416103242E+00, \
     0.6914624612740131E+00, \
     0.7257468822499270E+00, \
     0.7580363477769270E+00, \
     0.7881446014166033E+00, \
     0.8159398746532405E+00, \
     0.8413447460685429E+00, \
     0.9331927987311419E+00, \
     0.9772498680518208E+00, \
     0.9937903346742239E+00, \
     0.9986501019683699E+00, \
     0.9997673709209645E+00, \
     0.9999683287581669E+00 ))

  x_vec = np.array ((\
     0.0000000000000000E+00, \
     0.1000000000000000E+00, \
     0.2000000000000000E+00, \
     0.3000000000000000E+00, \
     0.4000000000000000E+00, \
     0.5000000000000000E+00, \
     0.6000000000000000E+00, \
     0.7000000000000000E+00, \
     0.8000000000000000E+00, \
     0.9000000000000000E+00, \
     0.1000000000000000E+01, \
     0.1500000000000000E+01, \
     0.2000000000000000E+01, \
     0.2500000000000000E+01, \
     0.3000000000000000E+01, \
     0.3500000000000000E+01, \
     0.4000000000000000E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def normal_01_cdf_values_test ( ):

#*****************************************************************************80
#
## normal_01_cdf_values_test() tests normal_01_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'normal_01_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  normal_01_cdf_values stores values of the unit normal CDF.' )
  print ( '' )
  print ( '      X         normal_01_cdf(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = normal_01_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'normal_01_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def normal_01_pdf_values ( n_data ):

#*****************************************************************************80
#
## normal_01_pdf_values returns some values of the Normal 01 PDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = NormalDistribution [ 0, 1 ]
#      PDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 10

  f_vec = np.array ( ( \
    0.03155059887555709, \
    0.0005094586261557538, \
    0.01235886992552887, \
    0.353192862601275, \
    0.3171212685764107, \
    0.0009653372813755943, \
    0.06083856556197816, \
    0.003066504313116445, \
    0.0005116437388114821, \
    0.2246444116615346 ))

  x_vec = np.array ( ( \
    -2.252653624140994, \
     3.650540612071437, \
     2.636073871461605, \
     0.4935635421351536, \
    -0.6775433481923101, \
    -3.471050120671749, \
    -1.939377660943641, \
    -3.120345651740235, \
    -3.649368017767143, \
     1.0717256984193 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def normal_01_pdf_values_test ( ):

#*****************************************************************************80
#
## normal_01_pdf_values_test() tests normal_01_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 July 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'normal_01_pdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  normal_01_pdf_values stores values of the unit normal PDF.' )
  print ( '' )
  print ( '      X         normal_01_pdf(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = normal_01_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'normal_01_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def normal_cdf_values ( n_data ):

#*****************************************************************************80
#
## normal_cdf_values returns some values of the Normal CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = NormalDistribution [ mu, sigma ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real MU, the mean of the distribution.
#
#    real SIGMA, the standard deviation of the distribution.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 12

  f_vec = np.array ( ( \
     0.5000000000000000E+00, \
     0.9772498680518208E+00, \
     0.9999683287581669E+00, \
     0.9999999990134124E+00, \
     0.6914624612740131E+00, \
     0.6305586598182364E+00, \
     0.5987063256829237E+00, \
     0.5792597094391030E+00, \
     0.6914624612740131E+00, \
     0.5000000000000000E+00, \
     0.3085375387259869E+00, \
     0.1586552539314571E+00 ))

  mu_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01 ))

  sigma_vec = np.array ( ( \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01 ))

  x_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    mu = 0.0
    sigma = 0.0
    x = 0.0
    f = 0.0
  else:
    mu = mu_vec[n_data]
    sigma = sigma_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, mu, sigma, x, f

def normal_cdf_values_test ( ):

#*****************************************************************************80
#
## normal_cdf_values_test() tests normal_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'normal_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  normal_cdf_values stores values of the normal CDF.' )
  print ( '' )
  print ( '      MU          SIGMA       X         normal_cdf(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, mu, sigma, x, f = normal_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16f' % ( mu, sigma, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'normal_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def normal_pdf_values ( n_data ):

#*****************************************************************************80
#
## normal_pdf_values returns some values of the Normal PDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = NormalDistribution [ mu, sigma ]
#      PDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 July 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real MU, the mean of the distribution.
#
#    real SIGMA, the standard deviation of the distribution.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 10

  f_vec = np.array ( ( \
    0.01180775937213258, \
    0.006307849174478944, \
    0.0147514774470322, \
    0.9468437743011001, \
    0.02140312299941794, \
    0.05939959967353488, \
    0.2348929157422787, \
    0.007207515678571277, \
    0.005944396897656727, \
    0.03637663165771322 ))

  mu_vec = np.array ( ( \
       -56.31634060352484, \
         12.33908855337884, \
        -48.48444152359102, \
          26.7931424604825, \
        -19.73874370047668, \
        -99.63232576831896, \
        -81.09104995766396, \
         68.16949013113364, \
        -47.93940044652702, \
        -29.67426801922078 ))

  sigma_vec = np.array ( ( \
    4.785956124893755, \
    2.13500469923221, \
    0.6387882883091059, \
    0.4024634224214489, \
    3.79790008346491, \
    4.497769898408682, \
    0.1667227687589636, \
    0.7032091872463158, \
    4.57117016420902, \
    4.132147851761006 ))

  x_vec = np.array ( ( \
  -46.85424018542929, \
    6.781057314200307, \
  -50.23282168570062, \
   26.67129012408019, \
  -12.9643468135976, \
 -103.6600156181528, \
  -80.73183222587458, \
   66.09155915000321, \
  -58.53544475210675, \
  -35.44773135435396 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    mu = 0.0
    sigma = 0.0
    x = 0.0
    f = 0.0
  else:
    mu = mu_vec[n_data]
    sigma = sigma_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, mu, sigma, x, f

def normal_pdf_values_test ( ):

#*****************************************************************************80
#
## normal_pdf_values_test() tests normal_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 July 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'normal_pdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  normal_pdf_values stores values of the normal PDF.' )
  print ( '' )
  print ( '        MU            SIGMA         X               PDF' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, mu, sigma, x, f = normal_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f  %24.16f' % ( mu, sigma, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'normal_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def omega_values ( n_data ):

#*****************************************************************************80
#
## omega_values returns some values of the OMEGA function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by
#
#      Length [ FactorInteger [ n ] ]
#
#  First values:
#
#     N   OMEGA(N)
#
#     1    0
#     2    1
#     3    1
#     4    1
#     5    1
#     6    2
#     7    1
#     8    1
#     9    1
#    10    2
#    11    1
#    12    2
#    13    1
#    14    2
#    15    2
#    16    1
#    17    1
#    18    2
#    19    1
#    20    2
#
#  Formula:
#
#    If N = 1, then
#
#      OMEGA(N) = 0
#
#    else if the prime factorization of N is
#
#      N = P1^E1 * P2^E2 * \ * PM^EM,
#
#    then
#
#      OMEGA(N) = M
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the argument of the OMEGA function.
#
#    integer C, the value of the OMEGA function.
#
  import numpy as np

  n_max = 23

  c_vec = np.array ( ( \
      0,   1,   1,   1,   1, \
      2,   1,   1,   1,   2, \
      3,   1,   4,   4,   3, \
      1,   5,   2,   2,   1, \
      6,   7,   8 ))

  n_vec = np.array ( ( \
           1, \
           2, \
           3, \
           4, \
           5, \
           6, \
           7, \
           8, \
           9, \
          10, \
          30, \
         101, \
         210, \
        1320, \
        1764, \
        2003, \
        2310, \
        2827, \
        8717, \
       12553, \
       30030, \
      510510, \
     9699690 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    c = 0
  else:
    n = n_vec[n_data]
    c = c_vec[n_data]
    n_data = n_data + 1

  return n_data, n, c

def omega_values_test ( ):

#*****************************************************************************80
#
## omega_values_test() tests omega_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'omega_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  omega_values stores values of the OMEGA function.' )
  print ( '' )
  print ( '             N    OMEGA(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, c = omega_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12d' % ( n, c ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'omega_values_test:' )
  print ( '  Normal end of execution.' )
  return

def owen_values ( n_data ):

#*****************************************************************************80
#
## owen_values returns some values of Owen's T function.
#
#  Discussion:
#
#    Owen's T function is useful for computation of the bivariate normal
#    distribution and the distribution of a skewed normal distribution.
#
#    Although it was originally formulated in terms of the bivariate
#    normal function, the function can be defined more directly as
#
#      T(H,A) = 1 / ( 2 * pi ) *
#        Integral ( 0 <= X <= A ) e^(H^2*(1+X^2)/2) / (1+X^2) dX
#
#    In Mathematica, the function can be evaluated by:
#
#      fx = 1/(2*Pi) * Integrate [ E^(-h^2*(1+x^2)/2)/(1+x^2), {x,0,a} ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Mike Patefield, David Tandy,
#    Fast and Accurate Calculation of Owen's T Function,
#    Journal of Statistical Software,
#    Volume 5, Number 5, 2000, pages 1-25.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real H, a parameter.
#
#    real A, the upper limit of the integral.
#
#    real T, the value of the function.
#
  import numpy as np

  n_max = 28

  a_vec = np.array ( ( \
    0.2500000000000000E+00, \
    0.4375000000000000E+00, \
    0.9687500000000000E+00, \
    0.0625000000000000E+00, \
    0.5000000000000000E+00, \
    0.9999975000000000E+00, \
    0.5000000000000000E+00, \
    0.1000000000000000E+01, \
    0.2000000000000000E+01, \
    0.3000000000000000E+01, \
    0.5000000000000000E+00, \
    0.1000000000000000E+01, \
    0.2000000000000000E+01, \
    0.3000000000000000E+01, \
    0.5000000000000000E+00, \
    0.1000000000000000E+01, \
    0.2000000000000000E+01, \
    0.3000000000000000E+01, \
    0.5000000000000000E+00, \
    0.1000000000000000E+01, \
    0.2000000000000000E+01, \
    0.3000000000000000E+01, \
    0.5000000000000000E+00, \
    0.1000000000000000E+01, \
    0.2000000000000000E+01, \
    0.3000000000000000E+01, \
    0.1000000000000000E+02, \
    0.1000000000000000E+03 ))

  h_vec = np.array ( ( \
    0.0625000000000000E+00, \
    6.5000000000000000E+00, \
    7.0000000000000000E+00, \
    4.7812500000000000E+00, \
    2.0000000000000000E+00, \
    1.0000000000000000E+00, \
    0.1000000000000000E+01, \
    0.1000000000000000E+01, \
    0.1000000000000000E+01, \
    0.1000000000000000E+01, \
    0.5000000000000000E+00, \
    0.5000000000000000E+00, \
    0.5000000000000000E+00, \
    0.5000000000000000E+00, \
    0.2500000000000000E+00, \
    0.2500000000000000E+00, \
    0.2500000000000000E+00, \
    0.2500000000000000E+00, \
    0.1250000000000000E+00, \
    0.1250000000000000E+00, \
    0.1250000000000000E+00, \
    0.1250000000000000E+00, \
    0.7812500000000000E-02, \
    0.7812500000000000E-02, \
    0.7812500000000000E-02, \
    0.7812500000000000E-02, \
    0.7812500000000000E-02, \
    0.7812500000000000E-02 ))

  t_vec = np.array ( ( \
    3.8911930234701366E-02, \
    2.0005773048508315E-11, \
    6.3990627193898685E-13, \
    1.0632974804687463E-07, \
    8.6250779855215071E-03, \
    6.6741808978228592E-02, \
    0.4306469112078537E-01, \
    0.6674188216570097E-01, \
    0.7846818699308410E-01, \
    0.7929950474887259E-01, \
    0.6448860284750376E-01, \
    0.1066710629614485E+00, \
    0.1415806036539784E+00, \
    0.1510840430760184E+00, \
    0.7134663382271778E-01, \
    0.1201285306350883E+00, \
    0.1666128410939293E+00, \
    0.1847501847929859E+00, \
    0.7317273327500385E-01, \
    0.1237630544953746E+00, \
    0.1737438887583106E+00, \
    0.1951190307092811E+00, \
    0.7378938035365546E-01, \
    0.1249951430754052E+00, \
    0.1761984774738108E+00, \
    0.1987772386442824E+00, \
    0.2340886964802671E+00, \
    0.2479460829231492E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    t = 0.0
    h = 0.0
    a = 0.0
  else:
    t = t_vec[n_data]
    h = h_vec[n_data]
    a = a_vec[n_data]
    n_data = n_data + 1

  return n_data, h, a, t

def owen_values_test ( ):

#*****************************************************************************80
#
## owen_values_test() tests owen_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'owen_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  owen_values stores values of the OWEN function.' )
  print ( '' )
  print ( '      H         A          T' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, h, a, t = owen_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %12f' % ( h, a, t ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'owen_values_test:' )
  print ( '  Normal end of execution.' )
  return

def p01_polynomial_values ( n_data ):

#*****************************************************************************80
#
## p01_polynomial_values returns values of the shifted Legendre polynomials.
#
#  Discussion:
#
#    If we denote the Legendre polynomial by P(n)(x), and the shifted 
#    Legendre polynomial by p01(n)(x), then
#
#      p01(n)(x) = P(n)(2*x-1)
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 March 2016
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 22

  f_vec = np.array ( ( \
      0.1000000000000000E+01, \
      0.2500000000000000E+00, \
     -0.4062500000000000E+00, \
     -0.3359375000000000E+00, \
      0.1577148437500000E+00, \
      0.3397216796875000E+00, \
      0.2427673339843750E-01, \
     -0.2799186706542969E+00, \
     -0.1524540185928345E+00, \
      0.1768244206905365E+00, \
      0.2212002165615559E+00, \
      0.0000000000000000E+00, \
     -0.1475000000000000E+00, \
     -0.2800000000000000E+00, \
     -0.3825000000000000E+00, \
     -0.4400000000000000E+00, \
     -0.4375000000000000E+00, \
     -0.3600000000000000E+00, \
     -0.1925000000000000E+00, \
      0.8000000000000000E-01, \
      0.4725000000000000E+00, \
      0.1000000000000000E+01 ))

  n_vec = np.array ( ( \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3 ))

  x_vec = np.array ( ( \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.625E+00, \
     0.50E+00, \
     0.55E+00, \
     0.60E+00, \
     0.65E+00, \
     0.70E+00, \
     0.75E+00, \
     0.80E+00, \
     0.85E+00, \
     0.90E+00, \
     0.95E+00, \
     1.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, f

def p01_polynomial_values_test ( ):

#*****************************************************************************80
#
## p01_polynomial_values_test() tests p01_polynomial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 March 2016
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'p01_polynomial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  p01_polynomial_values stores values of the shifted Legendre polynomials.' )
  print ( '' )
  print ( '      N            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, f = p01_polynomial_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12g  %24.16g' % ( n, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'p01_polynomial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def partition_count_values ( n_data ):

#*****************************************************************************80
#
## partition_count_values returns some values of the integer partition count.
#
#  Discussion:
#
#    A partition of an integer N is a representation of the integer
#    as the sum of nonzero positive integers.  The order of the summands
#    does not matter.  The number of partitions of N is symbolized
#    by P(N).  Thus, the number 5 has P(N) = 7, because it has the
#    following partitions:
#
#    5 = 5
#      = 4 + 1
#      = 3 + 2
#      = 3 + 1 + 1
#      = 2 + 2 + 1
#      = 2 + 1 + 1 + 1
#      = 1 + 1 + 1 + 1 + 1
#
#    In Mathematica, the function can be evaluated by
#
#      PartitionsP[n]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 November 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the integer.
#
#    integer C, the number of partitions of the integer.
#
  import numpy as np

  n_max = 21

  c_vec = np.array ( ( \
      1, \
      1,   2,   3,   5,   7,  11,  15,  22,  30,  42, \
     56,  77, 101, 135, 176, 231, 297, 385, 490, 627 ) )

  n_vec = np.array ( ( \
     0,  \
     1,  2,  3,  4,  5,  6,  7,  8,  9, 10, \
    11, 12, 13, 14, 15, 16, 17, 18, 19, 20 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    c = 0
  else:
    n = n_vec[n_data]
    c = c_vec[n_data]
    n_data = n_data + 1

  return n_data, n, c

def partition_count_values_test ( ):

#*****************************************************************************80
#
## partition_count_values_test() tests partition_count_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    23 November 2014
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'partition_count_values_test:' )
  print ( '  partition_count_values returns values of ' )
  print ( '  the integer partition count function.' )
  print ( '' )
  print ( '     N         P(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, fn = partition_count_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4d  %10d' % ( n, fn ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'partition_count_values_test:' )
  print ( '  Normal end of execution.' )
  return

def partition_distinct_count_values ( n_data ):

#*****************************************************************************80
#
## partition_distinct_count_values returns some values of Q(N).
#
#  Discussion:
#
#    A partition of an integer N is a representation of the integer
#    as the sum of nonzero positive integers.  The order of the summands
#    does not matter.  The number of partitions of N is symbolized
#    by P(N).  Thus, the number 5 has P(N) = 7, because it has the
#    following partitions:
#
#    5 = 5
#      = 4 + 1
#      = 3 + 2
#      = 3 + 1 + 1
#      = 2 + 2 + 1
#      = 2 + 1 + 1 + 1
#      = 1 + 1 + 1 + 1 + 1
#
#    However, if we require that each member of the partition
#    be distinct, so that no nonzero summand occurs more than once,
#    we are computing something symbolized by Q(N).
#    The number 5 has Q(N) = 3, because it has the following partitions
#    into distinct parts:
#
#    5 = 5
#      = 4 + 1
#      = 3 + 2
#
#    In Mathematica, the function can be evaluated by
#
#      PartitionsQ[n]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the integer.
#
#    integer C, the number of partitions of the integer
#    into distinct parts.
#
  import numpy as np

  n_max = 21

  c_vec = np.array ( ( \
      1, \
      1,   1,   2,   2,   3,   4,   5,   6,   8,  10, \
     12,  15,  18,  22,  27,  32,  38,  46,  54,  64 ) )

  n_vec = np.array ( ( \
     0,  \
     1,  2,  3,  4,  5,  6,  7,  8,  9, 10, \
    11, 12, 13, 14, 15, 16, 17, 18, 19, 20 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    c = 0
  else:
    n = n_vec[n_data]
    c = c_vec[n_data]
    n_data = n_data + 1

  return n_data, n, c

def partition_distinct_count_values_test ( ):

#*****************************************************************************80
#
## partition_distinct_count_values_test: test partition_distinct_count_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    14 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'partition_distinct_count_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  partition_distinct_count_values returns values of ' )
  print ( '  the integer partition count function for distinct parts' )
  print ( '' )
  print ( '     N         P(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, fn = partition_distinct_count_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4d  %10d' % ( n, fn ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'partition_distinct_count_values_test:' )
  print ( '  Normal end of execution.' )
  return

def phi_values ( n_data ):

#*****************************************************************************80
#
## phi_values returns some values of the PHI function.
#
#  Discussion:
#
#    PHI(N) is the number of integers between 1 and N which are
#    relatively prime to N.  I and J are relatively prime if they
#    have no common factors.  The function PHI(N) is known as
#    "Euler's totient function".
#
#    By convention, 1 and N are relatively prime.
#
#    In Mathematica, the function can be evaluated by:
#
#      EulerPhi[n]
#
#  First values:
#
#     N  PHI(N)
#
#     1    1
#     2    1
#     3    2
#     4    2
#     5    4
#     6    2
#     7    6
#     8    4
#     9    6
#    10    4
#    11   10
#    12    4
#    13   12
#    14    6
#    15    8
#    16    8
#    17   16
#    18    6
#    19   18
#    20    8
#
#  Formula:
#
#    PHI(U*V) = PHI(U) * PHI(V) if U and V are relatively prime.
#
#    PHI(P^K) = P^(K-1) * ( P - 1 ) if P is prime.
#
#    PHI(N) = N * Product ( P divides N ) ( 1 - 1 / P )
#
#    N = Sum ( D divides N ) PHI(D).
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 September 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the argument of the PHI function.
#
#    integer C, the value of the PHI function.
#
  import numpy as np

  n_max = 20

  c_vec = np.array ( ( \
      1,   1,   2,   2,   4,   2,   6,   4,   6,   4, \
      8,   8,  16,  20,  16,  40, 148, 200, 200, 648 ))

  n_vec = np.array ( ( \
      1,   2,   3,   4,   5,   6,   7,   8,   9,  10, \
     20,  30,  40,  50,  60, 100, 149, 500, 750, 999 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    c = 0
  else:
    n = n_vec[n_data]
    c = c_vec[n_data]
    n_data = n_data + 1

  return n_data, n, c

def phi_values_test ( ):

#*****************************************************************************80
#
## phi_values_test() tests phi_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'phi_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  phi_values stores values of the PHI function.' )
  print ( '' )
  print ( '             N    PHI(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, c = phi_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12d' % ( n, c ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'phi_values_test:' )
  print ( '  Normal end of execution.' )
  return

def pi_values ( n_data ):

#*****************************************************************************80
#
## pi_values returns values of the Pi function.
#
#  Discussion:
#
#    Pi[n] is the number of primes less than or equal to n.
#
#    In Mathematica, the function can be evaluated by:
#
#      PrimePi[n]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the argument.
#
#    integer P, the value of the function.
#
  import numpy as np

  n_max = 17

  n_vec = np.array ( ( \
            10, \
            20, \
            30, \
            40, \
            50, \
            60, \
            70, \
            80, \
            90, \
           100, \
          1000, \
         10000, \
        100000, \
       1000000, \
      10000000, \
     100000000, \
    1000000000 ))

  p_vec = np.array ( ( \
             4, \
             8, \
            10, \
            12, \
            15, \
            17, \
            19, \
            22, \
            24, \
            25, \
           168, \
          1229, \
          9592, \
         78498, \
        664579, \
       5761455, \
      50847534 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    p = 0
  else:
    n = n_vec[n_data]
    p = p_vec[n_data]
    n_data = n_data + 1

  return n_data, n, p

def pi_values_test ( ):

#*****************************************************************************80
#
## pi_values_test() tests pi_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'pi_values_test:' )
  print ( '  pi_values stores values of the PI function.' )
  print ( '' )
  print ( '             N    PI(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, c = pi_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12d' % ( n, c ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'pi_values_test:' )
  print ( '  Normal end of execution.' )
  return

def pmn_polynomial_values ( n_data ):

#*****************************************************************************80
#
## pmn_polynomial_values: selected values of associated Legendre functions.
#
#  Discussion:
#
#    The function considered is the associated Legendre polynomial P^M_N(X).
#
#    In Mathematica, the function can be evaluated by:
#
#      LegendreP [ n, m, x ]
#
#    The function is normalized by dividing by
#
#      sqrt ( 2 * ( n + m )! / ( 2 * n + 1 ) / ( n - m )! )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, integer M, real X, 
#    the arguments of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 21

  f_vec = np.array ( ( \
    0.7071067811865475E+00, \
    0.6123724356957945E+00, \
   -0.7500000000000000E+00, \
   -0.1976423537605237E+00, \
   -0.8385254915624211E+00, \
    0.7261843774138907E+00, \
   -0.8184875533567997E+00, \
   -0.1753901900050285E+00, \
    0.9606516343087123E+00, \
   -0.6792832849776299E+00, \
   -0.6131941618102092E+00, \
    0.6418623720763665E+00, \
    0.4716705890038619E+00, \
   -0.1018924927466445E+01, \
    0.6239615396237876E+00, \
    0.2107022704608181E+00, \
    0.8256314721961969E+00, \
   -0.3982651281554632E+00, \
   -0.7040399320721435E+00, \
    0.1034723155272289E+01, \
   -0.5667412129155530E+00 ))

  m_vec = np.array ( ( \
    0, 0, 1, 0, \
    1, 2, 0, 1, \
    2, 3, 0, 1, \
    2, 3, 4, 0, \
    1, 2, 3, 4, \
    5 ))

  n_vec = np.array ( ( \
    0,  1,  1,  2, \
    2,  2,  3,  3, \
    3,  3,  4,  4, \
    4,  4,  4,  5, \
    5,  5,  5,  5, \
    5 ))

  x_vec = np.array ( ( \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    m = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    m = m_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, m, x, f

def pmn_polynomial_values_test ( ):

#*****************************************************************************80
#
## pmn_polynomial_values_test demonstrates pmn_polynomial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'pmn_polynomial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  pmn_polynomial_values stores values of the ' )
  print ( '  normalized associated Legendre function.' )
  print ( '' )
  print ( '      N       M            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, m, x, f = pmn_polynomial_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %6d  %12g  %24.16g' % ( n, m, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'pmn_polynomial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def pmns_polynomial_values ( n_data ):

#*****************************************************************************80
#
## pmns_polynomial_values: selected values of the associated Legendre polynomial normalized for sphere.
#
#  Discussion:
#
#    The function considered is the associated Legendre polynomial P^M_N(X).
#
#    In Mathematica, the function can be evaluated by:
#
#      LegendreP [ n, m, x ]
#
#    The function is normalized for the unit sphere by dividing by
#
#      sqrt ( 4 * pi * ( n + m )! / ( 2 * n + 1 ) / ( n - m )! )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, integer M, real X, 
#    the arguments of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 21

  f_vec = np.array ( ( \
     0.2820947917738781, \
     0.2443012559514600, \
    -0.2992067103010745, \
    -0.07884789131313000, \
    -0.3345232717786446, \
     0.2897056515173922, \
    -0.3265292910163510, \
    -0.06997056236064664, \
     0.3832445536624809, \
    -0.2709948227475519, \
    -0.2446290772414100, \
     0.2560660384200185, \
     0.1881693403754876, \
    -0.4064922341213279, \
     0.2489246395003027, \
     0.08405804426339821, \
     0.3293793022891428, \
    -0.1588847984307093, \
    -0.2808712959945307, \
     0.4127948151484925, \
    -0.2260970318780046  ))

  m_vec = np.array ( ( \
    0, 0, 1, 0, \
    1, 2, 0, 1, \
    2, 3, 0, 1, \
    2, 3, 4, 0, \
    1, 2, 3, 4, \
    5 ))

  n_vec = np.array ( ( \
    0,  1,  1,  2, \
    2,  2,  3,  3, \
    3,  3,  4,  4, \
    4,  4,  4,  5, \
    5,  5,  5,  5, \
    5 ))

  x_vec = np.array ( ( \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    m = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    m = m_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, m, x, f

def pmns_polynomial_values_test ( ):

#*****************************************************************************80
#
## pmns_polynomial_values_test demonstrates pmns_polynomial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'pmns_polynomial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  pmns_polynomial_values stores values of the ' )
  print ( '  associated Legendre function normalized for the surface of a sphere.' )
  print ( '' )
  print ( '      N       M            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, m, x, f = pmns_polynomial_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %6d  %12g  %24.16g' % ( n, m, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'pmns_polynomial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def pm_polynomial_values ( n_data ):

#*****************************************************************************80
#
## pm_polynomial_values: selected values of associated Legendre functions.
#
#  Discussion:
#
#    The function considered is the associated Legendre polynomial P^M_N(X).
#
#    In Mathematica, the function can be evaluated by:
#
#      LegendreP [ n, m, x ]
#
#  Differential equation:
#
#    (1-X*X) * Y'' - 2 * X * Y + ( N (N+1) - (M*M/(1-X*X)) * Y = 0
#
#  First terms:
#
#    M = 0  ( = Legendre polynomials of first kind P(N)(X) )
#
#    P00 =    1
#    P10 =    1 X
#    P20 = (  3 X^2 -   1)/2
#    P30 = (  5 X^3 -   3 X)/2
#    P40 = ( 35 X^4 -  30 X^2 +   3)/8
#    P50 = ( 63 X^5 -  70 X^3 +  15 X)/8
#    P60 = (231 X^6 - 315 X^4 + 105 X^2 -  5)/16
#    P70 = (429 X^7 - 693 X^5 + 315 X^3 - 35 X)/16
#
#    M = 1
#
#    p01 =   0
#    P11 =   1 * SQRT(1-X*X)
#    P21 =   3 * SQRT(1-X*X) * X
#    P31 = 1.5 * SQRT(1-X*X) * (5*X*X-1)
#    P41 = 2.5 * SQRT(1-X*X) * (7*X*X*X-3*X)
#
#    M = 2
#
#    P02 =   0
#    P12 =   0
#    P22 =   3 * (1-X*X)
#    P32 =  15 * (1-X*X) * X
#    P42 = 7.5 * (1-X*X) * (7*X*X-1)
#
#    M = 3
#
#    P03 =   0
#    P13 =   0
#    P23 =   0
#    P33 =  15 * (1-X*X)^1.5
#    P43 = 105 * (1-X*X)^1.5 * X
#
#    M = 4
#
#    P04 =   0
#    P14 =   0
#    P24 =   0
#    P34 =   0
#    P44 = 105 * (1-X*X)^2
#
#  Recursion:
#
#    if N < M:
#      P(N,M) = 0
#    if N = M:
#      P(N,M) = (2*M-1)!! * (1-X*X)^(M/2) where N!! means the product of
#      all the odd integers less than or equal to N.
#    if N = M+1:
#      P(N,M) = X*(2*M+1)*P(M,M)
#    if M+1 < N:
#      P(N,M) = ( X*(2*N-1)*P(N-1,M) - (N+M-1)*P(N-2,M) )/(N-M)
#
#  Restrictions:
#
#    -1 <= X <= 1
#     0 <= M <= N
#
#  Special values:
#
#    P(N,0)(X) = P(N)(X), that is, for M=0, the associated Legendre
#    polynomial of the first kind equals the Legendre polynomial of the
#    first kind.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, integer M, real X, 
#    the arguments of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
      0.0000000000000000E+00, \
     -0.5000000000000000E+00, \
      0.0000000000000000E+00, \
      0.3750000000000000E+00, \
      0.0000000000000000E+00, \
     -0.8660254037844386E+00, \
     -0.1299038105676658E+01, \
     -0.3247595264191645E+00, \
      0.1353164693413185E+01, \
     -0.2800000000000000E+00, \
      0.1175755076535925E+01, \
      0.2880000000000000E+01, \
     -0.1410906091843111E+02, \
     -0.3955078125000000E+01, \
     -0.9997558593750000E+01, \
      0.8265311444100484E+02, \
      0.2024442836815152E+02, \
     -0.4237997531890869E+03, \
      0.1638320624828339E+04, \
     -0.2025687389227225E+05  ))

  m_vec = np.array ( ( \
    0, 0, 0, 0, \
    0, 1, 1, 1, \
    1, 0, 1, 2, \
    3, 2, 2, 3, \
    3, 4, 4, 5 ))

  n_vec = np.array ( ( \
    1,  2,  3,  4, \
    5,  1,  2,  3, \
    4,  3,  3,  3, \
    3,  4,  5,  6, \
    7,  8,  9, 10 ))

  x_vec = np.array ( ( \
     0.00E+00, \
     0.00E+00, \
     0.00E+00, \
     0.00E+00, \
     0.00E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     0.20E+00, \
     0.20E+00, \
     0.20E+00, \
     0.20E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00 ))
  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    m = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    m = m_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, m, x, f

def pm_polynomial_values_test ( ):

#*****************************************************************************80
#
## pm_polynomial_values_test() tests pm_polynomial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'pm_polynomial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  pm_polynomial_values stores values of the associated Legendre function.' )
  print ( '' )
  print ( '      N       M            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, m, x, f = pm_polynomial_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %6d  %12f  %24.16g' % ( n, m, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'pm_polynomial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def pn_polynomial_values ( n_data ):

#*****************************************************************************80
#
## pn_polynomial_values: selected values of the normalized Legendre polynomials.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 March 2016
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 22

  f_vec = np.array ( ( \
    0.7071067811865475, \
    0.3061862178478972, \
   -0.642337649721702, \
   -0.6284815141846855, \
    0.3345637065282053, \
    0.7967179601799685, \
    0.06189376866246124, \
   -0.766588850921089, \
   -0.4444760242953344, \
    0.5450094674858101, \
    0.7167706229835538, \
    0.0000000000000000, \
   -0.2759472322745781, \
   -0.5238320341483518, \
   -0.7155919752205163, \
   -0.823164625090267, \
   -0.8184875533567997, \
   -0.6734983296193094, \
   -0.360134523476992, \
    0.1496662954709581, \
    0.8839665576253438, \
    1.870828693386971 ))

  n_vec = np.array ( ( \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3 ))

  x_vec = np.array ( ( \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.00E+00, \
     0.10E+00, \
     0.20E+00, \
     0.30E+00, \
     0.40E+00, \
     0.50E+00, \
     0.60E+00, \
     0.70E+00, \
     0.80E+00, \
     0.90E+00, \
     1.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, f

def pn_polynomial_values_test ( ):

#*****************************************************************************80
#
## pn_polynomial_values_test() tests pn_polynomial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    17 March 2016
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'pn_polynomial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  pn_polynomial_values stores values of the normalized Legendre polynomials.' )
  print ( '' )
  print ( '      N            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, f = pn_polynomial_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12g  %24.16g' % ( n, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'pn_polynomial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def poisson_cdf_values ( n_data ):

#*****************************************************************************80
#
## poisson_cdf_values returns some values of the Poisson CDF.
#
#  Discussion:
#
#    CDF(X)(A) is the probability of at most X successes in unit time,
#    given that the expected mean number of successes is A.
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`DiscreteDistributions`]
#      dist = PoissonDistribution [ a ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#    Daniel Zwillinger,
#    CRC Standard Mathematical Tables and Formulae,
#    30th Edition, CRC Press, 1996, pages 653-658.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, the parameter of the function.
#
#    integer X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 21

  a_vec = np.array ( ( \
     0.02E+00, \
     0.10E+00, \
     0.10E+00, \
     0.50E+00, \
     0.50E+00, \
     0.50E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     1.00E+00, \
     2.00E+00, \
     2.00E+00, \
     2.00E+00, \
     2.00E+00, \
     5.00E+00, \
     5.00E+00, \
     5.00E+00, \
     5.00E+00, \
     5.00E+00, \
     5.00E+00, \
     5.00E+00 ))

  f_vec = np.array ( ( \
     0.9801986733067553E+00, \
     0.9048374180359596E+00, \
     0.9953211598395555E+00, \
     0.6065306597126334E+00, \
     0.9097959895689501E+00, \
     0.9856123220330293E+00, \
     0.3678794411714423E+00, \
     0.7357588823428846E+00, \
     0.9196986029286058E+00, \
     0.9810118431238462E+00, \
     0.1353352832366127E+00, \
     0.4060058497098381E+00, \
     0.6766764161830635E+00, \
     0.8571234604985470E+00, \
     0.6737946999085467E-02, \
     0.4042768199451280E-01, \
     0.1246520194830811E+00, \
     0.2650259152973617E+00, \
     0.4404932850652124E+00, \
     0.6159606548330631E+00, \
     0.7621834629729387E+00 ))

  x_vec = np.array ( ( \
     0, 0, 1, 0, \
     1, 2, 0, 1, \
     2, 3, 0, 1, \
     2, 3, 0, 1, \
     2, 3, 4, 5, \
     6 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, x, f

def poisson_cdf_values_test ( ):

#*****************************************************************************80
#
## poisson_cdf_values_test() tests poisson_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'poisson_cdf_values_test:' )
  print ( '  poisson_cdf_values stores values of the Gegenbauer polynomials.' )
  print ( '' )
  print ( '      A         X            FX' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, x, fx = poisson_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( a, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'poisson_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def polylogarithm_values ( n_data ):

#*****************************************************************************80
#
## polylogarithm_values returns some values of the polylogarithm.
#
#  Discussion:
#
#    The polylogarithm of n and z is defined as
#
#      f[n,z] = Sum ( 1 <= k < infinity ) z^k / k^n
#
#    In Mathematica, the function can be evaluated by:
#
#      PolyLog[n,z]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the exponent of the denominator.
#
#    real Z, the base of the numerator.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 12

  f_vec = np.array ( ( \
     0.1644934066848226E+01, \
     0.1202056903159594E+01, \
     0.1000994575127818E+01, \
     0.5822405264650125E+00, \
     0.5372131936080402E+00, \
     0.5002463206060068E+00, \
     0.3662132299770635E+00, \
     0.3488278611548401E+00, \
     0.3334424797228716E+00, \
     0.1026177910993911E+00, \
     0.1012886844792230E+00, \
     0.1000097826564961E+00 ))

  n_vec = np.array ( ( \
     2, 3, 10, 2, 3, 10, 2, 3, 10, 2, 3, 10 ))

  z_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.3333333333333333E+00, \
     0.3333333333333333E+00, \
     0.3333333333333333E+00, \
     0.1000000000000000E+00, \
     0.1000000000000000E+00, \
     0.1000000000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    z = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    z = z_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, z, f

def polylogarithm_values_test ( ):

#*****************************************************************************80
#
## polylogarithm_values_test() tests polylogarithm_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'polylogarithm_values_test:' )
  print ( '  polylogarithm_values stores values of the Gegenbauer polynomials.' )
  print ( '' )
  print ( '      N         Z            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, z, f = polylogarithm_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, z, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'polylogarithm_values_test:' )
  print ( '  Normal end of execution.' )
  return

def polyomino_chiral_count_values ( n_data ):

#*****************************************************************************80
#
## polyomino_chiral_count_values counts chiral polyominoes (allowing holes).
#
#  Discussion:
#
#    Polyominoes are connected planar shapes formed by adjoining unit squares.
#
#    The number of unit squares in a polyomino is its order.
#
#    If we ignore reflections and rotations when comparing polyominoes,
#    then we are considering the class of "chiral" polyominoes.  In that case,
#    for instance, there are just 18 chiral polyominoes of order 5.
#
#    As the order increases, the number of polyominoes grows very rapidly.
#    The list offered here goes no further than order 28, but the later
#    numbers in the list are too large to represent as 32 byte integers. 
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 May 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Solomon Golomb,
#    Polyominoes: Puzzles, Patterns, Problems, and Packings,
#    Princeton University Press, 1996,
#    ISBN: 9780691024448
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer ORDER, the order of a polyomino.
#
#    integer NUMBER, the number of chiral polyominos of this order.
#
  import numpy as np

  n_max = 31

  order_vec = np.array ( [ \
    0, \
    1,  2,  3,  4,  5, \
    6,  7,  8,  9, 10, \
   11, 12, 13, 14, 15, \
   16, 17, 18, 19, 20, \
   21, 22, 23, 24, 25, \
   26, 27, 28, 29, 30 ] )

  number_vec = np.array ( [ \
    1, \
    1, 1, 2, 7, 18, \
    60, 196, 704, 2500, 9189, \
    33896, 126759, 476270, 1802312, 6849777, \
    26152418, 100203194, 385221143, 1485200848, 5741256764, \
    22245940545, 86383382827, 336093325058, 1309998125640, 5114451441106, \
    19998172734786, 78306011677182, 307022182222506, 1205243866707468, 4736694001644862 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    order = 0
    number = 0
  else:
    order = order_vec[n_data]
    number = number_vec[n_data]
    n_data = n_data + 1

  return n_data, order, number

def polyomino_chiral_count_values_test ( ):

#*****************************************************************************80
#
## polyomino_chiral_count_values_test() tests polyomino_chiral_count_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 May 2018
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'polyomino_chiral_count_values_test:' )
  print ( '  polyomino_chiral_count_values returns counts of' )
  print ( '  the number of chiral polyominoes.' )
  print ( '' )
  print ( '     Order     Number' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, order, number = polyomino_chiral_count_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %d  %d' % (  order, number ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'polyomino_chiral_count_values_test:' )
  print ( '  Normal end of execution.' )
  return

def polyomino_fixed_count_values ( n_data ):

#*****************************************************************************80
#
## polyomino_fixed_count_values counts fixed polyominoes (allowing holes).
#
#  Discussion:
#
#    Polyominoes are connected planar shapes formed by adjoining unit squares.
#
#    The number of unit squares in a polyomino is its order.
#
#    If we do not ignore reflections and rotations when comparing polyominoes,
#    then we are considering the class of "fixed" polyominoes.  In that case,
#    for instance, there are 65 fixed polyominoes of order 5.
#
#    As the order increases, the number of polyominoes grows very rapidly.
#    The list offered here goes no further than order 28, but the later
#    numbers in the list are too large to represent as 32 byte integers. 
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    10 April 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Solomon Golomb,
#    Polyominoes: Puzzles, Patterns, Problems, and Packings,
#    Princeton University Press, 1996,
#    ISBN: 9780691024448
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer ORDER, the order of a polyomino.
#
#    integer NUMBER, the number of fixed polyominos of this order.
#
  import numpy as np

  n_max = 29

  order_vec = np.array ( [ \
    0, \
    1,  2,  3,  4,  5, \
    6,  7,  8,  9, 10, \
   11, 12, 13, 14, 15, \
   16, 17, 18, 19, 20, \
   21, 22, 23, 24, 25, \
   26, 27, 28 ] )

  number_vec = np.array ( [  \
    1, \
    1, 2, 6, 19, 63,  \
    216, 760, 2725, 9910, 36446,  \
    135268, 505861, 1903890, 7204874, 27394666,  \
    104592937, 400795844, 1540820542, 5940738676, 22964779660,  \
    88983512783, 345532572678, 1344372335524, 5239988770268, 20457802016011,  \
    79992676367108, 313224032098244, 1228088671826973 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    order = 0
    number = 0
  else:
    order = order_vec[n_data]
    number = number_vec[n_data]
    n_data = n_data + 1

  return n_data, order, number

def polyomino_fixed_count_values_test ( ):

#*****************************************************************************80
#
## polyomino_fixed_count_values_test() tests polyomino_fixed_count_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    10 April 2018
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'polyomino_fixed_count_values_test:' )
  print ( '  polyomino_fixed_count_values returns counts of' )
  print ( '  the number of fixed polyominoes.' )
  print ( '' )
  print ( '     Order     Number' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, order, number = polyomino_fixed_count_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %d  %d' % (  order, number ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'polyomino_fixed_count_values_test:' )
  print ( '  Normal end of execution.' )
  return

def polyomino_free_count_values ( n_data ):

#*****************************************************************************80
#
## polyomino_free_count_values counts free polyominoes (allowing holes).
#
#  Discussion:
#
#    Polyominoes are connected planar shapes formed by adjoining unit squares.
#
#    The number of unit squares in a polyomino is its order.
#
#    If we ignore reflections and rotations when comparing polyominoes,
#    then we are considering the class of "free" polyominoes.  In that case,
#    for instance, there are just 12 free polyominoes of order 5, the
#    so called "pentominoes".
#
#    As the order increases, the number of polyominoes grows very rapidly.
#    The list offered here goes no further than order 28, but the later
#    numbers in the list are too large to represent as 32 byte integers. 
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    10 April 2018
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Solomon Golomb,
#    Polyominoes: Puzzles, Patterns, Problems, and Packings,
#    Princeton University Press, 1996,
#    ISBN: 9780691024448
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer ORDER, the order of a polyomino.
#
#    integer NUMBER, the number of free polyominos of this order.
#
  import numpy as np

  n_max = 29

  order_vec = np.array ( [ \
    0, \
    1,  2,  3,  4,  5, \
    6,  7,  8,  9, 10, \
   11, 12, 13, 14, 15, \
   16, 17, 18, 19, 20, \
   21, 22, 23, 24, 25, \
   26, 27, 28 ] )

  number_vec = np.array ( [ \
    1, \
    1,  1,  2,  5,  12, \
    35,  108,  369,  1285,  4655, \
    17073,  63600,  238591,  901971,  3426576, \
    13079255,  50107909,  192622052,  742624232,  2870671950, \
    11123060678,  43191857688,  168047007728,  654999700403,  2557227044764, \
    9999088822075,  39153010938487,  153511100594603 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    order = 0
    number = 0
  else:
    order = order_vec[n_data]
    number = number_vec[n_data]
    n_data = n_data + 1

  return n_data, order, number

def polyomino_free_count_values_test ( ):

#*****************************************************************************80
#
## polyomino_free_count_values_test() tests polyomino_free_count_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    10 April 2018
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'polyomino_free_count_values_test:' )
  print ( '  polyomino_free_count_values returns counts of' )
  print ( '  the number of free polyominoes.' )
  print ( '' )
  print ( '     Order     Number' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, order, number = polyomino_free_count_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %d  %d' % (  order, number ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'polyomino_free_count_values_test:' )
  print ( '  Normal end of execution.' )
  return

def p_polynomial_values ( n_data ):

#*****************************************************************************80
#
## p_polynomial_values: selected values of the Legendre polynomials.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      LegendreP [ n, x ]
#
#  Differential equation:
#
#    (1-X*X) * P(N,X)'' - 2 * X * P(N,X)' + N * (N+1) = 0
#
#  First terms:
#
#    P( 0,X) =       1
#    P( 1,X) =       1 X
#    P( 2,X) =  (    3 X^2 -       1)/2
#    P( 3,X) =  (    5 X^3 -     3 X)/2
#    P( 4,X) =  (   35 X^4 -    30 X^2 +     3)/8
#    P( 5,X) =  (   63 X^5 -    70 X^3 +    15 X)/8
#    P( 6,X) =  (  231 X^6 -   315 X^4 +   105 X^2 -     5)/16
#    P( 7,X) =  (  429 X^7 -   693 X^5 +   315 X^3 -    35 X)/16
#    P( 8,X) =  ( 6435 X^8 - 12012 X^6 +  6930 X^4 -  1260 X^2 +   35)/128
#    P( 9,X) =  (12155 X^9 - 25740 X^7 + 18018 X^5 -  4620 X^3 +  315 X)/128
#    P(10,X) =  (46189 X^10-109395 X^8 + 90090 X^6 - 30030 X^4 + 3465 X^2-63 ) /256
#
#  Recursion:
#
#    P(0,X) = 1
#    P(1,X) = X
#    P(N,X) = ( (2*N-1)*X*P(N-1,X)-(N-1)*P(N-2,X) ) / N
#
#    P'(0,X) = 0
#    P'(1,X) = 1
#    P'(N,X) = ( (2*N-1)*(P(N-1,X)+X*P'(N-1,X)-(N-1)*P'(N-2,X) ) / N
#
#  Formula:
#
#    P(N,X) = (1/2^N) * sum ( 0 <= M <= N/2 ) C(N,M) C(2N-2M,N) X^(N-2*M)
#
#  Orthogonality:
#
#    Integral ( -1 <= X <= 1 ) P(I,X) * P(J,X) dX
#      = 0 if I =/= J
#      = 2 / ( 2*I+1 ) if I = J.
#
#  Approximation:
#
#    A function F(X) defined on [-1,1] may be approximated by the series
#
#      C0*P(0,X) + C1*P(1,X) + \ + CN*P(N,X)
#
#    where
#
#      C(I) = (2*I+1)/(2) * Integral ( -1 <= X <= 1 ) F(X) P(I,X) dx.
#
#  Special values:
#
#    P(N,1) = 1.
#    P(N,-1) = (-1)^N.
#    | P(N,X) | <= 1 in [-1,1].
#
#    P(N,0,X) = P(N,X), that is, for M=0, the associated Legendre
#    function of the first kind and order N equals the Legendre polynomial
#    of the first kind and order N.
#
#    The N zeroes of P(N,X) are the abscissas used for Gauss-Legendre
#    quadrature of the integral of a function F(X) with weight function 1
#    over the interval [-1,1].
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the order of the function.
#
#    real X, the point where the function is evaluated.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 22

  f_vec = np.array ( ( \
      0.1000000000000000E+01, \
      0.2500000000000000E+00, \
     -0.4062500000000000E+00, \
     -0.3359375000000000E+00, \
      0.1577148437500000E+00, \
      0.3397216796875000E+00, \
      0.2427673339843750E-01, \
     -0.2799186706542969E+00, \
     -0.1524540185928345E+00, \
      0.1768244206905365E+00, \
      0.2212002165615559E+00, \
      0.0000000000000000E+00, \
     -0.1475000000000000E+00, \
     -0.2800000000000000E+00, \
     -0.3825000000000000E+00, \
     -0.4400000000000000E+00, \
     -0.4375000000000000E+00, \
     -0.3600000000000000E+00, \
     -0.1925000000000000E+00, \
      0.8000000000000000E-01, \
      0.4725000000000000E+00, \
      0.1000000000000000E+01 ))

  n_vec = np.array ( ( \
     0,  1,  2, \
     3,  4,  5, \
     6,  7,  8, \
     9, 10,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3,  3,  3, \
     3 ))

  x_vec = np.array ( ( \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.25E+00, \
     0.00E+00, \
     0.10E+00, \
     0.20E+00, \
     0.30E+00, \
     0.40E+00, \
     0.50E+00, \
     0.60E+00, \
     0.70E+00, \
     0.80E+00, \
     0.90E+00, \
     1.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    x = 0.0
    f = 0.0
  else:
    n = n_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, x, f

def p_polynomial_values_test ( ):

#*****************************************************************************80
#
## p_polynomial_values_test() tests p_polynomial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    18 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'p_polynomial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  p_polynomial_values stores values of the Legendre polynomials.' )
  print ( '' )
  print ( '      N            X            F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, x, f = p_polynomial_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12f  %24.16g' % ( n, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'p_polynomial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def prandtl_values ( n_data ):

#*****************************************************************************80
#
## prandtl_values returns some values of the Prandtl number.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Lester Haar, John Gallagher and George Kell,
#    NBS/NRC Steam Tables:
#    Thermodynamic and transport Properties and Computer Programs
#    for Vapor and Liquid States of Water in SI Units,
#    Hemisphere Publishing Corporation, Washington, 1984,
#    TJ270.H3, page 265.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real TC, the temperature, in degrees Celsius.
#
#    real P, the pressure, in bar.
#
#    real PR, the Prandtl number, dimensionless.
#
  import numpy as np

  n_max = 35

  pr_vec = np.array ( ( \
     13.50E+00, \
     13.48E+00, \
     13.46E+00, \
     13.39E+00, \
     13.27E+00, \
     13.15E+00, \
     13.04E+00, \
     12.93E+00, \
     12.83E+00, \
     12.73E+00, \
     12.63E+00, \
     12.53E+00, \
     12.43E+00, \
     12.34E+00, \
     12.25E+00, \
     12.08E+00, \
     11.92E+00, \
     11.77E+00, \
     11.62E+00, \
     11.48E+00, \
     11.36E+00, \
     11.23E+00, \
     11.12E+00, \
     10.91E+00, \
     10.72E+00, \
     10.55E+00, \
      6.137E+00, \
      3.555E+00, \
      2.378E+00, \
      1.000E+00, \
      0.974E+00, \
      0.960E+00, \
      0.924E+00, \
      0.899E+00, \
      0.882E+00 ))

  p_vec = np.array ( ( \
        1.0E+00, \
        5.0E+00, \
       10.0E+00, \
       25.0E+00, \
       50.0E+00, \
       75.0E+00, \
      100.0E+00, \
      125.0E+00, \
      150.0E+00, \
      175.0E+00, \
      200.0E+00, \
      225.0E+00, \
      250.0E+00, \
      275.0E+00, \
      300.0E+00, \
      350.0E+00, \
      400.0E+00, \
      450.0E+00, \
      500.0E+00, \
      550.0E+00, \
      600.0E+00, \
      650.0E+00, \
      700.0E+00, \
      800.0E+00, \
      900.0E+00, \
     1000.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00 ))

  tc_vec = np.array ( ( \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
      25.0E+00, \
      50.0E+00, \
      75.0E+00, \
     100.0E+00, \
     150.0E+00, \
     200.0E+00, \
     400.0E+00, \
     600.0E+00, \
     800.0E+00 ))


  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    tc = 0.0
    p = 0.0
    pr = 0.0
  else:
    tc = tc_vec[n_data]
    p = p_vec[n_data]
    pr = pr_vec[n_data]
    n_data = n_data + 1

  return n_data, tc, p, pr

def prandtl_values_test ( ):

#*****************************************************************************80
#
## prandtl_values_test() tests prandtl_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'prandtl_values_test:' )
  print ( '  prandtl_values stores values of the PRANDTL function.' )
  print ( '' )
  print ( '      TC         P        PRANDTL(TC.P)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, tc, p, pr = prandtl_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f' % ( tc, p, pr ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'prandtl_values_test:' )
  print ( '  Normal end of execution.' )
  return

def prime_values ( n_data ):

#*****************************************************************************80
#
## prime_values returns values of the prime function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Prime[n]
#
#    Thanks to Morten Welinder for pointing out that the index of 145253029
#    is 8192000, 12 April 2013.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the index of the prime.
#
#    integer P, the value of the prime.
#
  import numpy as np

  n_max = 24

  n_vec = np.array ( ( \
          1, \
          2, \
          4, \
          8, \
         16, \
         32, \
         64, \
        128, \
        256, \
        512, \
       1000, \
       2000, \
       4000, \
       8000, \
      16000, \
      32000, \
      64000, \
     128000, \
     256000, \
     512000, \
    1024000, \
    2048000, \
    4096000, \
    8192000 ))

  p_vec = np.array ( ( \
            2, \
            3, \
            7, \
           19, \
           53, \
          131, \
          311, \
          719, \
         1619, \
         3671, \
         7919, \
        17389, \
        37813, \
        81799, \
       176081, \
       376127, \
       800573, \
      1698077, \
      3588941, \
      7559173, \
     15881419, \
     33283031, \
     69600977, \
    145253029 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    p = 0
  else:
    n = n_vec[n_data]
    p = p_vec[n_data]
    n_data = n_data + 1

  return n_data, n, p

def prime_values_test ( ):

#*****************************************************************************80
#
## prime_values_test() tests prime_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'prime_values_test:' )
  print ( '  prime_values stores values of the PRIME function.' )
  print ( '' )
  print ( '             N    PRIME(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, p = prime_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12d' % ( n, p ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'prime_values_test:' )
  print ( '  Normal end of execution.' )
  return

def psat_values ( n_data ):

#*****************************************************************************80
#
## psat_values returns some values of the saturation pressure.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Lester Haar, John Gallagher and George Kell,
#    NBS/NRC Steam Tables:
#    Thermodynamic and transport Properties and Computer Programs
#    for Vapor and Liquid States of Water in SI Units,
#    Hemisphere Publishing Corporation, Washington, 1984,
#    TJ270.H3, pages 9-15.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real TC, the temperature, in degrees Celsius.
#
#    real P, the saturation pressure, in bar.
#
  import numpy as np

  n_max = 12

  p_vec = np.array ( ( \
     0.0061173E+00, \
     0.0065716E+00, \
     0.0087260E+00, \
     0.12344E+00, \
     1.0132E+00,  \
     2.3201E+00,  \
     4.7572E+00,  \
     15.537E+00,  \
     39.737E+00,  \
     85.838E+00,  \
     165.21E+00,  \
     220.55E+00 ))

  tc_vec = np.array ( ( \
     0.100000E-01, \
     0.100000E+01, \
     0.500000E+01, \
     0.500000E+02, \
     0.100000E+03, \
     0.125000E+03, \
     0.150000E+03, \
     0.200000E+03, \
     0.250000E+03, \
     0.300000E+03, \
     0.350000E+03, \
     0.373976E+03  ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    tc = 0.0
    p = 0.0
  else:
    tc = tc_vec[n_data]
    p = p_vec[n_data]
    n_data = n_data + 1

  return n_data, tc, p

def psat_values_test ( ):

#*****************************************************************************80
#
## psat_values_test() tests psat_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  print ( '' )
  print ( 'psat_values_test:' )
  print ( '  psat_values stores values of the PSAT function.' )
  print ( '' )
  print ( '      TC         P' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, tc, p = psat_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f %24.16f' % ( tc, p ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'psat_values_test:' )
  print ( '  Normal end of execution.' )
  return

def psi_values ( n_data ):

#*****************************************************************************80
#
## psi_values returns some values of the Psi or Digamma function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      PolyGamma[x]
#
#    or
#
#      PolyGamma[0,x]
#
#    PSI(X) = d ln ( Gamma ( X ) ) / d X = Gamma'(X) / Gamma(X)
#
#    PSI(1) = -Euler's constant.
#
#    PSI(X+1) = PSI(X) + 1 / X.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
    -10.42375494041108E+00, \
     -5.289039896592188E+00, \
     -3.502524222200133E+00, \
     -2.561384544585116E+00, \
     -1.963510026021423E+00, \
     -1.540619213893190E+00, \
     -1.220023553697935E+00, \
     -0.9650085667061385E+00, \
     -0.7549269499470514E+00, \
     -0.5772156649015329E+00, \
     -0.4237549404110768E+00, \
     -0.2890398965921883E+00, \
     -0.1691908888667997E+00, \
     -0.6138454458511615E-01, \
      0.3648997397857652E-01, \
      0.1260474527734763E+00, \
      0.2085478748734940E+00, \
      0.2849914332938615E+00, \
      0.3561841611640597E+00, \
      0.4227843350984671E+00 ))

  x_vec = np.array ( ( \
     0.1E+00, \
     0.2E+00, \
     0.3E+00, \
     0.4E+00, \
     0.5E+00, \
     0.6E+00, \
     0.7E+00, \
     0.8E+00, \
     0.9E+00, \
     1.0E+00, \
     1.1E+00, \
     1.2E+00, \
     1.3E+00, \
     1.4E+00, \
     1.5E+00, \
     1.6E+00, \
     1.7E+00, \
     1.8E+00, \
     1.9E+00, \
     2.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def psi_values_test ( ):

#*****************************************************************************80
#
## psi_values_test() tests psi_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'psi_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  psi_values stores values of the PSI function.' )
  print ( '' )
  print ( '      X         PSI(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = psi_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'psi_values_test:' )
  print ( '  Normal end of execution.' )
  return

def r8_factorial2_values ( n_data ):

#*****************************************************************************80
#
## r8_factorial2_values returns values of the double factorial function.
#
#  Formula:
#
#    FACTORIAL2( N ) = Product ( N * (N-2) * (N-4) * ... * 2 )  (N even)
#                    = Product ( N * (N-2) * (N-4) * ... * 1 )  (N odd)
#
#    In Mathematica, the function can be evaluated by:
#
#      n!!
#
#  Example:
#
#     N    N!!
#
#     0     1
#     1     1
#     2     2
#     3     3
#     4     8
#     5    15
#     6    48
#     7   105
#     8   384
#     9   945
#    10  3840
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    07 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#    Daniel Zwillinger,
#    CRC Standard Mathematical Tables and Formulae,
#    30th Edition,
#    CRC Press, 1996, page 16.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the argument of the function.
#
#    real F, the value of the function.
# 
  import numpy as np

  n_max = 16

  f_vec = np.array ( ( 
          1.0, \
          1.0, \
          2.0, \
          3.0, \
          8.0, \
         15.0, \
         48.0, \
        105.0, \
        384.0, \
        945.0, \
       3840.0, \
      10395.0, \
      46080.0, \
     135135.0, \
     645120.0, \
    2027025.0 ) )

  n_vec = np.array ( ( 
    0, \
     1,  2,  3,  4,  5, \
     6,  7,  8,  9, 10, \
    11, 12, 13, 14, 15 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    f = 0.0
  else:
    n = n_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, f

def r8_factorial2_values_test ( ):

#*****************************************************************************80
#
## r8_factorial2_values_test() tests r8_factorial2_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    07 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'r8_factorial2_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  r8_factorial2_values returns values of the double factorial function.' )
  print ( '' )
  print ( '     N        N!!' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, f = r8_factorial2_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '%6d  %14.6g' % ( n, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'r8_factorial2_values_test:' )
  print ( '  Normal end of execution.' )
  return

def r8_factorial_log_values ( n_data ):

#*****************************************************************************80
#
## r8_factorial_log_values returns values of log(n!).
#
#  Discussion:
#
#    The function log(n!) can be written as
#
#     log(n!) = sum ( 1 <= i <= n ) log ( i )
#
#    In Mathematica, the function can be evaluated by:
#
#      Log[n!]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#    Daniel Zwillinger, editor,
#    CRC Standard Mathematical Tables and Formulae,
#    30th Edition,
#    CRC Press, 1996.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 27

  f_vec = np.array ( ( \
     0.0000000000000000E+00, \
     0.0000000000000000E+00, \
     0.6931471805599453E+00, \
     0.1791759469228055E+01, \
     0.3178053830347946E+01, \
     0.4787491742782046E+01, \
     0.6579251212010101E+01, \
     0.8525161361065414E+01, \
     0.1060460290274525E+02, \
     0.1280182748008147E+02, \
     0.1510441257307552E+02, \
     0.1750230784587389E+02, \
     0.1998721449566189E+02, \
     0.2255216385312342E+02, \
     0.2519122118273868E+02, \
     0.2789927138384089E+02, \
     0.3067186010608067E+02, \
     0.3350507345013689E+02, \
     0.3639544520803305E+02, \
     0.3933988418719949E+02, \
     0.4233561646075349E+02, \
     0.5800360522298052E+02, \
     0.1484777669517730E+03, \
     0.3637393755555635E+03, \
     0.6050201058494237E+03, \
     0.2611330458460156E+04, \
     0.5912128178488163E+04 ))

  n_vec = np.array ( ( \
       0, \
       1, \
       2, \
       3, \
       4, \
       5, \
       6, \
       7, \
       8, \
       9, \
      10, \
      11, \
      12, \
      13, \
      14, \
      15, \
      16, \
      17, \
      18, \
      19, \
      20, \
      25, \
      50, \
     100, \
     150, \
     500, \
    1000 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    f = 0
  else:
    n = n_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, f

def r8_factorial_log_values_test ( ):

#*****************************************************************************80
#
## r8_factorial_log_values_test() tests r8_factorial_log_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    13 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'r8_factorial_log_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  r8_factorial_log_values returns values of the log factorial function.' )
  print ( '' )
  print ( '          N          r8_factorial_log(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, fn = r8_factorial_log_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %8d  %14.6g' % ( n, fn ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'r8_factorial_log_values_test:' )
  print ( '  Normal end of execution.' )
  return

def r8_factorial_values ( n_data ):

#*****************************************************************************80
#
## r8_factorial_values returns values of the real factorial function.
#
#  Discussion:
#
#    0! = 1
#    I! = Product ( 1 <= J <= I ) J
#
#    Although the factorial is an integer valued function, it quickly
#    becomes too large for an integer to hold.  This routine still accepts
#    an integer as the input argument, but returns the function value
#    as a real number.
#
#    In Mathematica, the function can be evaluated by:
#
#      n!
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the argument of the function.
#
#    real FN, the value of the function.
#
  import numpy as np

  n_max = 25

  fn_vec = np.array ( [ \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.6000000000000000E+01, \
     0.2400000000000000E+02, \
     0.1200000000000000E+03, \
     0.7200000000000000E+03, \
     0.5040000000000000E+04, \
     0.4032000000000000E+05, \
     0.3628800000000000E+06, \
     0.3628800000000000E+07, \
     0.3991680000000000E+08, \
     0.4790016000000000E+09, \
     0.6227020800000000E+10, \
     0.8717829120000000E+11, \
     0.1307674368000000E+13, \
     0.2092278988800000E+14, \
     0.3556874280960000E+15, \
     0.6402373705728000E+16, \
     0.1216451004088320E+18, \
     0.2432902008176640E+19, \
     0.1551121004333099E+26, \
     0.3041409320171338E+65, \
     0.9332621544394415E+158, \
     0.5713383956445855E+263 ] )

  n_vec = np.array ( [ \
       0, \
       1, \
       2, \
       3, \
       4, \
       5, \
       6, \
       7, \
       8, \
       9, \
      10, \
      11, \
      12, \
      13, \
      14, \
      15, \
      16, \
      17, \
      18, \
      19, \
      20, \
      25, \
      50, \
     100, \
     150 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    fn = 0
  else:
    n = n_vec[n_data]
    fn = fn_vec[n_data]
    n_data = n_data + 1

  return n_data, n, fn

def r8_factorial_values_test ( ):

#*****************************************************************************80
#
## r8_factorial_values_test() tests r8_factorial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    27 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'r8_factorial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  r8_factorial_values returns values of the real factorial function.' )
  print ( '' )
  print ( '          N          r8_factorial(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, fn = r8_factorial_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %8d  %14.6g' % ( n, fn ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'r8_factorial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def r8_fall_values ( n_data ):

#*****************************************************************************80
#
## r8_fall_values returns values of the falling factorial function.
#
#  Discussion:
#
#    The definition of the falling factorial function is
#
#      (m)_n = (m)! / (m-n)!
#            = ( m ) * ( m - 1 ) * ( m - 2 ) \ * ( m - n + 1 )
#            = Gamma ( m + 1 ) / Gamma ( m - n + 1 )
#
#    We assume 0 <= N <= M.
#
#    In Mathematica, the function can be evaluated by:
#
#      FactorialPower[m,n]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, integer N, the arguments of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 15

  f_vec = np.array ( [ 
       120.0000000000000,  \
        163.1601562500000, \
        216.5625000000000, \
        281.6601562500000, \
        360.0000000000000, \
        1.000000000000000, \
        7.500000000000000, \
        48.75000000000000, \
        268.1250000000000, \
        1206.562500000000, \
        4222.968750000000, \
        10557.42187500000, \
        15836.13281250000, \
        7918.066406250000, \
        -3959.03320312500 ] )

  n_vec = np.array ( [ 
        4, \
        4, \
        4, \
        4, \
        4, \
        0, \
        1, \
        2, \
        3, \
        4, \
        5, \
        6, \
        7, \
        8, \
        9  ] )

  x_vec = np.array ( [ 
        5.00, \
        5.25, \
        5.50, \
        5.75, \
        6.00, \
        7.50, \
        7.50, \
        7.50, \
        7.50, \
        7.50, \
        7.50, \
        7.50, \
        7.50, \
        7.50, \
        7.50 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    n = 0
    f = 0.0
  else:
    x = x_vec[n_data]
    n = n_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, n, f

def r8_fall_values_test ( ):

#*****************************************************************************80
#
## r8_fall_values_test() tests r8_fall_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'r8_fall_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  r8_fall_values returns values of the falling factorial.' )
  print ( '' )
  print ( '          X         N          r8_fall(X,N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, n, f = r8_fall_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %8.4f  %8d  %24.16g' % ( x, n, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'r8_fall_values_test:' )
  print ( '  Normal end of execution.' )
  return

def r8_rise_values ( n_data ):

#*****************************************************************************80
#
## r8_rise_values returns values of the rising factorial function.
#
#  Discussion:
#
#    The rising factorial function is sometimes symbolized by (m)_n.
#
#    The definition is
#
#      (m)_n = (m-1+n)! / (m-1)!
#            = ( m ) * ( m + 1 ) * ( m + 2 ) \ * ( m - 1 + n )
#            = Gamma ( m + n ) / Gamma ( m )
#
#    We assume 0 <= N <= M.
#
#    In Mathematica, the function can be evaluated by:
#
#      Pochhammer[m,n]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    16 December 2014
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, integer N, the arguments of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 15

  f_vec = np.array ( [ 
       1680.000000000000, \
       1962.597656250000, \
       2279.062500000000, \
       2631.972656250000, \
       3024.000000000000, \
       1.000000000000000, \
       7.500000000000000, \
       63.75000000000000, \
       605.6250000000000, \
       6359.062500000000, \
       73129.21875000000, \
       914115.2343750000, \
       1.234055566406250E+07, \
       1.789380571289063E+08, \
       2.773539885498047E+09 ] )

  n_vec = np.array ( [ 
       4, \
       4, \
       4, \
       4, \
       4, \
       0, \
       1, \
       2, \
       3, \
       4, \
       5, \
       6, \
       7, \
       8, \
       9 ] )

  x_vec = np.array ( [ 
       5.00, \
       5.25, \
       5.50, \
       5.75, \
       6.00, \
       7.50, \
       7.50, \
       7.50, \
       7.50, \
       7.50, \
       7.50, \
       7.50, \
       7.50, \
       7.50, \
       7.50 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    n = 0
    f = 0.0
  else:
    x = x_vec[n_data]
    n = n_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, n, f

def r8_rise_values_test ( ):

#*****************************************************************************80
#
## r8_rise_values_test() tests r8_rise_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 December 2014
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'r8_rise_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  r8_rise_values returns values of the rising factorial.' )
  print ( '' )
  print ( '          X         N          r8_rise(X,N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, n, f = r8_rise_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %8.4f  %8d  %24.16g' % ( x, n, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'r8_rise_values_test:' )
  print ( '  Normal end of execution.' )
  return

def rayleigh_cdf_values ( n_data ):

#*****************************************************************************80
#
## rayleigh_cdf_values returns some values of the Rayleigh CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = RayleighDistribution [ sigma ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real SIGMA, the shape parameter of the distribution.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 9

  f_vec = np.array ( ( \
     0.8646647167633873E+00, \
     0.9996645373720975E+00, \
     0.9999999847700203E+00, \
     0.999999999999987E+00, \
     0.8646647167633873E+00, \
     0.3934693402873666E+00, \
     0.1992625970831920E+00, \
     0.1175030974154046E+00, \
     0.7688365361336422E-01 ))

  sigma_vec = np.array ( ( \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01 ))

  x_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    sigma = 0.0
    x = 0.0
    f = 0.0
  else:
    sigma = sigma_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, sigma, x, f

def rayleigh_cdf_values_test ( ):

#*****************************************************************************80
#
## rayleigh_cdf_values_test() tests rayleigh_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'rayleigh_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  rayleigh_cdf_values stores values of the Rayleigh CDF.' )
  print ( '' )
  print ( '      SIGMA       X        rayleigh_cdf(SIGMA,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, sigma, x, f = rayleigh_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16g' % ( sigma, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'rayleigh_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def scaled_inverse_chi_square_pdf_values ( n_data ):

#*****************************************************************************80
#
## scaled_inverse_chi_square_pdf_values: scaled inverse chi square PDF values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 August 2015
#
#  Author:
#
#    John Burkardt
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real DF, the degrees of freedom.
#
#    real XI, the scale parameter.
#
#    real X, the argument of the function.
#
#    real FX, the value of the function.
#
  import numpy as np

  n_max = 18

  df_vec = np.array ( [ \
     1.0, \
     2.0, \
     1.0, \
     2.0, \
     1.0, \
     2.0, \
     1.0, \
     2.0, \
     1.0, \
     2.0, \
     1.0, \
     2.0, \
     1.0, \
     2.0, \
     1.0, \
     2.0, \
     1.0, \
     2.0 ] )
  fx_vec = np.array ( [ \
     0.7322491280963244, \
     0.3368973499542734, \
     0.9036119633409063, \
     1.026062482798735, \
     0.5968580144169457, \
     0.8953274901880941, \
     0.08500366602520342, \
     0.004539992976248485, \
     0.3661245640481622, \
     0.1684486749771367, \
     0.4518059816704532, \
     0.5130312413993675, \
     0.0008099910956089117, \
     4.122307244877116E-07, \
     0.04250183301260171, \
     0.002269996488124243, \
     0.1830622820240811, \
     0.08422433748856834 ] )
  x_vec = np.array ( [ \
    0.10, \
    0.10, \
    0.20, \
    0.20, \
    0.40, \
    0.40, \
    0.10, \
    0.10, \
    0.20, \
    0.20, \
    0.40, \
    0.40, \
    0.10, \
    0.10, \
    0.20, \
    0.20, \
    0.40, \
    0.40 ] )
  xi_vec = np.array ( [ \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    0.50, \
    1.00, \
    1.00, \
    1.00, \
    1.00, \
    1.00, \
    1.00, \
    2.00, \
    2.00, \
    2.00, \
    2.00, \
    2.00, \
    2.00 ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    df = 0.0
    xi = 0.0
    x = 0.0
    fx = 0.0
  else:
    df = df_vec[n_data]
    xi = xi_vec[n_data]
    x = x_vec[n_data]
    fx = fx_vec[n_data]
    n_data = n_data + 1

  return n_data, df, xi, x, fx

def scaled_inverse_chi_square_pdf_values_test ( ):

#*****************************************************************************80
#
## scaled_inverse_chi_square_pdf_values_test() tests scaled_inverse_chi_square_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    05 August 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'scaled_inverse_chi_square_pdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  scaled_inverse_chi_square_pdf_values returns values of' )
  print ( '  the scaled inverse Chi Square Probability Density Function.' )
  print ( '' )
  print ( '        DF        XI         X         PDF' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, df, xi, x, fx = scaled_inverse_chi_square_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %8g  %8g  %8g  %24.16g' % ( df, xi, x, fx ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'scaled_inverse_chi_square_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def secvir_values ( n_data ):

#*****************************************************************************80
#
## secvir_values returns some values of the second virial coefficient.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Lester Haar, John Gallagher and George Kell,
#    NBS/NRC Steam Tables:
#    Thermodynamic and transport Properties and Computer Programs
#      for Vapor and Liquid States of Water in SI Units,
#    Hemisphere Publishing Corporation, Washington, 1984,
#    TJ270.H3, pages 24-25.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real TC, the temperature, in degrees Celsius.
#
#    real VIR, the second virial coefficient, in
#    m^3/kg.
#
  import numpy as np

  n_max = 19

  tc_vec = np.array ( ( \
        0.0E+00, \
        5.0E+00, \
       10.0E+00, \
       20.0E+00, \
       30.0E+00, \
       40.0E+00, \
       60.0E+00, \
       90.0E+00, \
      120.0E+00, \
      150.0E+00, \
      180.0E+00, \
      210.0E+00, \
      240.0E+00, \
      300.0E+00, \
      400.0E+00, \
      500.0E+00, \
      700.0E+00, \
     1000.0E+00, \
     2000.0E+00 ))

  vir_vec = np.array ( ( \
     -98.96E+00, \
     -90.08E+00, \
     -82.29E+00, \
     -69.36E+00, \
     -59.19E+00, \
     -51.07E+00, \
     -39.13E+00, \
     -27.81E+00, \
     -20.83E+00, \
     -16.21E+00, \
     -12.98E+00, \
     -10.63E+00, \
      -8.85E+00, \
      -6.39E+00, \
      -4.03E+00, \
      -2.71E+00, \
      -1.32E+00, \
      -0.39E+00, \
       0.53E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    tc = 0.0
    vir = 0.0
  else:
    tc = tc_vec[n_data]
    vir = vir_vec[n_data]
    n_data = n_data + 1

  return n_data, tc, vir

def secvir_values_test ( ):

#*****************************************************************************80
#
## secvir_values_test() tests secvir_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'secvir_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  secvir_values stores values of the second virial function.' )
  print ( '' )
  print ( '      TC         VIR' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, tc, vir = secvir_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f %24.16f' % ( tc, vir ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'secvir_values_test:' )
  print ( '  Normal end of execution.' )
  return

def shi_values ( n_data ):

#*****************************************************************************80
#
## shi_values returns some values of the hyperbolic sine integral function.
#
#  Discussion:
#
#    SHI(X) = integral ( 0 <= T <= X ) sinh ( T ) / T dt
#
#    In Mathematica, the function can be evaluated by:
#
#      SinhIntegral[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 16

  f_vec = np.array ( ( \
    0.5069967498196672, \
    0.6121303965633808, \
    0.7193380189288998, \
    0.8289965633789345, \
    0.9414978265114335, \
    1.057250875375729, \
    1.300250361022057, \
    1.561713388361002, \
    1.845814141358504, \
    2.157290343425901, \
    2.501567433354976, \
    3.549340406224435, \
    4.973440475859807, \
    6.966162067504942, \
    9.817326911233034, \
    13.96788504934715  ))

  x_vec = np.array ( ( \
      0.5E+00, \
      0.6E+00, \
      0.7E+00, \
      0.8E+00, \
      0.9E+00, \
      1.0E+00, \
      1.2E+00, \
      1.4E+00, \
      1.6E+00, \
      1.8E+00, \
      2.0E+00, \
      2.5E+00, \
      3.0E+00, \
      3.5E+00, \
      4.0E+00, \
      4.5E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def shi_values_test ( ):

#*****************************************************************************80
#
## shi_values_test() tests shi_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    20 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'shi_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  shi_values stores values of the SHI function.' )
  print ( '' )
  print ( '      X         SHI(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = shi_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'shi_values_test:' )
  print ( '  Normal end of execution.' )
  return

def sigma_values ( n_data ):

#*****************************************************************************80
#
## sigma_values returns some values of the Sigma function.
#
#  Discussion:
#
#    SIGMA(N) is the sum of the distinct divisors of N, including 1 and N.
#
#    In Mathematica, the function can be evaluated by:
#
#      DivisorSigma[1,n]
#
#  First values:
#
#     N  SIGMA(N)
#
#     1    1
#     2    3
#     3    4
#     4    7
#     5    6
#     6   12
#     7    8
#     8   15
#     9   13
#    10   18
#    11   12
#    12   28
#    13   14
#    14   24
#    15   24
#    16   31
#    17   18
#    18   39
#    19   20
#    20   42
#
#  Formula:
#
#    SIGMA(U*V) = SIGMA(U) * SIGMA(V) if U and V are relatively prime.
#
#    SIGMA(P^K) = ( P^(K+1) - 1 ) / ( P - 1 ) if P is prime.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the argument of the Sigma function.
#
#    integer C, the value of the Sigma function.
#
  import numpy as np

  n_max = 20

  c_vec = np.array ( ( \
     1,    3,    4,    7,    6,   12,    8,   15,   13,   18, \
    72,  128,  255,  176,  576, 1170,  618,  984, 2232, 2340 ))

  n_vec = np.array ( ( \
      1,   2,   3,   4,   5,   6,   7,   8,   9,   10, \
     30, 127, 128, 129, 210, 360, 617, 815, 816, 1000 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    c = 0
  else:
    n = n_vec[n_data]
    c = c_vec[n_data]
    n_data = n_data + 1

  return n_data, n, c

def sigma_values_test ( ):

#*****************************************************************************80
#
## sigma_values_test() tests sigma_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'sigma_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  sigma_values stores values of the SIGMA function.' )
  print ( '' )
  print ( '             N    SIGMA(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, c = sigma_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12d' % ( n, c ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'sigma_values_test:' )
  print ( '  Normal end of execution.' )
  return

def sin_degree_values ( n_data ):

#*****************************************************************************80
#
## sin_degree_values: the sine function with argument in degrees.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Sin[x Degree]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 22

  f_vec = np.array ( ( \
    -0.087155742747658173558, \
     0.000000000000000000000, \
     0.017452406437283512819, \
     0.034899496702500971646, \
     0.052335956242943832722, \
     0.069756473744125300776, \
     0.087155742747658173558, \
     0.17364817766693034885, \
     0.25881904510252076235, \
     0.50000000000000000000, \
     0.70710678118654752440, \
     0.86602540378443864676, \
     0.96592582628906828675, \
     0.99619469809174553230, \
     0.99756405025982424761, \
     0.99862953475457387378, \
     0.99939082701909573001, \
     0.99984769515639123916, \
     1.0000000000000000000, \
     0.99984769515639123916, \
     0.96592582628906828675, \
     0.00000000000000000000 ))
  x_vec = np.array ( ( \
     -5.0, \
      0.0, \
      1.0, \
      2.0, \
      3.0, \
      4.0, \
      5.0, \
     10.0, \
     15.0, \
     30.0, \
     45.0, \
     60.0, \
     75.0, \
     85.0, \
     86.0, \
     87.0, \
     88.0, \
     89.0, \
     90.0, \
     91.0, \
    105.0, \
    180.0 ))


  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def sin_degree_values_test ( ):

#*****************************************************************************80
#
## sin_degree_values_test() tests sin_degree_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'sin_degree_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  sin_degree_values stores values of the SIN function.' )
  print ( '' )
  print ( '      X         SIN(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = sin_degree_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'sin_degree_values_test:' )
  print ( '  Normal end of execution.' )
  return

def sinh_values ( n_data ):

#*****************************************************************************80
#
## sinh_values returns some values of the hyperbolic sine function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Sinh[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 18

  f_vec = np.array ( ( \
      -74.203210577788758977, \
       -1.1752011936438014569, \
        0.00000000000000000000, \
        0.10016675001984402582, \
        0.20133600254109398763, \
        0.30452029344714261896, \
        0.41075232580281550854, \
        0.52109530549374736162, \
        0.63665358214824127112, \
        0.75858370183953350346, \
        0.88810598218762300657, \
        1.0265167257081752760, \
        1.1752011936438014569, \
        3.6268604078470187677, \
       10.017874927409901899, \
       27.289917197127752449, \
       74.203210577788758977, \
    11013.232874703393377 ))

  x_vec = np.array ( ( \
   -5.0, \
   -1.0, \
    0.0, \
    0.1, \
    0.2, \
    0.3, \
    0.4, \
    0.5, \
    0.6, \
    0.7, \
    0.8, \
    0.9, \
    1.0, \
    2.0, \
    3.0, \
    4.0, \
    5.0, \
   10.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def sinh_values_test ( ):

#*****************************************************************************80
#
## sinh_values_test() tests sinh_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'sinh_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  sinh_values stores values of the SINH function.' )
  print ( '' )
  print ( '      X         SINH(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = sinh_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'sinh_values_test:' )
  print ( '  Normal end of execution.' )
  return

def sin_power_int_values ( n_data ):

#*****************************************************************************80
#
## sin_power_int_values returns some values of the sine power integral.
#
#  Discussion:
#
#    The function has the form
#
#      sin_power_int(A,B,N) = Integral ( A <= T <= B ) ( sin(T) )^N dt
#
#    In Mathematica, the function can be evaluated by:
#
#      Integrate [ ( Sin[x] )^n, { x, a, b } ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, B, the limits of integration.
#
#    integer N, the power.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 10

  a_vec = np.array ( ( \
      0.10E+02, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.00E+00, \
      0.10E+01, \
      0.00E+00, \
      0.00E+00 ))

  b_vec = np.array ( ( \
      0.20E+02, \
      0.10E+01, \
      0.10E+01, \
      0.10E+01, \
      0.10E+01, \
      0.10E+01, \
      0.20E+01, \
      0.20E+01, \
      0.10E+01, \
      0.10E+01 ))

  f_vec = np.array ( ( \
     0.10000000000000000000E+02, \
     0.45969769413186028260E+00, \
     0.27267564329357957615E+00, \
     0.17894056254885809051E+00, \
     0.12402556531520681830E+00, \
     0.88974396451575946519E-01, \
     0.90393123848149944133E+00, \
     0.81495684202992349481E+00, \
     0.21887522421729849008E-01, \
     0.17023439374069324596E-01 ))

  n_vec = np.array ( ( \
     0, \
     1, \
     2, \
     3, \
     4, \
     5, \
     5, \
     5, \
    10, \
    11 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    b = 0.0
    f = 0.0
    n = 0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    f = f_vec[n_data]
    n = n_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, n, f

def sin_power_int_values_test ( ):

#*****************************************************************************80
#
## sin_power_int_values_test() tests sin_power_int_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'sin_power_int_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  sin_power_int_values stores values of the cosine power integral.' )
  print ( '' )
  print ( '        A             B            N           F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, n, f = sin_power_int_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %6d  %24.16g' % ( a, b, n, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'sin_power_int_values_test:' )
  print ( '  Normal end of execution.' )
  return

def sin_values ( n_data ):

#*****************************************************************************80
#
## sin_values returns some values of the sine function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Sin[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 13

  f_vec = np.array ( ( \
     0.00000000000000000000, \
     0.25881904510252076235, \
     0.47942553860420300027, \
     0.50000000000000000000, \
     0.70710678118654752440, \
     0.84147098480789650665, \
     0.86602540378443864676, \
     1.00000000000000000000, \
     0.90929742682568169540, \
     0.14112000805986722210, \
     0.00000000000000000000, \
    -0.75680249530792825137, \
    -0.95892427466313846889 ))

  x_vec = np.array ( ( \
    0.0000000000000000000, \
    0.26179938779914943654, \
    0.50000000000000000000, \
    0.52359877559829887308, \
    0.78539816339744830962, \
    1.0000000000000000000, \
    1.0471975511965977462, \
    1.5707963267948966192, \
    2.0000000000000000000, \
    3.0000000000000000000, \
    3.1415926535897932385, \
    4.0000000000000000000, \
    5.0000000000000000000  ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def sin_values_test ( ):

#*****************************************************************************80
#
## sin_values_test() tests sin_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'sin_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  sin_values stores values of the SIN function.' )
  print ( '' )
  print ( '      X         SIN(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = sin_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'sin_values_test:' )
  print ( '  Normal end of execution.' )
  return

def si_values ( n_data ):

#*****************************************************************************80
#
## si_values returns some values of the sine integral function.
#
#  Discussion:
#
#    SI(X) = integral ( 0 <= T <= X ) sin ( T ) / T dt
#
#    In Mathematica, the function can be evaluated by:
#
#      SinIntegral[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 16

  f_vec = np.array ( ( \
     0.4931074180430667E+00, \
     0.5881288096080801E+00, \
     0.6812222391166113E+00, \
     0.7720957854819966E+00, \
     0.8604707107452929E+00, \
     0.9460830703671830E+00, \
     0.1108047199013719E+01, \
     0.1256226732779218E+01, \
     0.1389180485870438E+01, \
     0.1505816780255579E+01, \
     0.1605412976802695E+01, \
     0.1778520173443827E+01, \
     0.1848652527999468E+01, \
     0.1833125398665997E+01, \
     0.1758203138949053E+01, \
     0.1654140414379244E+01 ))

  x_vec = np.array ( ( \
      0.5E+00, \
      0.6E+00, \
      0.7E+00, \
      0.8E+00, \
      0.9E+00, \
      1.0E+00, \
      1.2E+00, \
      1.4E+00, \
      1.6E+00, \
      1.8E+00, \
      2.0E+00, \
      2.5E+00, \
      3.0E+00, \
      3.5E+00, \
      4.0E+00, \
      4.5E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def si_values_test ( ):

#*****************************************************************************80
#
## si_values_test() tests si_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'si_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  si_values stores values of the SI function.' )
  print ( '' )
  print ( '      X         SI(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = si_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'si_values_test:' )
  print ( '  Normal end of execution.' )
  return

def six_j_values ( n_data ):

#*****************************************************************************80
#
## six_j_values returns some values of the Wigner 6J function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      SixJSymbol[{j1,j2,j3},{j4,j5,j6}]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real J1, J2, J3, J4, J5, J6, the arguments 
#    of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 15

  f_vec = np.array ( ( \
     0.03490905138373300,  \
    -0.03743025039659792,  \
     0.01890866390959560,  \
     0.007342448254928643, \
    -0.02358935185081794,  \
     0.01913476955215437,  \
     0.001288017397724172, \
    -0.01930018366290527,  \
     0.01677305949382889,  \
     0.005501147274850949, \
    -0.02135439790896831,  \
     0.003460364451435387, \
     0.02520950054795585,  \
     0.01483990561221713,  \
     0.002708577680633186 ))
  j1_vec = np.array ( ( \
    1.0, \
    2.0, \
    3.0, \
    4.0, \
    5.0, \
    6.0, \
    7.0, \
    8.0, \
    9.0, \
   10.0, \
   11.0, \
   12.0, \
   13.0, \
   14.0, \
   15.0 ))
  j2_vec = np.array ( ( \
    8.0, \
    8.0, \
    8.0, \
    8.0, \
    8.0, \
    8.0, \
    8.0, \
    8.0, \
    8.0, \
    8.0, \
    8.0, \
    8.0, \
    8.0, \
    8.0, \
    8.0 ))
  j3_vec = np.array ( ( \
    7.0, \
    7.0, \
    7.0, \
    7.0, \
    7.0, \
    7.0, \
    7.0, \
    7.0, \
    7.0, \
    7.0, \
    7.0, \
    7.0, \
    7.0, \
    7.0, \
    7.0 ))
  j4_vec = np.array ( ( \
    6.5, \
    6.5, \
    6.5, \
    6.5, \
    6.5, \
    6.5, \
    6.5, \
    6.5, \
    6.5, \
    6.5, \
    6.5, \
    6.5, \
    6.5, \
    6.5, \
    6.5 ))
  j5_vec = np.array ( ( \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5 ))
  j6_vec = np.array ( ( \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5, \
    7.5 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    j1 = 0.0
    j2 = 0.0
    j3 = 0.0
    j4 = 0.0
    j5 = 0.0
    j6 = 0.0
    f = 0.0
  else:
    j1 = j1_vec[n_data]
    j2 = j2_vec[n_data]
    j3 = j3_vec[n_data]
    j4 = j4_vec[n_data]
    j5 = j5_vec[n_data]
    j6 = j6_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, j1, j2, j3, j4, j5, j6, f

def six_j_values_test ( ):

#*****************************************************************************80
#
## six_j_values_test() tests six_j_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'six_j_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  six_j_values stores values of the six_j function.' )
  print ( '' )
  print ( '    J1    J2    J3    J4    J5    J6    six_j(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, j1, j2, j3, j4, j5, j6, f = six_j_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4.1f  %4.1f  %4.1f  %4.1f  %4.1f  %4.1f  %24.16f' \
      % ( j1, j2, j3, j4, j5, j6, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'six_j_values_test:' )
  print ( '  Normal end of execution.' )
  return

def sound_values ( n_data ):

#*****************************************************************************80
#
## sound_values returns some values of the speed of sound.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Lester Haar, John Gallagher and George Kell,
#    NBS/NRC Steam Tables:
#    Thermodynamic and transport Properties and Computer Programs
#    for Vapor and Liquid States of Water in SI Units,
#    Hemisphere Publishing Corporation, Washington, 1984,
#    TJ270.H3, page 238-246.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real TC, the temperature, in degrees Celsius.
#
#    real P, the pressure, in bar.
#
#    real C, the speed of sound, in m/s.
#
  import numpy as np

  n_max = 20

  c_vec = np.array ( ( \
     1401.0E+00, \
      472.8E+00, \
      533.7E+00, \
      585.7E+00, \
      609.5E+00, \
      632.2E+00, \
      674.6E+00, \
      713.9E+00, \
      802.0E+00, \
      880.1E+00, \
     1017.8E+00, \
     1115.9E+00, \
     1401.7E+00, \
     1402.6E+00, \
     1409.6E+00, \
     1418.1E+00, \
     1443.1E+00, \
     1484.6E+00, \
     1577.1E+00, \
     1913.4E+00 ))

  p_vec = np.array ( ( \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        5.0E+00, \
       10.0E+00, \
       50.0E+00, \
      100.0E+00, \
      250.0E+00, \
      500.0E+00, \
     1000.0E+00, \
     2500.0E+00 ))

  tc_vec = np.array ( ( \
        0.0E+00, \
      100.0E+00, \
      200.0E+00, \
      300.0E+00, \
      350.0E+00, \
      400.0E+00, \
      500.0E+00, \
      600.0E+00, \
      850.0E+00, \
     1100.0E+00, \
     1600.0E+00, \
     2000.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00, \
        0.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    tc = 0.0
    p = 0.0
    c = 0.0
  else:
    tc = tc_vec[n_data]
    p = p_vec[n_data]
    c = c_vec[n_data]
    n_data = n_data + 1

  return n_data, tc, p, c

def sound_values_test ( ):

#*****************************************************************************80
#
## sound_values_test() tests sound_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'sound_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  sound_values stores values of the SOUND function.' )
  print ( '' )
  print ( '      TC         P        SOUND(TC.P)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, tc, p, c = sound_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %12f  %24.16f' % ( tc, p, c ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'sound_values_test:' )
  print ( '  Normal end of execution.' )
  return

def sphere_unit_area_values ( n_data ):

#*****************************************************************************80
#
## sphere_unit_area_values returns some areas of the unit sphere in ND.
#
#  Discussion:
#
#    The formula for the surface area of the unit sphere in N dimensions is:
#
#      sphere_unit_area ( N ) = 2 * PI^(N/2) / Gamma ( N / 2 )
#
#    Some values of the function include:
#
#       N   Area
#
#       2    2        * PI
#       3  ( 4 /    ) * PI
#       4  ( 2 /   1) * PI^2
#       5  ( 8 /   3) * PI^2
#       6  ( 1 /   1) * PI^3
#       7  (16 /  15) * PI^3
#       8  ( 1 /   3) * PI^4
#       9  (32 / 105) * PI^4
#      10  ( 1 /  12) * PI^5
#
#    For the unit sphere, Area(N) = N * Volume(N)
#
#    In Mathematica, the function can be evaluated by:
#
#      2 * Pi^(n/2) / Gamma[n/2]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the spatial dimension.
#
#    real AREA, the area of the unit sphere 
#    in that dimension.
#
  import numpy as np

  n_max = 20

  area_vec = np.array ( ( \
     0.2000000000000000E+01, \
     0.6283185307179586E+01, \
     0.1256637061435917E+02, \
     0.1973920880217872E+02, \
     0.2631894506957162E+02, \
     0.3100627668029982E+02, \
     0.3307336179231981E+02, \
     0.3246969701133415E+02, \
     0.2968658012464836E+02, \
     0.2550164039877345E+02, \
     0.2072514267328890E+02, \
     0.1602315322625507E+02, \
     0.1183817381218268E+02, \
     0.8389703410491089E+01, \
     0.5721649212349567E+01, \
     0.3765290085742291E+01, \
     0.2396678817591364E+01, \
     0.1478625959000308E+01, \
     0.8858104195716824E+00, \
     0.5161378278002812E+00 ))

  n_vec = np.array ( ( \
     1, \
     2, \
     3, \
     4, \
     5, \
     6, \
     7, \
     8, \
     9, \
    10, \
    11, \
    12, \
    13, \
    14, \
    15, \
    16, \
    17, \
    18, \
    19, \
    20 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0.0
    area = 0.0
  else:
    n = n_vec[n_data]
    area = area_vec[n_data]
    n_data = n_data + 1

  return n_data, n, area

def sphere_unit_area_values_test ( ):

#*****************************************************************************80
#
## sphere_unit_area_values_test() tests sphere_unit_area_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'sphere_unit_area_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  sphere_unit_area_values stores values of the sphere_unit_area function.' )
  print ( '' )
  print ( '      N         sphere_unit_area(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, area = sphere_unit_area_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %24.16f' % ( n, area ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'sphere_unit_area_values_test:' )
  print ( '  Normal end of execution.' )
  return

def sphere_unit_volume_values ( n_data ):

#*****************************************************************************80
#
## sphere_unit_volume_values returns some volumes of the unit sphere in ND.
#
#  Discussion:
#
#    The formula for the volume of the unit sphere in N dimensions is
#
#      Volume(N) = 2 * PI^(N/2) / ( N * Gamma ( N / 2 ) )
#
#    This function satisfies the relationships:
#
#      Volume(N) = 2 * PI * Volume(N-2) / N
#      Volume(N) = Area(N) / N
#
#    Some values of the function include:
#
#       N  Volume
#
#       1    1
#       2    1        * PI
#       3  ( 4 /   3) * PI
#       4  ( 1 /   2) * PI^2
#       5  ( 8 /  15) * PI^2
#       6  ( 1 /   6) * PI^3
#       7  (16 / 105) * PI^3
#       8  ( 1 /  24) * PI^4
#       9  (32 / 945) * PI^4
#      10  ( 1 / 120) * PI^5
#
#    In Mathematica, the function can be evaluated by:
#
#      2 * Pi^(n/2) / ( n * Gamma[n/2] )
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the spatial dimension.
#
#    real VOLUME, the volume of the unit 
#    sphere in that dimension.
#
  import numpy as np

  n_max = 20

  n_vec = np.array ( ( \
     1, \
     2, \
     3, \
     4, \
     5, \
     6, \
     7, \
     8, \
     9, \
    10, \
    11, \
    12, \
    13, \
    14, \
    15, \
    16, \
    17, \
    18, \
    19, \
    20 ))

  volume_vec = np.array ( ( \
     0.2000000000000000E+01, \
     0.3141592653589793E+01, \
     0.4188790204786391E+01, \
     0.4934802200544679E+01, \
     0.5263789013914325E+01, \
     0.5167712780049970E+01, \
     0.4724765970331401E+01, \
     0.4058712126416768E+01, \
     0.3298508902738707E+01, \
     0.2550164039877345E+01, \
     0.1884103879389900E+01, \
     0.1335262768854589E+01, \
     0.9106287547832831E+00, \
     0.5992645293207921E+00, \
     0.3814432808233045E+00, \
     0.2353306303588932E+00, \
     0.1409811069171390E+00, \
     0.8214588661112823E-01, \
     0.4662160103008855E-01, \
     0.2580689139001406E-01  ))

  n_vec = np.array ( ( \
     1, \
     2, \
     3, \
     4, \
     5, \
     6, \
     7, \
     8, \
     9, \
    10, \
    11, \
    12, \
    13, \
    14, \
    15, \
    16, \
    17, \
    18, \
    19, \
    20 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0.0
    volume = 0.0
  else:
    n = n_vec[n_data]
    volume = volume_vec[n_data]
    n_data = n_data + 1

  return n_data, n, volume

def sphere_unit_volume_values_test ( ):

#*****************************************************************************80
#
## sphere_unit_volume_values_test() tests sphere_unit_volume_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    21 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'sphere_unit_volume_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  sphere_unit_volume_values stores values of the sphere_unit_volume function.' )
  print ( '' )
  print ( '      N         sphere_unit_volume(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, volume = sphere_unit_volume_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %24.16f' % ( n, volume ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'sphere_unit_volume_values_test:' )
  print ( '  Normal end of execution.' )
  return

def spherical_harmonic_values ( n_data ):

#*****************************************************************************80
#
## spherical_harmonic_values returns values of spherical harmonic functions.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      SphericalHarmonicY [ l, m, theta, phi ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Eric Weisstein,
#    CRC Concise Encyclopedia of Mathematics,
#    CRC Press, 1998.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer L, integer M, real THETA, PHI, the arguments
#    of the function.
#
#    real YR, YI, the real and imaginary parts of
#    the function.
#
  import numpy as np

  n_max = 20

  l_vec = np.array ( ( \
     0,  1,  2,  \
     3,  4,  5,  \
     5,  5,  5,  \
     5,  4,  4,  \
     4,  4,  4,  \
     3,  3,  3,  \
     3,  3 ))
  m_vec = np.array ( ( \
     0,  0,  1,  \
     2,  3,  5,  \
     4,  3,  2,  \
     1,  2,  2,  \
     2,  2,  2,  \
    -1, -1, -1,  \
    -1, -1 ))
  phi_vec = np.array ( ( \
    0.1047197551196598E+01, 0.1047197551196598E+01, 0.1047197551196598E+01, \
    0.1047197551196598E+01, 0.1047197551196598E+01, 0.6283185307179586E+00, \
    0.6283185307179586E+00, 0.6283185307179586E+00, 0.6283185307179586E+00, \
    0.6283185307179586E+00, 0.7853981633974483E+00, 0.7853981633974483E+00, \
    0.7853981633974483E+00, 0.7853981633974483E+00, 0.7853981633974483E+00, \
    0.4487989505128276E+00, 0.8975979010256552E+00, 0.1346396851538483E+01, \
    0.1795195802051310E+01, 0.2243994752564138E+01 ))
  theta_vec = np.array ( ( \
    0.5235987755982989E+00, 0.5235987755982989E+00, 0.5235987755982989E+00, \
    0.5235987755982989E+00, 0.5235987755982989E+00, 0.2617993877991494E+00, \
    0.2617993877991494E+00, 0.2617993877991494E+00, 0.2617993877991494E+00, \
    0.2617993877991494E+00, 0.6283185307179586E+00, 0.1884955592153876E+01, \
    0.3141592653589793E+01, 0.4398229715025711E+01, 0.5654866776461628E+01, \
    0.3926990816987242E+00, 0.3926990816987242E+00, 0.3926990816987242E+00, \
    0.3926990816987242E+00, 0.3926990816987242E+00 ))
  yi_vec = np.array ( ( \
    0.0000000000000000E+00,  0.0000000000000000E+00, -0.2897056515173922E+00, \
    0.1916222768312404E+00,  0.0000000000000000E+00,  0.0000000000000000E+00, \
    0.3739289485283311E-02, -0.4219517552320796E-01,  0.1876264225575173E+00, \
   -0.3029973424491321E+00,  0.4139385503112256E+00, -0.1003229830187463E+00, \
    0.0000000000000000E+00, -0.1003229830187463E+00,  0.4139385503112256E+00, \
   -0.1753512375142586E+00, -0.3159720118970196E+00, -0.3940106541811563E+00, \
   -0.3940106541811563E+00, -0.3159720118970196E+00 ))
  yr_vec = np.array ( ( \
   0.2820947917738781E+00,  0.4231421876608172E+00, -0.1672616358893223E+00, \
  -0.1106331731112457E+00,  0.1354974113737760E+00,  0.5390423109043568E-03, \
  -0.5146690442951909E-02,  0.1371004361349490E-01,  0.6096352022265540E-01, \
  -0.4170400640977983E+00,  0.0000000000000000E+00,  0.0000000000000000E+00, \
   0.0000000000000000E+00,  0.0000000000000000E+00,  0.0000000000000000E+00, \
   0.3641205966137958E+00,  0.2519792711195075E+00,  0.8993036065704300E-01, \
  -0.8993036065704300E-01, -0.2519792711195075E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    l = 0
    m = 0
    theta = 0.0
    phi = 0.0
    yr = 0.0
    yi = 0.0
  else:
    l = l_vec[n_data]
    m = m_vec[n_data]
    theta = theta_vec[n_data]
    phi = phi_vec[n_data]
    yr = yr_vec[n_data]
    yi = yi_vec[n_data]
    n_data = n_data + 1

  return n_data, l, m, theta, phi, yr, yi

def spherical_harmonic_values_test ( ):

#*****************************************************************************80
#
## spherical_harmonic_values_test() tests spherical_harmonic_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'spherical_harmonic_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  spherical_harmonic_values stores values of the spherical_harmonic function.' )
  print ( '' )
  print ( '   L   M    THETA   PHI               YR                YI' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, l, m, theta, phi, yr, yi = spherical_harmonic_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %2d  %2d  %8f  %8f  %24.16f  %24.16f' % ( l, m, theta, phi, yr, yi ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'spherical_harmonic_values_test:' )
  print ( '  Normal end of execution.' )
  return

def sqrt_values ( n_data ):

#*****************************************************************************80
#
## sqrt_values returns some values of the square root function.
#
#  Discussion:
#
#    SQRT(X) = positive real number Y such that Y * Y = X.
#
#    In Mathematica, the function can be evaluated by:
#
#      Sqrt[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 January 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 14

  f_vec = np.array ( ( \
     0.0000000000000000E+00, \
     0.9000000040950000E-04, \
     0.3000000000000000E+00, \
     0.3162277660168379E+00, \
     0.6324555320336759E+00, \
     0.1000000000000000E+01, \
     0.1414213562373095E+01, \
     0.1732050807568877E+01, \
     0.1772453850905516E+01, \
     0.4358898943540674E+01, \
     0.5385164807134504E+01, \
     0.8426149773176359E+01, \
     0.9848857801796105E+01, \
     0.1111111106055556E+05 ) )

  x_vec = np.array ( ( \
     0.0000000000000000E+00, \
     0.8100000073710001E-08, \
     0.9000000000000000E-01, \
     0.1000000000000000E+00, \
     0.4000000000000000E+00, \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3141592653589793E+01, \
     0.1900000000000000E+02, \
     0.2900000000000000E+02, \
     0.7100000000000000E+02, \
     0.9700000000000000E+02, \
     0.1234567890000000E+09 ) )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def sqrt_values_test ( ):

#*****************************************************************************80
#
## sqrt_values_test() tests sqrt_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    19 January 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'sqrt_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  sqrt_values stores values of the SQRT function.' )
  print ( '' )
  print ( '      X         SQRT(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = sqrt_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'sqrt_values_test:' )
  print ( '  Normal end of execution.' )
  return

def stirling1_values ( n_data ):

#*****************************************************************************80
#
## stirling1_values returns some values of the Stirling numbers, kind 1.
#
#  Discussion:
#
#    The absolute value of the Stirling number S1(N,M) gives the number
#    of permutations on N objects having exactly M cycles, while the
#    sign of the Stirling number records the sign (odd or even) of
#    the permutations.  For example, there are six permutations on 3 objects:
#
#      A B C   3 cycles (A) (B) (C)
#      A C B   2 cycles (A) (BC)
#      B A C   2 cycles (AB) (C)
#      B C A   1 cycle  (ABC)
#      C A B   1 cycle  (ABC)
#      C B A   2 cycles (AC) (B)
#
#    There are 
#
#      2 permutations with 1 cycle, and S1(3,1) = 2
#      3 permutations with 2 cycles, and S1(3,2) = -3,
#      1 permutation with 3 cycles, and S1(3,3) = 1.
#
#    Since there are N! permutations of N objects, the sum of the absolute 
#    values of the Stirling numbers in a given row, 
#
#      sum ( 1 <= I <= N ) abs ( S1(N,I) ) = N!
#
#  First terms:
#
#    N/M:  1     2      3     4     5    6    7    8
#
#    1     1     0      0     0     0    0    0    0
#    2    -1     1      0     0     0    0    0    0
#    3     2    -3      1     0     0    0    0    0
#    4    -6    11     -6     1     0    0    0    0
#    5    24   -50     35   -10     1    0    0    0
#    6  -120   274   -225    85   -15    1    0    0
#    7   720 -1764   1624  -735   175  -21    1    0
#    8 -5040 13068 -13132  6769 -1960  322  -28    1
#
#    In Mathematica, the function can be evaluated by:
#
#      StirlingS1[n,m]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, M, the arguments of the function.
#
#    integer F, the value of the function.
#
  import numpy as np

  n_max = 16

  f_vec = np.array ( ( \
           0, \
           1, \
          -3, \
          11, \
         -50, \
         274, \
       -1764, \
       13068, \
     -109584, \
     1026576, \
      -13132, \
        6769, \
       -1960, \
         322, \
         -28, \
           1 ))

  m_vec = np.array ( ( \
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 5, 6, 7, 8 ))

  n_vec = np.array ( ( \
     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 8, 8, 8, 8, 8, 8 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    m = 0
    f = 0
  else:
    n = n_vec[n_data]
    m = m_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, m, f

def stirling1_values_test ( ):

#*****************************************************************************80
#
## stirling1_values_test() tests stirling1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'stirling1_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  stirling1_values stores values of the STIRLING1 function.' )
  print ( '' )
  print ( '             N             M        STIRLING1(N,M)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, m, f = stirling1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12d  %12d' % ( n, m, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'stirling1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def stirling2_values ( n_data ):

#*****************************************************************************80
#
## stirling2_values returns some values of the Stirling numbers, kind 2.
#
#  Discussion:
#
#    S2(N,M) represents the number of distinct partitions of N elements
#    into M nonempty sets.  For a fixed N, the sum of the Stirling
#    numbers S2(N,M) is represented by B(N), called "Bell's number",
#    and represents the number of distinct partitions of N elements.
#
#    For example, with 4 objects, there are:
#
#    1 partition into 1 set:
#
#      (A,B,C,D)
#
#    7 partitions into 2 sets:
#
#      (A,B,C) (D)
#      (A,B,D) (C)
#      (A,C,D) (B)
#      (A) (B,C,D)
#      (A,B) (C,D)
#      (A,C) (B,D)
#      (A,D) (B,C)
#
#    6 partitions into 3 sets:
#
#      (A,B) (C) (D)
#      (A) (B,C) (D)
#      (A) (B) (C,D)
#      (A,C) (B) (D)
#      (A,D) (B) (C)
#      (A) (B,D) (C)
#
#    1 partition into 4 sets:
#
#      (A) (B) (C) (D)
#
#    So S2(4,1) = 1, S2(4,2) = 7, S2(4,3) = 6, S2(4,4) = 1, and B(4) = 15.
#
#
#  First terms:
#
#    N/M: 1    2    3    4    5    6    7    8
#
#    1    1    0    0    0    0    0    0    0
#    2    1    1    0    0    0    0    0    0
#    3    1    3    1    0    0    0    0    0
#    4    1    7    6    1    0    0    0    0
#    5    1   15   25   10    1    0    0    0
#    6    1   31   90   65   15    1    0    0
#    7    1   63  301  350  140   21    1    0
#    8    1  127  966 1701 1050  266   28    1
#
#    In Mathematica, the function can be evaluated by:
#
#      StirlingS2[n,m]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, M, the arguments of the function.
#
#    integer F, the value of the function.
#
  import numpy as np

  n_max = 16

  f_vec = np.array ( ( \
           0, \
           1, \
           3, \
           7, \
          15, \
          31, \
          63, \
         127, \
         255, \
         511, \
         966, \
        1701, \
        1050, \
         266, \
          28, \
           1 ))

  m_vec = np.array ( ( \
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 5, 6, 7, 8 ))

  n_vec = np.array ( ( \
     1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 8, 8, 8, 8, 8, 8 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    m = 0
    f = 0
  else:
    n = n_vec[n_data]
    m = m_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, m, f

def stirling2_values_test ( ):

#*****************************************************************************80
#
## stirling2_values_test() tests stirling2_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'stirling2_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  stirling2_values stores values of the STIRLING2 function.' )
  print ( '' )
  print ( '             N             M        STIRLING2(N,M)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, m, f = stirling2_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12d  %12d' % ( n, m, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'stirling2_values_test:' )
  print ( '  Normal end of execution.' )
  return

def stromgen_values ( n_data ):

#*****************************************************************************80
#
## stromgen_values returns some values of the STROMGEN function.
#
#  Discussion:
#
#    The function is defined by:
#
#      STROMGEN(X) = Integral ( 0 <= t <= X ) t^7 * exp(2*t) / (exp(t)-1)^3 dt
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
     0.21901065985698662316E-15, \
     0.22481399438625244761E-12, \
     0.23245019579558857124E-09, \
     0.24719561475975007037E-06, \
     0.28992610989833245669E-03, \
     0.10698146390809715091E-01, \
     0.89707650964424730705E-01, \
     0.40049605719592888440E+00, \
     0.30504104398079096598E+01, \
     0.11367704858439426431E+02, \
     0.12960679405324786954E+02, \
     0.18548713944748505675E+02, \
     0.27866273821903121400E+02, \
     0.51963334071699323351E+02, \
     0.10861016747891228129E+03, \
     0.15378903316556621624E+03, \
     0.19302665532558721516E+03, \
     0.19636850166006541482E+03, \
     0.19651946766008214217E+03, \
     0.19651956920868316152E+03 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0078125000E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.1250000000E+00, \
       4.5000000000E+00, \
       5.0000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00 )) 

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def stromgen_values_test ( ):

#*****************************************************************************80
#
## stromgen_values_test() tests stromgen_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'stromgen_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  stromgen_values stores values of the STROMGEN function.' )
  print ( '' )
  print ( '      X         STROMGEN(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = stromgen_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'stromgen_values_test:' )
  print ( '  Normal end of execution.' )
  return

def struve_h0_values ( n_data ):

#*****************************************************************************80
#
## struve_h0_values returns some values of the Struve H0 function.
#
#  Discussion:
#
#    The function is defined by:
#
#      HO(x) = 2/pi * Integral ( 0 <= t <= pi/2 ) sin ( x * cos ( t ) ) dt
#
#    In Mathematica, the function can be evaluated by:
#
#      StruveH[0,x]
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
      0.12433974658847434366E-02, \
     -0.49735582423748415045E-02, \
      0.39771469054536941564E-01, \
     -0.15805246001653314198E+00, \
      0.56865662704828795099E+00, \
      0.66598399314899916605E+00, \
      0.79085884950809589255E+00, \
     -0.13501457342248639716E+00, \
      0.20086479668164503137E+00, \
     -0.11142097800261991552E+00, \
     -0.17026804865989885869E+00, \
     -0.13544931808186467594E+00, \
      0.94393698081323450897E-01, \
     -0.10182482016001510271E+00, \
      0.96098421554162110012E-01, \
     -0.85337674826118998952E-01, \
     -0.76882290637052720045E-01, \
      0.47663833591418256339E-01, \
     -0.70878751689647343204E-01, \
      0.65752908073352785368E-01 ))

  x_vec = np.array ( ( \
        0.0019531250E+00, \
       -0.0078125000E+00, \
        0.0625000000E+00, \
       -0.2500000000E+00, \
        1.0000000000E+00, \
        1.2500000000E+00, \
        2.0000000000E+00, \
       -4.0000000000E+00, \
        7.5000000000E+00, \
       11.0000000000E+00, \
       11.5000000000E+00, \
      -16.0000000000E+00, \
       20.0000000000E+00, \
       25.0000000000E+00, \
      -30.0000000000E+00, \
       50.0000000000E+00, \
       75.0000000000E+00, \
      -80.0000000000E+00, \
      100.0000000000E+00, \
     -125.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def struve_h0_values_test ( ):

#*****************************************************************************80
#
## struve_h0_values_test() tests struve_h0_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'struve_h0_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  struve_h0_values stores values of the struve_h0 function.' )
  print ( '' )
  print ( '      X         struve_h0(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = struve_h0_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'struve_h0_values_test:' )
  print ( '  Normal end of execution.' )
  return

def struve_h1_values ( n_data ):

#*****************************************************************************80
#
## struve_h1_values returns some values of the Struve H1 function.
#
#  Discussion:
#
#    The function is defined by:
#
#      H1(x) = 2*x/pi * Integral ( 0 <= t <= pi/2 ) 
#        sin ( x * cos ( t ) )^2 * sin ( t ) dt
#
#    In Mathematica, the function can be evaluated by:
#
#      StruveH[1,x]
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
     0.80950369576367526071E-06, \
     0.12952009724113229165E-04, \
     0.82871615165407083021E-03, \
     0.13207748375849572564E-01, \
     0.19845733620194439894E+00, \
     0.29853823231804706294E+00, \
     0.64676372828356211712E+00, \
     0.10697266613089193593E+01, \
     0.38831308000420560970E+00, \
     0.74854243745107710333E+00, \
     0.84664854642567359993E+00, \
     0.58385732464244384564E+00, \
     0.80600584524215772824E+00, \
     0.53880362132692947616E+00, \
     0.72175037834698998506E+00, \
     0.58007844794544189900E+00, \
     0.60151910385440804463E+00, \
     0.70611511147286827018E+00, \
     0.61631110327201338454E+00, \
     0.62778480765443656489E+00 ))

  x_vec = np.array ( ( \
        0.0019531250E+00, \
       -0.0078125000E+00, \
        0.0625000000E+00, \
       -0.2500000000E+00, \
        1.0000000000E+00, \
        1.2500000000E+00, \
        2.0000000000E+00, \
       -4.0000000000E+00, \
        7.5000000000E+00, \
       11.0000000000E+00, \
       11.5000000000E+00, \
      -16.0000000000E+00, \
       20.0000000000E+00, \
       25.0000000000E+00, \
      -30.0000000000E+00, \
       50.0000000000E+00, \
       75.0000000000E+00, \
      -80.0000000000E+00, \
      100.0000000000E+00, \
     -125.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def struve_h1_values_test ( ):

#*****************************************************************************80
#
## struve_h1_values_test() tests struve_h1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'struve_h1_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  struve_h1_values stores values of the struve_h1 function.' )
  print ( '' )
  print ( '      X         struve_h1(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = struve_h1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'struve_h1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def struve_l0_values ( n_data ):

#*****************************************************************************80
#
## struve_l0_values returns some values of the Struve L0 function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      StruveL[0,x]
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
      0.12433985199262820188E-02, \
     -0.19896526647882937004E-01, \
      0.79715713253115014945E-01, \
     -0.32724069939418078025E+00, \
      0.71024318593789088874E+00, \
      0.19374337579914456612E+01, \
     -0.11131050203248583431E+02, \
      0.16850062034703267148E+03, \
     -0.28156522493745948555E+04, \
      0.89344618796978400815E+06, \
      0.11382025002851451057E+07, \
     -0.23549701855860190304E+07, \
      0.43558282527641046718E+08, \
      0.49993516476037957165E+09, \
     -0.57745606064408041689E+10, \
      0.78167229782395624524E+12, \
     -0.14894774793419899908E+17, \
      0.29325537838493363267E+21, \
      0.58940770556098011683E+25, \
     -0.12015889579125463605E+30 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
      -0.0312500000E+00, \
       0.1250000000E+00, \
      -0.5000000000E+00, \
       1.0000000000E+00, \
       2.0000000000E+00, \
      -4.0000000000E+00, \
       7.0000000000E+00, \
     -10.0000000000E+00, \
      16.0000000000E+00, \
      16.2500000000E+00, \
     -17.0000000000E+00, \
      20.0000000000E+00, \
      22.5000000000E+00, \
     -25.0000000000E+00, \
      30.0000000000E+00, \
     -40.0000000000E+00, \
      50.0000000000E+00, \
      60.0000000000E+00, \
     -70.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def struve_l0_values_test ( ):

#*****************************************************************************80
#
## struve_l0_values_test() tests struve_l0_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'struve_l0_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  struve_l0_values stores values of the struve_l0 function.' )
  print ( '' )
  print ( '      X         struve_l0(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = struve_l0_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'struve_l0_values_test:' )
  print ( '  Normal end of execution.' )
  return

def struve_l1_values ( n_data ):

#*****************************************************************************80
#
## struve_l1_values returns some values of the Struve L1 function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      StruveL[1,x]
#
#    The data was reported by McLeod.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
     0.80950410749865126939E-06, \
     0.20724649092571514607E-03, \
     0.33191834066894516744E-02, \
     0.53942182623522663292E-01, \
     0.22676438105580863683E+00, \
     0.11027597873677158176E+01, \
     0.91692778117386847344E+01, \
     0.15541656652426660966E+03, \
     0.26703582852084829694E+04, \
     0.86505880175304633906E+06, \
     0.11026046613094942620E+07, \
     0.22846209494153934787E+07, \
     0.42454972750111979449E+08, \
     0.48869614587997695539E+09, \
     0.56578651292431051863E+10, \
     0.76853203893832108948E+12, \
     0.14707396163259352103E+17, \
     0.29030785901035567967E+21, \
     0.58447515883904682813E+25, \
     0.11929750788892311875E+30 ))

  x_vec = np.array ( ( \
        0.0019531250E+00, \
       -0.0078125000E+00, \
        0.0625000000E+00, \
       -0.2500000000E+00, \
        1.0000000000E+00, \
        1.2500000000E+00, \
        2.0000000000E+00, \
       -4.0000000000E+00, \
        7.5000000000E+00, \
       11.0000000000E+00, \
       11.5000000000E+00, \
      -16.0000000000E+00, \
       20.0000000000E+00, \
       25.0000000000E+00, \
      -30.0000000000E+00, \
       50.0000000000E+00, \
       75.0000000000E+00, \
      -80.0000000000E+00, \
      100.0000000000E+00, \
     -125.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def struve_l1_values_test ( ):

#*****************************************************************************80
#
## struve_l1_values_test() tests struve_l1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'struve_l1_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  struve_l1_values stores values of the struve_l1 function.' )
  print ( '' )
  print ( '      X         struve_l1(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = struve_l1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'struve_l1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def student_cdf_values ( n_data ):

#*****************************************************************************80
#
## student_cdf_values returns some values of the Student CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = StudentTDistribution [ df ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real C, is usually called the number of 
#    degrees of freedom of the distribution.  C is typically an 
#    integer, but that is not essential.  It is required that
#    C be strictly positive.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 13

  c_vec = np.array ( ( \
    1.0, 2.0, 3.0, 4.0, \
    5.0, 2.0, 5.0, 2.0, \
    5.0, 2.0, 3.0, 4.0, \
    5.0 ))

  f_vec = np.array ( ( \
     0.6000231200328521, \
     0.6001080279134390, \
     0.6001150934648930, \
     0.6000995134721354, \
     0.5999341989834830, \
     0.7498859393137811, \
     0.7500879487671045, \
     0.9500004222186464, \
     0.9499969138365968, \
     0.9900012348724744, \
     0.9900017619355059, \
     0.9900004567580596, \
     0.9900007637471291 ))

  x_vec = np.array ( ( \
     0.325, \
     0.289, \
     0.277, \
     0.271, \
     0.267, \
     0.816, \
     0.727, \
     2.920, \
     2.015, \
     6.965, \
     4.541, \
     3.747, \
     3.365 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    c = 0.0
    x = 0.0
    f = 0.0
  else:
    c = c_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, c, x, f

def student_cdf_values_test ( ):

#*****************************************************************************80
#
## student_cdf_values_test() tests student_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'student_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  student_cdf_values stores values of the student_cdf function.' )
  print ( '' )
  print ( '      C             X         student_cdf(C,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, c, x, f = student_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %24.16g' % ( c, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'student_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def student_noncentral_cdf_values ( n_data ):

#*****************************************************************************80
#
## student_noncentral_cdf_values returns values of the noncentral Student CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = NoncentralStudentTDistribution [ df, lambda ]
#      CDF [ dist, x ]
#
#    Mathematica seems to have some difficulty computing this function
#    to the desired number of digits.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer DF, real LAM, the parameters of the
#    function.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 30

  df_vec = np.array ( ( \
     1,  2,  3, \
     1,  2,  3, \
     1,  2,  3, \
     1,  2,  3, \
     1,  2,  3, \
    15, 20, 25, \
     1,  2,  3, \
    10, 10, 10, \
    10, 10, 10, \
    10, 10, 10 ))

  f_vec = np.array ( ( \
     0.8975836176504333E+00, \
     0.9522670169E+00, \
     0.9711655571887813E+00, \
     0.8231218864E+00, \
     0.9049021510E+00, \
     0.9363471834E+00, \
     0.7301025986E+00, \
     0.8335594263E+00, \
     0.8774010255E+00, \
     0.5248571617E+00, \
     0.6293856597E+00, \
     0.6800271741E+00, \
     0.20590131975E+00, \
     0.2112148916E+00, \
     0.2074730718E+00, \
     0.9981130072E+00, \
     0.9994873850E+00, \
     0.9998391562E+00, \
     0.168610566972E+00, \
     0.16967950985E+00, \
     0.1701041003E+00, \
     0.9247683363E+00, \
     0.7483139269E+00, \
     0.4659802096E+00, \
     0.9761872541E+00, \
     0.8979689357E+00, \
     0.7181904627E+00, \
     0.9923658945E+00, \
     0.9610341649E+00, \
     0.8688007350E+00 ))

  lam_vec = np.array ( ( \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.5E+00, \
     0.5E+00, \
     0.5E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     2.0E+00, \
     2.0E+00, \
     2.0E+00, \
     4.0E+00, \
     4.0E+00, \
     4.0E+00, \
     7.0E+00, \
     7.0E+00, \
     7.0E+00, \
     1.0E+00, \
     1.0E+00, \
     1.0E+00, \
     2.0E+00, \
     3.0E+00, \
     4.0E+00, \
     2.0E+00, \
     3.0E+00, \
     4.0E+00, \
     2.0E+00, \
     3.0E+00, \
     4.0E+00 ))

  x_vec = np.array ( ( \
      3.00E+00, \
      3.00E+00, \
      3.00E+00, \
      3.00E+00, \
      3.00E+00, \
      3.00E+00, \
      3.00E+00, \
      3.00E+00, \
      3.00E+00, \
      3.00E+00, \
      3.00E+00, \
      3.00E+00, \
      3.00E+00, \
      3.00E+00, \
      3.00E+00, \
     15.00E+00, \
     15.00E+00, \
     15.00E+00, \
      0.05E+00, \
      0.05E+00, \
      0.05E+00, \
      4.00E+00, \
      4.00E+00, \
      4.00E+00, \
      5.00E+00, \
      5.00E+00, \
      5.00E+00, \
      6.00E+00, \
      6.00E+00, \
      6.00E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    df = 0
    lam = 0.0
    x = 0.0
    f = 0.0
  else:
    df = df_vec[n_data]
    lam = lam_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, df, lam, x, f

def student_noncentral_cdf_values_test ( ):

#*****************************************************************************80
#
## student_noncentral_cdf_values_test() tests student_noncentral_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'student_noncentral_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  student_noncentral_cdf_values stores values of the student_noncentral_cdf function.' )
  print ( '' )
  print ( '      DF          LAM             X         CDF(DF,LAM,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, df, lam, x, f = student_noncentral_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %12g  %12g  %24.16g' % ( df, lam, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'student_noncentral_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def subfactorial_values ( n_data ):

#*****************************************************************************80
#
## subfactorial_values returns values of the subfactorial function.
#
#  Discussion:
#
#    The subfactorial function Subfactorial(N) counts the number of 
#    permutations of N objects which leave no object unchanged.
#
#    Such a permutation is known as a derangement.
#
#    In Mathematica, the function can be evaluated by:
#
#      << DiscreteMath`CombinatorialFunctions`
#      Subfactorial[n]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the argument of the function.
#
#    integer F, the value of the function.
#
  import numpy as np

  n_max = 13

  f_vec = np.array ( ( \
            1, \
            0, \
            1, \
            2, \
            9, \
           44, \
          265, \
         1854, \
        14833, \
       133496, \
      1334961, \
     14684570, \
    176214841 ))

  n_vec = np.array ( ( \
     0,  1,  2,  3, \
     4,  5,  6,  7, \
     8,  9, 10, 11, \
    12 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    f = 0
  else:
    n = n_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, f

def subfactorial_values_test ( ):

#*****************************************************************************80
#
## subfactorial_values_test() tests subfactorial_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'subfactorial_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  subfactorial_values stores values of the SUBFACTORIAL function.' )
  print ( '' )
  print ( '             N    Subfactorial(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, f = subfactorial_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12d' % ( n, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'subfactorial_values_test:' )
  print ( '  Normal end of execution.' )
  return

def surten_values ( n_data ):

#*****************************************************************************80
#
## surten_values returns some values of the surface tension.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Lester Haar, John Gallagher and George Kell,
#    NBS/NRC Steam Tables:
#    Thermodynamic and transport Properties and Computer Programs
#    for Vapor and Liquid States of Water in SI Units,
#    Hemisphere Publishing Corporation, Washington, 1984,
#    TJ270.H3, pages 267.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real TC, the temperature, in degrees Celsius.
#
#    real SIGMA, the surface tension,
#    in Pascal * m = Newton / m.
#
  import numpy as np

  n_max = 14

  sigma_vec = np.array ( ( \
     74.22E+00, \
     72.74E+00, \
     71.20E+00, \
     69.60E+00, \
     67.95E+00, \
     58.92E+00, \
     48.75E+00, \
     37.68E+00, \
     26.05E+00, \
     14.37E+00, \
      8.78E+00, \
      3.67E+00, \
      0.40E+00, \
      0.00E+00 ))

  tc_vec = np.array ( ( \
      10.000E+00, \
      20.000E+00, \
      30.000E+00, \
      40.000E+00, \
      50.000E+00, \
     100.000E+00, \
     150.000E+00, \
     200.000E+00, \
     250.000E+00, \
     300.000E+00, \
     325.000E+00, \
     350.000E+00, \
     370.000E+00, \
     373.976E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    tc = 0.0
    sigma = 0.0
  else:
    tc = tc_vec[n_data]
    sigma = sigma_vec[n_data]
    n_data = n_data + 1

  return n_data, tc, sigma

def surten_values_test ( ):

#*****************************************************************************80
#
## surten_values_test() tests surten_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'surten_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  surten_values stores values of the SURTEN function.' )
  print ( '' )
  print ( '      TC         SIGMA(TC)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, tc, sigma = surten_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g %24.16g' % ( tc, sigma ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'surten_values_test:' )
  print ( '  Normal end of execution.' )
  return

def synch1_values ( n_data ):

#*****************************************************************************80
#
## synch1_values returns some values of the synchrotron radiation function.
#
#  Discussion:
#
#    The function is defined by:
#
#      synch1(x) = x * Integral ( x <= t < infinity ) K(5/3)(t) dt
#
#    where K(5/3) is a modified Bessel function of order 5/3.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
       0.26514864547487397044E+00, \
       0.62050129979079045645E+00, \
       0.85112572132368011206E+00, \
       0.87081914687546885094E+00, \
       0.65142281535536396975E+00, \
       0.45064040920322354579E+00, \
       0.30163590285073940285E+00, \
       0.19814490804441305867E+00, \
       0.12856571000906381300E+00, \
       0.52827396697866818297E-01, \
       0.42139298471720305542E-01, \
       0.21248129774981984268E-01, \
       0.13400258907505536491E-01, \
       0.84260797314108699935E-02, \
       0.12884516186754671469E-02, \
       0.19223826430086897418E-03, \
       0.28221070834007689394E-04, \
       0.15548757973038189372E-05, \
       0.11968634456097453636E-07, \
       0.89564246772237127742E-10 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
       5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      12.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      25.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def synch1_values_test ( ):

#*****************************************************************************80
#
## synch1_values_test() tests synch1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'synch1_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  synch1_values stores values of the synch1 function.' )
  print ( '' )
  print ( '      X         synch1(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = synch1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'synch1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def synch2_values ( n_data ):

#*****************************************************************************80
#
## synch2_values returns some values of the synchrotron radiation function.
#
#  Discussion:
#
#    The function is defined by:
#
#      synch2(x) = x * K(2/3)(x)
#
#    where K(2/3) is a modified Bessel function of order 2/3.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
     0.13430727275667378338E+00, \
     0.33485265272424176976E+00, \
     0.50404224110911078651E+00, \
     0.60296523236016785113E+00, \
     0.49447506210420826699E+00, \
     0.36036067860473360389E+00, \
     0.24967785497625662113E+00, \
     0.16813830542905833533E+00, \
     0.11117122348556549832E+00, \
     0.46923205826101330711E-01, \
     0.37624545861980001482E-01, \
     0.19222123172484106436E-01, \
     0.12209535343654701398E-01, \
     0.77249644268525771866E-02, \
     0.12029044213679269639E-02, \
     0.18161187569530204281E-03, \
     0.26884338006629353506E-04, \
     0.14942212731345828759E-05, \
     0.11607696854385161390E-07, \
     0.87362343746221526073E-10 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
       5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      12.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      25.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def synch2_values_test ( ):

#*****************************************************************************80
#
## synch2_values_test() tests synch2_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'synch2_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  synch2_values stores values of the synch2 function.' )
  print ( '' )
  print ( '      X         synch2(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = synch2_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'synch2_values_test:' )
  print ( '  Normal end of execution.' )
  return

def tanh_values ( n_data ):

#*****************************************************************************80
#
## tanh_values returns some values of the hyperbolic tangent function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Tanh[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 18

  f_vec = np.array ( ( \
   -0.99990920426259513121, \
   -0.76159415595576488812, \
    0.00000000000000000000, \
    0.099667994624955817118, \
    0.19737532022490400074, \
    0.29131261245159090582, \
    0.37994896225522488527, \
    0.46211715726000975850, \
    0.53704956699803528586, \
    0.60436777711716349631, \
    0.66403677026784896368, \
    0.71629787019902442081, \
    0.76159415595576488812, \
    0.96402758007581688395, \
    0.99505475368673045133, \
    0.99932929973906704379, \
    0.99990920426259513121, \
    0.99999999587769276362 ))

  x_vec = np.array ( ( \
   -5.0, \
   -1.0, \
    0.0, \
    0.1, \
    0.2, \
    0.3, \
    0.4, \
    0.5, \
    0.6, \
    0.7, \
    0.8, \
    0.9, \
    1.0, \
    2.0, \
    3.0, \
    4.0, \
    5.0, \
   10.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def tanh_values_test ( ):

#*****************************************************************************80
#
## tanh_values_test() tests tanh_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'tanh_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  tanh_values stores values of the TANH function.' )
  print ( '' )
  print ( '      X         TANH(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = tanh_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'tanh_values_test:' )
  print ( '  Normal end of execution.' )
  return

def tan_values ( n_data ):

#*****************************************************************************80
#
## tan_values returns some values of the tangent function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Tan[x]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 15

  f_vec = np.array ( ( \
     0.00000000000000000000, \
     0.26794919243112270647, \
     0.54630248984379051326, \
     0.57735026918962576451, \
     1.0000000000000000000, \
     1.5574077246549022305, \
     1.7320508075688772935, \
     3.7320508075688772935, \
     7.5957541127251504405, \
    15.257051688265539110, \
    -2.1850398632615189916, \
    -0.14254654307427780530, \
     0.0000000000000000000, \
     1.1578212823495775831, \
    -3.3805150062465856370 ))

  x_vec = np.array ( ( \
    0.00000000000000000000, \
    0.26179938779914943654, \
    0.50000000000000000000, \
    0.52359877559829887308, \
    0.78539816339744830962, \
    1.0000000000000000000, \
    1.0471975511965977462, \
    1.3089969389957471827, \
    1.4398966328953219010, \
    1.5053464798451092601, \
    2.0000000000000000000, \
    3.0000000000000000000, \
    3.1415926535897932385, \
    4.0000000000000000000, \
    5.0000000000000000000 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def tan_values_test ( ):

#*****************************************************************************80
#
## tan_values_test() tests tan_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'tan_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  tan_values stores values of the TAN function.' )
  print ( '' )
  print ( '      X         TAN(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = tan_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'tan_values_test:' )
  print ( '  Normal end of execution.' )
  return

def tau_values ( n_data ):

#*****************************************************************************80
#
## tau_values returns some values of the Tau function.
#
#  Discussion:
#
#    TAU(N) is the number of divisors of N, including 1 and N.
#
#    In Mathematica, the function can be evaluated by:
#
#      DivisorSigma[1,n]
#
#  First values:
#
#     N   TAU(N)
#
#     1    1
#     2    2
#     3    2
#     4    3
#     5    2
#     6    4
#     7    2
#     8    4
#     9    3
#    10    4
#    11    2
#    12    6
#    13    2
#    14    4
#    15    4
#    16    5
#    17    2
#    18    6
#    19    2
#    20    6
#
#  Formula:
#
#    If the prime factorization of N is
#
#      N = P1^E1 * P2^E2 * ... * PM^EM,
#
#    then
#
#      TAU(N) = ( E1 + 1 ) * ( E2 + 1 ) * ... * ( EM + 1 ).
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the argument of the Tau function.
#
#    integer C, the value of the Tau function.
#
  import numpy as np

  n_max = 20

  c_vec = np.array ( ( \
    1,  2,  2,  3,  2,  4,  2,  4,  3,  4, \
    2, 12, 12,  4, 18, 24,  2,  8, 14, 28 ))

  n_vec = np.array ( ( \
      1,   2,   3,   4,   5,   6,   7,   8,   9,  10, \
     23,  72, 126, 226, 300, 480, 521, 610, 832, 960 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    c = 0
  else:
    n = n_vec[n_data]
    c = c_vec[n_data]
    n_data = n_data + 1

  return n_data, n, c

def tau_values_test ( ):

#*****************************************************************************80
#
## tau_values_test() tests tau_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'tau_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  tau_values stores values of the TAU function.' )
  print ( '' )
  print ( '             N    TAU(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, c = tau_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12d' % ( n, c ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'tau_values_test:' )
  print ( '  Normal end of execution.' )
  return

def test_values_test ( ):

#*****************************************************************************80
#
## test_values_test() tests test_values().
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license. 
#
#  Modified:
#
#    04 January 2019
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'test_values_test():' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  Test test_values().' )

  abram0_values_test ( )
  abram1_values_test ( )
  abram2_values_test ( )
  agm_values_test ( )
  airy_ai_values_test ( )
  airy_ai_int_values_test ( )
  airy_ai_prime_values_test ( )
  airy_bi_values_test ( )
  airy_bi_int_values_test ( )
  airy_bi_prime_values_test ( )
  airy_cai_values_test ( )
  airy_cbi_values_test ( )
  airy_gi_values_test ( )
  arccos_values_test ( )
  arccosh_values_test ( )
  arcsin_values_test ( )
  arcsinh_values_test ( )
  arctan_values_test ( )
  arctan_int_values_test ( )
  arctan2_values_test ( )
  arctanh_values_test ( )

  bei0_values_test ( )
  bei1_values_test ( )
  bell_values_test ( )
  ber0_values_test ( )
  ber1_values_test ( )
  bernoulli_number_values_test ( )
  bernoulli_poly_values_test ( )
  bernstein_poly_01_values_test ( )
  bessel_i0_values_test ( )
  bessel_i0_int_values_test ( )
  bessel_i0_spherical_values_test ( )
  bessel_i1_values_test ( )
  bessel_i1_spherical_values_test ( )
  bessel_in_values_test ( )
  bessel_ix_values_test ( )
  bessel_j_spherical_values_test ( )
  bessel_j0_values_test ( )
  bessel_j0_int_values_test ( )
  bessel_j0_spherical_values_test ( )
  bessel_j0_zero_values_test ( )
  bessel_j1_values_test ( )
  bessel_j1_spherical_values_test ( )
  bessel_jn_values_test ( )
  bessel_jx_values_test ( )
  bessel_k0_values_test ( )
  bessel_k0_int_values_test ( )
  bessel_k1_values_test ( )
  bessel_kn_values_test ( )
  bessel_kx_values_test ( )
  bessel_y0_values_test ( )
  bessel_y0_int_values_test ( )
  bessel_y0_spherical_values_test ( )
  bessel_y1_values_test ( )
  bessel_y1_spherical_values_test ( )
  bessel_yn_values_test ( )
  bessel_yx_values_test ( )
  beta_values_test ( )
  beta_cdf_values_test ( )
  beta_inc_values_test ( )
  beta_log_values_test ( )
  beta_noncentral_cdf_values_test ( )
  beta_pdf_values_test ( )
  binomial_values_test ( )
  binomial_cdf_values_test ( )
  binomial_pdf_values_test ( )
  bivariate_normal_cdf_values_test ( )

  c8_log_values_test ( )
  catalan_values_test ( )
  cauchy_cdf_values_test ( )
  cbrt_values_test ( )
  cheby_t_poly_values_test ( )
  cheby_t01_poly_values_test ( )
  cheby_u_poly_values_test ( )
  cheby_u01_poly_values_test ( )
  cheby_v_poly_values_test ( )
  cheby_v01_poly_values_test ( )
  cheby_w_poly_values_test ( )
  cheby_w01_poly_values_test ( )
  chi_values_test ( )
  chi_square_cdf_values_test ( )
  chi_square_pdf_values_test ( )
  chi_square_noncentral_cdf_values_test ( )
  ci_values_test ( )
  cin_values_test ( )
  cinh_values_test ( )
  clausen_values_test ( )
  clebsch_gordan_values_test ( )
  collatz_count_values_test ( )
  cos_values_test ( )
  cos_degree_values_test ( )
  cos_power_int_values_test ( )
  cosh_values_test ( )
  cot_values_test ( )
  cp_values_test ( )

  datenum_values_test ( )
  dawson_values_test ( )
  debye1_values_test ( )
  debye2_values_test ( )
  debye3_values_test ( )
  debye4_values_test ( )
  dedekind_sum_values_test ( )
  dielectric_values_test ( )
  dilogarithm_values_test ( )

  e1_values_test ( )
  easter_gregorian_values_test ( )
  easter_julian_values_test ( )
  ei_values_test ( )
  elliptic_ea_values_test ( )
  elliptic_ek_values_test ( )
  elliptic_em_values_test ( )
  elliptic_fa_values_test ( )
  elliptic_fk_values_test ( )
  elliptic_fm_values_test ( )
  elliptic_pia_values_test ( )
  elliptic_pik_values_test ( )
  elliptic_pim_values_test ( )
  elliptic_inc_ea_values_test ( )
  elliptic_inc_ek_values_test ( )
  elliptic_inc_em_values_test ( )
  elliptic_inc_fa_values_test ( )
  elliptic_inc_fk_values_test ( )
  elliptic_inc_fm_values_test ( )
  elliptic_inc_pia_values_test ( )
  elliptic_inc_pik_values_test ( )
  elliptic_inc_pim_values_test ( )
  erf_values_test ( )
  erfc_values_test ( )
  euler_number_values_test ( )
  euler_poly_values_test ( )
  exp_values_test ( )
  exp3_int_values_test ( )
  exponential_01_pdf_values_test ( )
  exponential_cdf_values_test ( )
  exponential_pdf_values_test ( )
  extreme_values_cdf_values_test ( )

  f_cdf_values_test ( )
  f_noncentral_cdf_values_test ( )
  fresnel_cos_values_test ( )
  fresnel_sin_values_test ( )
  frobenius_number_data_values_test ( )
  frobenius_number_order_values_test ( )
  frobenius_number_order2_values_test ( )

  gamma_values_test ( )
  gamma_01_pdf_values_test ( )
  gamma_inc_values_test ( )
  gamma_inc_p_values_test ( )
  gamma_inc_q_values_test ( )
  gamma_log_values_test ( )
  gamma_pdf_values_test ( )
  gegenbauer_poly_values_test ( )
  geometric_cdf_values_test ( )
  goodwin_values_test ( )
  gud_values_test ( )

  hermite_function_values_test ( )
  hermite_poly_phys_values_test ( )
  hermite_poly_prob_values_test ( )
  hyper_1f1_values_test ( )
  hyper_2f1_values_test ( )
  hypergeometric_cdf_values_test ( )
  hypergeometric_pdf_values_test ( )
  hypergeometric_u_values_test ( )

  i0ml0_values_test ( )
  i1ml1_values_test ( )
  i4_factorial_values_test ( )
  i4_factorial2_values_test ( )
  i4_fall_values_test ( )
  i4_rise_values_test ( )
  int_values_test ( )
  inverse_chi_square_pdf_values_test ( )
  inverse_gamma_pdf_values_test ( )

  jacobi_cn_values_test ( )
  jacobi_dn_values_test ( )
  jacobi_poly_values_test ( )
  jacobi_sn_values_test ( )
  jed_ce_values_test ( )
  jed_mjd_values_test ( )
  jed_rd_values_test ( )
  jed_weekday_values_test ( )

  kei0_values_test ( )
  kei1_values_test ( )
  ker0_values_test ( )
  ker1_values_test ( )
  laguerre_associated_values_test ( )
  laguerre_general_values_test ( )
  laguerre_polynomial_values_test ( )
  lambert_w_values_test ( )
  laplace_cdf_values_test ( )
  legendre_associated_values_test ( )
  legendre_associated_normalized_values_test ( )
  legendre_associated_normalized_sphere_values_test ( )
  legendre_function_q_values_test ( )
  legendre_normalized_polynomial_values_test ( )
  legendre_polynomial_values_test ( )
  legendre_shifted_polynomial_values_test ( )
  lerch_values_test ( )
  lobachevsky_values_test ( )
  lobatto_polynomial_values_test ( )
  lobatto_polynomial_derivatives_test ( )
  log_values_test ( )
  log_normal_cdf_values_test ( )
  log_series_cdf_values_test ( )
  log10_values_test ( )
  logarithmic_integral_values_test ( )
  logistic_cdf_values_test ( )

  mertens_values_test ( )
  mittag_leffler_ea_values_test ( )
  moebius_values_test ( )
  multinomial_pdf_values_test ( )

  negative_binomial_cdf_values_test ( )
  nine_j_values_test ( )
  normal_01_cdf_values_test ( )
  normal_cdf_values_test ( )
  normal_pdf_values_test ( )

  omega_values_test ( )
  owen_values_test ( )

  partition_count_values_test ( )
  partition_distinct_count_values_test ( )
  phi_values_test ( )
  pi_values_test ( )
  poisson_cdf_values_test ( )
  polylogarithm_values_test ( )
  polyomino_chiral_count_values_test ( )
  polyomino_fixed_count_values_test ( )
  polyomino_free_count_values_test ( )
  prandtl_values_test ( )
  prime_values_test ( )
  psat_values_test ( )
  psi_values_test ( )

  r8_factorial_values_test ( )
  r8_factorial_log_values_test ( )
  r8_factorial2_values_test ( )
  r8_fall_values_test ( )
  r8_rise_values_test ( )
  rayleigh_cdf_values_test ( )

  scaled_inverse_chi_square_pdf_values_test ( )
  secvir_values_test ( )
  shi_values_test ( )
  si_values_test ( )
  sigma_values_test ( )
  sin_values_test ( )
  sin_degree_values_test ( )
  sin_power_int_values_test ( )
  sinh_values_test ( )
  six_j_values_test ( )
  sound_values_test ( )
  sphere_unit_area_values_test ( )
  sphere_unit_volume_values_test ( )
  spherical_harmonic_values_test ( )
  sqrt_values_test ( )
  stirling1_values_test ( )
  stirling2_values_test ( )
  stromgen_values_test ( )
  struve_h0_values_test ( )
  struve_h1_values_test ( )
  struve_l0_values_test ( )
  struve_l1_values_test ( )
  student_cdf_values_test ( )
  student_noncentral_cdf_values_test ( )
  subfactorial_values_test ( )
  surten_values_test ( )
  synch1_values_test ( )
  synch2_values_test ( )

  tan_values_test ( )
  tanh_values_test ( )
  tau_values_test ( )
  thercon_values_test ( )
  three_j_values_test ( )
  tran02_values_test ( )
  tran03_values_test ( )
  tran04_values_test ( )
  tran05_values_test ( )
  tran06_values_test ( )
  tran07_values_test ( )
  tran08_values_test ( )
  tran09_values_test ( )
  trigamma_values_test ( )
  truncated_normal_ab_cdf_values_test ( )
  truncated_normal_ab_pdf_values_test ( )
  truncated_normal_a_cdf_values_test ( )
  truncated_normal_a_pdf_values_test ( )
  truncated_normal_b_cdf_values_test ( )
  truncated_normal_b_pdf_values_test ( )
  tsat_values_test ( )

  van_der_corput_values_test ( )
  viscosity_values_test ( )
  von_mises_cdf_values_test ( )

  weekday_values_test ( )
  weibull_cdf_values_test ( )
  wright_omega_values_test ( )

  zeta_values_test ( )
  zeta_m1_values_test ( )
#
#  Terminate.
#
  print ( '' )
  print ( 'test_values_test():' )
  print ( '  Normal end of execution.' )
  return

def thercon_values ( n_data ):

#*****************************************************************************80
#
## thercon_values returns some values of the thermal conductivity.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Lester Haar, John Gallagher and George Kell,
#    NBS/NRC Steam Tables:
#    Thermodynamic and transport Properties and Computer Programs
#    for Vapor and Liquid States of Water in SI Units,
#    Hemisphere Publishing Corporation, Washington, 1984,
#    TJ270.H3, page 264.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real TC, the temperature, in degrees Celsius.
#
#    real P, the pressure, in bar.
#
#    real LAM, the thermal conductivity, in
#    mW/(m degrees Kelvin).
#
  import numpy as np

  n_max = 35

  lam_vec = np.array ( ( \
     561.00E+00, \
     561.30E+00, \
     561.50E+00, \
     562.40E+00, \
     563.70E+00, \
     565.10E+00, \
     566.50E+00, \
     567.90E+00, \
     569.30E+00, \
     570.60E+00, \
     572.00E+00, \
     573.40E+00, \
     574.80E+00, \
     576.10E+00, \
     577.50E+00, \
     580.20E+00, \
     582.90E+00, \
     585.50E+00, \
     588.10E+00, \
     590.70E+00, \
     593.30E+00, \
     595.80E+00, \
     598.30E+00, \
     603.10E+00, \
     607.80E+00, \
     612.20E+00, \
     607.20E+00, \
     643.60E+00, \
     666.80E+00, \
      25.08E+00, \
      28.85E+00, \
      33.28E+00, \
      54.76E+00, \
      79.89E+00, \
     107.30E+00 ))

  p_vec = np.array ( ( \
        1.0E+00, \
        5.0E+00, \
       10.0E+00, \
       25.0E+00, \
       50.0E+00, \
       75.0E+00, \
      100.0E+00, \
      125.0E+00, \
      150.0E+00, \
      175.0E+00, \
      200.0E+00, \
      225.0E+00, \
      250.0E+00, \
      275.0E+00, \
      300.0E+00, \
      350.0E+00, \
      400.0E+00, \
      450.0E+00, \
      500.0E+00, \
      550.0E+00, \
      600.0E+00, \
      650.0E+00, \
      700.0E+00, \
      800.0E+00, \
      900.0E+00, \
     1000.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00 ))

  tc_vec = np.array ( ( \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
      25.0E+00, \
      50.0E+00, \
      75.0E+00, \
     100.0E+00, \
     150.0E+00, \
     200.0E+00, \
     400.0E+00, \
     600.0E+00, \
     800.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    tc = 0.0
    p = 0.0
    lam = 0.0
  else:
    tc = tc_vec[n_data]
    p = p_vec[n_data]
    lam = lam_vec[n_data]
    n_data = n_data + 1

  return n_data, tc, p, lam

def thercon_values_test ( ):

#*****************************************************************************80
#
## thercon_values_test() tests thercon_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'thercon_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  thercon_values stores values of the thermal conductivity function.' )
  print ( '' )
  print ( '      TC         P        LAM(TC,P)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, tc, p, lam = thercon_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %24.16g' % ( tc, p, lam ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'thercon_values_test:' )
  print ( '  Normal end of execution.' )
  return

def three_j_values ( n_data ):

#*****************************************************************************80
#
## three_j_values returns some values of the Wigner 3J function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      ThreeJSymbol[{j1,m1},{j2,m2},{j3,m3}]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz, Irene Stegun,
#    Handbook of Mathematical Functions,
#    National Bureau of Standards, 1964,
#    ISBN: 0-486-61272-4,
#    LC: QA47.A34.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Cambridge University Press, 1999,
#    ISBN: 0-521-64314-7,
#    LC: QA76.95.W65.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real  J1, J2, J3, M1, M2, M3, the arguments 
#    of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 8

  f_vec = np.array ( ( \
     0.2788866755113585, \
    -0.09534625892455923, \
    -0.06741998624632421, \
     0.1533110351679666, \
    -0.1564465546936860, \
     0.1099450412156551, \
    -0.05536235693131719, \
     0.01799835451137786 ))
  j1_vec = np.array ( ( \
    1.0, \
    2.0, \
    3.0, \
    4.0, \
    5.0, \
    6.0, \
    7.0, \
    8.0 ))
  j2_vec = np.array ( ( \
    4.5, \
    4.5, \
    4.5, \
    4.5, \
    4.5, \
    4.5, \
    4.5, \
    4.5 ))
  j3_vec = np.array ( ( \
    3.5, \
    3.5, \
    3.5, \
    3.5, \
    3.5, \
    3.5, \
    3.5, \
    3.5 ))
  m1_vec = np.array ( ( \
    1.0, \
    1.0, \
    1.0, \
    1.0, \
    1.0, \
    1.0, \
    1.0, \
    1.0 ))
  m2_vec = np.array ( ( \
    -3.5, \
    -3.5, \
    -3.5, \
    -3.5, \
    -3.5, \
    -3.5, \
    -3.5, \
    -3.5 ))
  m3_vec = np.array ( ( \
    2.5, \
    2.5, \
    2.5, \
    2.5, \
    2.5, \
    2.5, \
    2.5, \
    2.5 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    j1 = 0.0
    j2 = 0.0
    j3 = 0.0
    m1 = 0.0
    m2 = 0.0
    m3 = 0.0
    f = 0.0
  else:
    j1 = j1_vec[n_data]
    j2 = j2_vec[n_data]
    j3 = j3_vec[n_data]
    m1 = m1_vec[n_data]
    m2 = m2_vec[n_data]
    m3 = m3_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, j1, j2, j3, m1, m2, m3, f

def three_j_values_test ( ):

#*****************************************************************************80
#
## three_j_values_test() tests three_j_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'three_j_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  three_j_values stores values of the three_j function.' )
  print ( '' )
  print ( '    J1    J2    J3    M1    M2    M3    three_j(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, j1, j2, j3, m1, m2, m3, f = three_j_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %4.1f  %4.1f  %4.1f  %4.1f  %4.1f  %4.1f  %24.16f' \
      % ( j1, j2, j3, m1, m2, m3, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'three_j_values_test:' )
  print ( '  Normal end of execution.' )
  return

def timestamp ( ):

#*****************************************************************************80
#
## timestamp() prints the date as a timestamp.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license. 
#
#  Modified:
#
#    06 April 2013
#
#  Author:
#
#    John Burkardt
#
  import time

  t = time.time ( )
  print ( time.ctime ( t ) )

  return None

def tran02_values ( n_data ):

#*****************************************************************************80
#
## tran02_values returns some values of the order 2 transportation function.
#
#  Discussion:
#
#    The function is defined by:
#
#      tran02(x) = Integral ( 0 <= t <= x ) t^2 exp(t) / ( exp(t) - 1 )^2 dt
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
     0.19531247930394515480E-02, \
     0.31249152314331109004E-01, \
     0.12494577194783451032E+00, \
     0.49655363615640595865E+00, \
     0.97303256135517012845E+00, \
     0.14121978695932525805E+01, \
     0.18017185674405776809E+01, \
     0.21350385339277043015E+01, \
     0.24110500490169534620E+01, \
     0.28066664045631179931E+01, \
     0.28777421863296234131E+01, \
     0.30391706043438554330E+01, \
     0.31125074928667355940E+01, \
     0.31656687817738577185E+01, \
     0.32623520367816009184E+01, \
     0.32843291144979517358E+01, \
     0.32897895167775788137E+01, \
     0.32898672226665499687E+01, \
     0.32898681336064325400E+01, \
     0.32898681336964528724E+01 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
       5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def tran02_values_test ( ):

#*****************************************************************************80
#
## tran02_values_test() tests tran02_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'tran02_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  tran02_values stores values of the tran02 function.' )
  print ( '' )
  print ( '      X         tran02(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = tran02_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'tran02_values_test:' )
  print ( '  Normal end of execution.' )
  return

def tran03_values ( n_data ):

#*****************************************************************************80
#
## tran03_values returns some values of the order 3 transportation function.
#
#  Discussion:
#
#    The function is defined by:
#
#      tran03(x) = Integral ( 0 <= t <= x ) t^3 exp(t) / ( exp(t) - 1 )^2 dt
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
     0.19073483296476379584E-05, \
     0.48826138243180786081E-03, \
     0.78074163848431205820E-02, \
     0.12370868718812031049E+00, \
     0.47984100657241749994E+00, \
     0.10269431622039754738E+01, \
     0.17063547219458658863E+01, \
     0.24539217444475937661E+01, \
     0.32106046629422467723E+01, \
     0.45792174372291563703E+01, \
     0.48722022832940370805E+01, \
     0.56143866138422732286E+01, \
     0.59984455864575470009E+01, \
     0.63033953673480961120E+01, \
     0.69579908688361166266E+01, \
     0.71503227120085929750E+01, \
     0.72110731475871876393E+01, \
     0.72123221966388461839E+01, \
     0.72123414161609465119E+01, \
     0.72123414189575656868E+01 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
       5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def tran03_values_test ( ):

#*****************************************************************************80
#
## tran03_values_test() tests tran03_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'tran03_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  tran03_values stores values of the tran03 function.' )
  print ( '' )
  print ( '      X         tran03(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = tran03_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'tran03_values_test:' )
  print ( '  Normal end of execution.' )
  return

def tran04_values ( n_data ):

#*****************************************************************************80
#
## tran04_values returns some values of the order 4 transportation function.
#
#  Discussion:
#
#    The function is defined by:
#
#      tran04(x) = Integral ( 0 <= t <= x ) t^4 exp(t) / ( exp(t) - 1 )^2 dt
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
     0.24835263919461834041E-08, \
     0.10172029353616724881E-04, \
     0.65053332405940765479E-03, \
     0.41150448004155727767E-01, \
     0.31724404523442648241E+00, \
     0.10079442901142373591E+01, \
     0.22010881024333408363E+01, \
     0.38846508619156545210E+01, \
     0.59648223973714765245E+01, \
     0.10731932392998622219E+02, \
     0.11940028876819364777E+02, \
     0.15359784316882182982E+02, \
     0.17372587633093742893E+02, \
     0.19122976016053166969E+02, \
     0.23583979156921941515E+02, \
     0.25273667677030441733E+02, \
     0.25955198214572256372E+02, \
     0.25975350935212241910E+02, \
     0.25975757522084093747E+02, \
     0.25975757609067315288E+02 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
       5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def tran04_values_test ( ):

#*****************************************************************************80
#
## tran04_values_test() tests tran04_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'tran04_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  tran04_values stores values of the tran04 function.' )
  print ( '' )
  print ( '      X         tran04(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = tran04_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'tran04_values_test:' )
  print ( '  Normal end of execution.' )
  return

def tran05_values ( n_data ):

#*****************************************************************************80
#
## tran05_values returns some values of the order 5 transportation function.
#
#  Discussion:
#
#    The function is defined by:
#
#      tran05(x) = Integral ( 0 <= t <= x ) t^5 exp(t) / ( exp(t) - 1 )^2 dt
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
     0.36379780361036116971E-11, \
     0.23840564453948442379E-06, \
     0.60982205372226969189E-04, \
     0.15410004586376649337E-01, \
     0.23661587923909478926E+00, \
     0.11198756851307629651E+01, \
     0.32292901663684049171E+01, \
     0.70362973105160654056E+01, \
     0.12770557691044159511E+02, \
     0.29488339015245845447E+02, \
     0.34471340540362254586E+02, \
     0.50263092218175187785E+02, \
     0.60819909101127165207E+02, \
     0.70873334429213460498E+02, \
     0.10147781242977788097E+03, \
     0.11638074540242071077E+03, \
     0.12409623901262967878E+03, \
     0.12442270155632550228E+03, \
     0.12443132790838589548E+03, \
     0.12443133061720432435E+03 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
       5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def tran05_values_test ( ):

#*****************************************************************************80
#
## tran05_values_test() tests tran05_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'tran05_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  tran05_values stores values of the tran05 function.' )
  print ( '' )
  print ( '      X         tran05(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = tran05_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'tran05_values_test:' )
  print ( '  Normal end of execution.' )
  return

def tran06_values ( n_data ):

#*****************************************************************************80
#
## tran06_values returns some values of the order 6 transportation function.
#
#  Discussion:
#
#    The function is defined by:
#
#      tran06(x) = Integral ( 0 <= t <= x ) t^6 exp(t) / ( exp(t) - 1 )^2 dt
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
     0.56843405953641209574E-14, \
     0.59601180165247401484E-08, \
     0.60978424397580572815E-05, \
     0.61578909866319494394E-02, \
     0.18854360275680840514E+00, \
     0.13319251347921659134E+01, \
     0.50857202271697616755E+01, \
     0.13729222365466557122E+02, \
     0.29579592481641441292E+02, \
     0.88600835706899853768E+02, \
     0.10916037113373004909E+03, \
     0.18224323749575359518E+03, \
     0.23765383125586756031E+03, \
     0.29543246745959381136E+03, \
     0.50681244381280455592E+03, \
     0.63878231134946125623E+03, \
     0.72699203556994876111E+03, \
     0.73230331643146851717E+03, \
     0.73248692015882096369E+03, \
     0.73248700462879996604E+03 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
       5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def tran06_values_test ( ):

#*****************************************************************************80
#
## tran06_values_test() tests tran06_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'tran06_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  tran06_values stores values of the tran06 function.' )
  print ( '' )
  print ( '      X         tran06(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = tran06_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'tran06_values_test:' )
  print ( '  Normal end of execution.' )
  return

def tran07_values ( n_data ):

#*****************************************************************************80
#
## tran07_values returns some values of the order 7 transportation function.
#
#  Discussion:
#
#    The function is defined by:
#
#      tran07(x) = Integral ( 0 <= t <= x ) t^7 exp(t) / ( exp(t) - 1 )^2 dt
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
     0.92518563327283409427E-17, \
     0.15521095556949867541E-09, \
     0.63516238373841716290E-06, \
     0.25638801246626135714E-02, \
     0.15665328993811649746E+00, \
     0.16538225039181097423E+01, \
     0.83763085709508211054E+01, \
     0.28078570717830763747E+02, \
     0.72009676046751991365E+02, \
     0.28174905701691911450E+03, \
     0.36660227975327792529E+03, \
     0.70556067982603601123E+03, \
     0.99661927562755629434E+03, \
     0.13288914430417403901E+04, \
     0.27987640273169129925E+04, \
     0.39721376409416504325E+04, \
     0.49913492839319899726E+04, \
     0.50781562639825019000E+04, \
     0.50820777202028708434E+04, \
     0.50820803580047164618E+04 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
       5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def tran07_values_test ( ):

#*****************************************************************************80
#
## tran07_values_test() tests tran07_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'tran07_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  tran07_values stores values of the tran07 function.' )
  print ( '' )
  print ( '      X         tran07(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = tran07_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'tran07_values_test:' )
  print ( '  Normal end of execution.' )
  return

def tran08_values ( n_data ):

#*****************************************************************************80
#
## tran08_values returns some values of the order 8 transportation function.
#
#  Discussion:
#
#    The function is defined by:
#
#      tran08(x) = Integral ( 0 <= t <= x ) t^8 exp(t) / ( exp(t) - 1 )^2 dt
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
     0.15488598634539359463E-19, \
     0.41574269117845953797E-11, \
     0.68050651245227411689E-07, \
     0.10981703519563009836E-02, \
     0.13396432776187883834E+00, \
     0.21153387806998617182E+01, \
     0.14227877028750735641E+02, \
     0.59312061431647843226E+02, \
     0.18139614577043147745E+03, \
     0.93148001928992220863E+03, \
     0.12817928112604611804E+04, \
     0.28572838386329242218E+04, \
     0.43872971687877730010E+04, \
     0.62993229139406657611E+04, \
     0.16589426277154888511E+05, \
     0.27064780798797398935E+05, \
     0.38974556062543661284E+05, \
     0.40400240716905025786E+05, \
     0.40484316504120655568E+05, \
     0.40484399001892184901E+05 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
       5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def tran08_values_test ( ):

#*****************************************************************************80
#
## tran08_values_test() tests tran08_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'tran08_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  tran08_values stores values of the tran08 function.' )
  print ( '' )
  print ( '      X         tran08(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = tran08_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'tran08_values_test:' )
  print ( '  Normal end of execution.' )
  return

def tran09_values ( n_data ):

#*****************************************************************************80
#
## tran09_values returns some values of the order 9 transportation function.
#
#  Discussion:
#
#    The function is defined by:
#
#      tran09(x) = Integral ( 0 <= t <= x ) t^9 exp(t) / ( exp(t) - 1 )^2 dt
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Allan McLeod,
#    Algorithm 757, MISCFUN: A software package to compute uncommon
#    special functions,
#    ACM transactions on Mathematical Software,
#    Volume 22, Number 3, September 1996, pages 288-301.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 20

  f_vec = np.array ( ( \
     0.26469772870084897671E-22, \
     0.11367943653594246210E-12, \
     0.74428246255329800255E-08, \
     0.48022728485415366194E-03, \
     0.11700243014358676725E+00, \
     0.27648973910899914391E+01, \
     0.24716631405829192997E+02, \
     0.12827119828849828583E+03, \
     0.46842894800662208986E+03, \
     0.31673967371627895718E+04, \
     0.46140886546630195390E+04, \
     0.11952718545392302185E+05, \
     0.20001612666477027728E+05, \
     0.31011073271851366554E+05, \
     0.10352949905541130133E+06, \
     0.19743173017140591390E+06, \
     0.33826030414658460679E+06, \
     0.36179607036750755227E+06, \
     0.36360622124777561525E+06, \
     0.36360880558827162725E+06 ))

  x_vec = np.array ( ( \
       0.0019531250E+00, \
       0.0312500000E+00, \
       0.1250000000E+00, \
       0.5000000000E+00, \
       1.0000000000E+00, \
       1.5000000000E+00, \
       2.0000000000E+00, \
       2.5000000000E+00, \
       3.0000000000E+00, \
       4.0000000000E+00, \
       4.2500000000E+00, \
       5.0000000000E+00, \
       5.5000000000E+00, \
       6.0000000000E+00, \
       8.0000000000E+00, \
      10.0000000000E+00, \
      15.0000000000E+00, \
      20.0000000000E+00, \
      30.0000000000E+00, \
      50.0000000000E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def tran09_values_test ( ):

#*****************************************************************************80
#
## tran09_values_test() tests tran09_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'tran09_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  tran09_values stores values of the tran09 function.' )
  print ( '' )
  print ( '      X         tran09(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = tran09_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'tran09_values_test:' )
  print ( '  Normal end of execution.' )
  return

def trigamma_values ( n_data ):

#*****************************************************************************80
#
## trigamma_values returns some values of the trigamma function.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      PolyGamma[1,x]
#
#    trigamma(X) = d^2 ln ( Gamma ( X ) ) / d X^2
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 11

  f_vec = np.array ( ( \
     0.1644934066848226E+01, \
     0.1433299150792759E+01, \
     0.1267377205423779E+01, \
     0.1134253434996619E+01, \
     0.1025356590529597E+01, \
     0.9348022005446793E+00, \
     0.8584318931245799E+00, \
     0.7932328301639984E+00, \
     0.7369741375017002E+00, \
     0.6879720582426356E+00, \
     0.6449340668482264E+00 ))

  x_vec = np.array ( ( \
    1.0E+00, \
    1.1E+00, \
    1.2E+00, \
    1.3E+00, \
    1.4E+00, \
    1.5E+00, \
    1.6E+00, \
    1.7E+00, \
    1.8E+00, \
    1.9E+00, \
    2.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    x = 0.0
    f = 0.0
  else:
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, x, f

def trigamma_values_test ( ):

#*****************************************************************************80
#
## trigamma_values_test() tests trigamma_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'trigamma_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  trigamma_values stores values of the trigamma function.' )
  print ( '' )
  print ( '      X         trigamma(X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, x, f = trigamma_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12f  %24.16f' % ( x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'trigamma_values_test:' )
  print ( '  Normal end of execution.' )
  return

def truncated_normal_ab_cdf_values ( n_data ):

#*****************************************************************************80
#
## truncated_normal_ab_cdf_values: values of the Truncated Normal AB CDF.
#
#  Discussion:
#
#    The Normal distribution, with mean Mu and standard deviation Sigma,
#    is truncated to the interval [A,B].
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real MU, the mean of the distribution.
#
#    real SIGMA, the standard deviation of the distribution.
#
#    real A, B, the lower and upper truncation limits.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 11

  a_vec = np.array ( ( \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0 ))

  b_vec = np.array ( ( \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0 ))

  f_vec = np.array ( ( \
    0.3371694242213513, \
    0.3685009225506048, \
    0.4006444233448185, \
    0.4334107066903040, \
    0.4665988676496338, \
    0.5000000000000000, \
    0.5334011323503662, \
    0.5665892933096960, \
    0.5993555766551815, \
    0.6314990774493952, \
    0.6628305757786487 ))

  mu_vec = np.array ( ( \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0 )) 

  sigma_vec = np.array ( ( \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0  ))

  x_vec = np.array ( ( \
     90.0, \
     92.0, \
     94.0, \
     96.0, \
     98.0, \
    100.0, \
    102.0, \
    104.0, \
    106.0, \
    108.0, \
    110.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    mu = 0.0
    sigma = 0.0
    a = 0.0
    b = 0.0
    x = 0.0
    f = 0.0
  else:
    mu = mu_vec[n_data]
    sigma = sigma_vec[n_data]
    a = a_vec[n_data]
    b = b_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, mu, sigma, a, b, x, f

def truncated_normal_ab_cdf_values_test ( ):

#*****************************************************************************80
#
## truncated_normal_ab_cdf_values_test() tests truncated_normal_ab_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'truncated_normal_ab_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  truncated_normal_ab_cdf_values stores values of the truncated_normal_ab_cdf function.' )
  print ( '' )
  print ( '            MU         SIGMA             A             B             X               F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, mu, sigma, a, b, x, f = truncated_normal_ab_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %12g  %12g  %12g  %24.16g' % ( mu, sigma, a, b, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'truncated_normal_ab_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def truncated_normal_ab_pdf_values ( n_data ):

#*****************************************************************************80
#
## truncated_normal_ab_pdf_values: values of the Truncated Normal AB PDF.
#
#  Discussion:
#
#    The Normal distribution, with mean Mu and standard deviation Sigma,
#    is truncated to the interval [A,B].
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real MU, the mean of the distribution.
#
#    real SIGMA, the standard deviation of the distribution.
#
#    real A, B, the lower and upper truncation limits.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 11

  a_vec = np.array ( ( \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0 ))

  b_vec = np.array ( ( \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0 ))

  f_vec = np.array ( ( \
    0.01543301171801836, \
    0.01588394472270638, \
    0.01624375997031919, \
    0.01650575046469259, \
    0.01666496869385951, \
    0.01671838200940538, \
    0.01666496869385951, \
    0.01650575046469259, \
    0.01624375997031919, \
    0.01588394472270638, \
    0.01543301171801836 ))

  mu_vec = np.array ( ( \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0 )) 

  sigma_vec = np.array ( ( \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0  ))

  x_vec = np.array ( ( \
     90.0, \
     92.0, \
     94.0, \
     96.0, \
     98.0, \
    100.0, \
    102.0, \
    104.0, \
    106.0, \
    108.0, \
    110.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    mu = 0.0
    sigma = 0.0
    a = 0.0
    b = 0.0
    x = 0.0
    f = 0.0
  else:
    mu = mu_vec[n_data]
    sigma = sigma_vec[n_data]
    a = a_vec[n_data]
    b = b_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, mu, sigma, a, b, x, f

def truncated_normal_ab_pdf_values_test ( ):

#*****************************************************************************80
#
## truncated_normal_ab_pdf_values_test() tests truncated_normal_ab_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'truncated_normal_ab_pdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  truncated_normal_ab_pdf_values stores values of the truncated_normal_ab_pdf function.' )
  print ( '' )
  print ( '            MU         SIGMA             A             B             X               F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, mu, sigma, a, b, x, f = truncated_normal_ab_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %12g  %12g  %12g  %24.16g' % ( mu, sigma, a, b, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'truncated_normal_ab_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def truncated_normal_a_cdf_values ( n_data ):

#*****************************************************************************80
#
## truncated_normal_a_cdf_values: values of the Truncated Normal A CDF.
#
#  Discussion:
#
#    The Normal distribution, with mean Mu and standard deviation Sigma,
#    is truncated to the interval [A,+oo).
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real MU, the mean of the distribution.
#
#    real SIGMA, the standard deviation of the distribution.
#
#    real A, the lower truncation limit.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 11

  a_vec = np.array ( ( \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0 ))

  f_vec = np.array ( ( \
    0.3293202045481688, \
    0.3599223134505957, \
    0.3913175216041539, \
    0.4233210140873113, \
    0.4557365629792204, \
    0.4883601253415709, \
    0.5209836877039214, \
    0.5533992365958304, \
    0.5854027290789878, \
    0.6167979372325460, \
    0.6474000461349729 ))

  mu_vec = np.array ( ( \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0 )) 

  sigma_vec = np.array ( ( \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0  ))

  x_vec = np.array ( ( \
     90.0, \
     92.0, \
     94.0, \
     96.0, \
     98.0, \
    100.0, \
    102.0, \
    104.0, \
    106.0, \
    108.0, \
    110.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    mu = 0.0
    sigma = 0.0
    a = 0.0
    x = 0.0
    f = 0.0
  else:
    mu = mu_vec[n_data]
    sigma = sigma_vec[n_data]
    a = a_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, mu, sigma, a, x, f

def truncated_normal_a_cdf_values_test ( ):

#*****************************************************************************80
#
## truncated_normal_a_cdf_values_test() tests truncated_normal_a_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'truncated_normal_a_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  truncated_normal_a_cdf_values stores values of the truncated_normal_a_cdf function.' )
  print ( '' )
  print ( '            MU         SIGMA             A             X               F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, mu, sigma, a, x, f = truncated_normal_a_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %12g  %12g  %24.16g' % ( mu, sigma, a, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'truncated_normal_a_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def truncated_normal_a_pdf_values ( n_data ):

#*****************************************************************************80
#
## truncated_normal_a_pdf_values: values of the Truncated Normal A PDF.
#
#  Discussion:
#
#    The Normal distribution, with mean Mu and standard deviation Sigma,
#    is truncated to the interval [A,+oo).
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real MU, the mean of the distribution.
#
#    real SIGMA, the standard deviation of the distribution.
#
#    real A, the lower truncation limit.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 11

  a_vec = np.array ( ( \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0, \
     50.0 ))

  f_vec = np.array ( ( \
     0.01507373507401876, \
     0.01551417047139894, \
     0.01586560931024694, \
     0.01612150073158793, \
     0.01627701240029317, \
     0.01632918226724295, \
     0.01627701240029317, \
     0.01612150073158793, \
     0.01586560931024694, \
     0.01551417047139894, \
     0.01507373507401876 ))

  mu_vec = np.array ( ( \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0 )) 

  sigma_vec = np.array ( ( \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0  ))

  x_vec = np.array ( ( \
     90.0, \
     92.0, \
     94.0, \
     96.0, \
     98.0, \
    100.0, \
    102.0, \
    104.0, \
    106.0, \
    108.0, \
    110.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    mu = 0.0
    sigma = 0.0
    a = 0.0
    x = 0.0
    f = 0.0
  else:
    mu = mu_vec[n_data]
    sigma = sigma_vec[n_data]
    a = a_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, mu, sigma, a, x, f

def truncated_normal_a_pdf_values_test ( ):

#*****************************************************************************80
#
## truncated_normal_a_pdf_values_test() tests truncated_normal_a_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'truncated_normal_a_pdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  truncated_normal_a_pdf_values stores values of the truncated_normal_a_pdf function.' )
  print ( '' )
  print ( '            MU         SIGMA             A             X               F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, mu, sigma, a, x, f = truncated_normal_a_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %12g  %12g  %24.16g' % ( mu, sigma, a, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'truncated_normal_a_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def truncated_normal_b_cdf_values ( n_data ):

#*****************************************************************************80
#
## truncated_normal_b_cdf_values: values of the Truncated Normal B CDF.
#
#  Discussion:
#
#    The Normal distribution, with mean Mu and standard deviation Sigma,
#    is truncated to the interval (-oo,B].
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real MU, the mean of the distribution.
#
#    real SIGMA, the standard deviation of the distribution.
#
#    real B, the upper truncation limit.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 11

  b_vec = np.array ( ( \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0 ))

  f_vec = np.array ( ( \
    0.3525999538650271, \
    0.3832020627674540, \
    0.4145972709210122, \
    0.4466007634041696, \
    0.4790163122960786, \
    0.5116398746584291, \
    0.5442634370207796, \
    0.5766789859126887, \
    0.6086824783958461, \
    0.6400776865494043, \
    0.6706797954518312 ))

  mu_vec = np.array ( ( \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0 )) 

  sigma_vec = np.array ( ( \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0  ))

  x_vec = np.array ( ( \
     90.0, \
     92.0, \
     94.0, \
     96.0, \
     98.0, \
    100.0, \
    102.0, \
    104.0, \
    106.0, \
    108.0, \
    110.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    mu = 0.0
    sigma = 0.0
    b = 0.0
    x = 0.0
    f = 0.0
  else:
    mu = mu_vec[n_data]
    sigma = sigma_vec[n_data]
    b = b_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, mu, sigma, b, x, f

def truncated_normal_b_cdf_values_test ( ):

#*****************************************************************************80
#
## truncated_normal_b_cdf_values_test() tests truncated_normal_b_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'truncated_normal_b_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  truncated_normal_b_cdf_values stores values of the truncated_normal_b_cdf function.' )
  print ( '' )
  print ( '            MU         SIGMA             B             X               F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, mu, sigma, b, x, f = truncated_normal_b_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %12g  %12g  %24.16g' % ( mu, sigma, b, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'truncated_normal_b_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return


def truncated_normal_b_pdf_values ( n_data ):

#*****************************************************************************80
#
## truncated_normal_b_pdf_values: values of the Truncated Normal B PDF.
#
#  Discussion:
#
#    The Normal distribution, with mean Mu and standard deviation Sigma,
#    is truncated to the interval (-oo,B].
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real MU, the mean of the distribution.
#
#    real SIGMA, the standard deviation of the distribution.
#
#    real B, the upper truncation limit.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 11

  b_vec = np.array ( ( \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0, \
     150.0 ))

  f_vec = np.array ( ( \
    0.01507373507401876, \
    0.01551417047139894, \
    0.01586560931024694, \
    0.01612150073158793, \
    0.01627701240029317, \
    0.01632918226724295, \
    0.01627701240029317, \
    0.01612150073158793, \
    0.01586560931024694, \
    0.01551417047139894, \
    0.01507373507401876 ))

  mu_vec = np.array ( ( \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0, \
     100.0 )) 

  sigma_vec = np.array ( ( \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0, \
    25.0  ))

  x_vec = np.array ( ( \
     90.0, \
     92.0, \
     94.0, \
     96.0, \
     98.0, \
    100.0, \
    102.0, \
    104.0, \
    106.0, \
    108.0, \
    110.0 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    mu = 0.0
    sigma = 0.0
    b = 0.0
    x = 0.0
    f = 0.0
  else:
    mu = mu_vec[n_data]
    sigma = sigma_vec[n_data]
    b = b_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, mu, sigma, b, x, f

def truncated_normal_b_pdf_values_test ( ):

#*****************************************************************************80
#
## truncated_normal_b_pdf_values_test() tests truncated_normal_b_pdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'truncated_normal_b_pdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  truncated_normal_b_pdf_values stores values of the truncated_normal_b_pdf function.' )
  print ( '' )
  print ( '            MU         SIGMA             B             X               F' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, mu, sigma, b, x, f = truncated_normal_b_pdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %12g  %12g  %24.16g' % ( mu, sigma, b, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'truncated_normal_b_pdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def tsat_values ( n_data ):

#*****************************************************************************80
#
## tsat_values returns some values of the saturation temperature.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Lester Haar, John Gallagher and George Kell,
#    NBS/NRC Steam Tables:
#    Thermodynamic and transport Properties and Computer Programs
#    for Vapor and Liquid States of Water in SI Units,
#    Hemisphere Publishing Corporation, Washington, 1984,
#    TJ270.H3, pages 16-22.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real P, the pressure, in bar.
#
#    real TC, the saturation temperature, in
#    degrees Celsius.
#
  import numpy as np

  n_max = 20

  p_vec = np.array ( ( \
       0.0061173, \
       0.012, \
       0.025, \
       0.055, \
       0.080, \
       0.110, \
       0.160, \
       0.250, \
       0.500, \
       0.750, \
       1.000, \
       1.500, \
       2.000, \
       5.000, \
      10.000, \
      20.000, \
      50.000, \
     100.000, \
     200.000, \
     220.550 ))

  tc_vec = np.array ( ( \
       0.010, \
       9.655, \
      21.080, \
      34.589, \
      41.518, \
      47.695, \
      55.327, \
      64.980, \
      81.339, \
      91.783, \
      99.632, \
     111.378, \
     120.443, \
     151.866, \
     179.916, \
     212.417, \
     263.977, \
     311.031, \
     365.800, \
     373.976 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    p = 0.0
    tc = 0.0
  else:
    p = p_vec[n_data]
    tc = tc_vec[n_data]
    n_data = n_data + 1

  return n_data, p, tc

def tsat_values_test ( ):

#*****************************************************************************80
#
## tsat_values_test() tests tsat_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'tsat_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  tsat_values stores values of the TSAT function.' )
  print ( '' )
  print ( '      P          TSAT(P)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, p, tc = tsat_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %24.16g' % ( p, tc ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'tsat_values_test:' )
  print ( '  Normal end of execution.' )
  return

def van_der_corput_values ( n_data ):

#*****************************************************************************80
#
## van_der_corput_values returns some values of the van der Corput sequence.
#
#  Discussion:
#
#    The van der Corput sequence is often used to generate a "subrandom"
#    sequence of points which have a better covering property
#    than pseudorandom points.
#
#    The van der Corput sequence generates a sequence of points in [0,1]
#    which (theoretically) never repeats.  Except for SEED = 0, the
#    elements of the van der Corput sequence are strictly between 0 and 1.
#
#    The van der Corput sequence writes an integer in a given base B,
#    and then its digits are "reflected" about the decimal point.
#    This maps the numbers from 1 to N into a set of numbers in [0,1],
#    which are especially nicely distributed if N is one less
#    than a power of the base.
#
#    Hammersley suggested generating a set of N nicely distributed
#    points in two dimensions by setting the first component of the
#    Ith point to I/N, and the second to the van der Corput 
#    value of I in base 2.  
#
#    Halton suggested that in many cases, you might not know the number 
#    of points you were generating, so Hammersley's formulation was
#    not ideal.  Instead, he suggested that to generate a nicely
#    distributed sequence of points in M dimensions, you simply
#    choose the first M primes, P(1:M), and then for the J-th component of
#    the I-th point in the sequence, you compute the van der Corput
#    value of I in base P(J).
#
#    Thus, to generate a Halton sequence in a 2 dimensional space,
#    it is typical practice to generate a pair of van der Corput sequences,
#    the first with prime base 2, the second with prime base 3.
#    Similarly, by using the first K primes, a suitable sequence
#    in K-dimensional space can be generated.
#
#    The generation is quite simple.  Given an integer SEED, the expansion
#    of SEED in base BASE is generated.  Then, essentially, the result R
#    is generated by writing a decimal point followed by the digits of
#    the expansion of SEED, in reverse order.  This decimal value is actually
#    still in base BASE, so it must be properly interpreted to generate
#    a usable value.
#
#  Example:
#
#    BASE = 2
#
#    SEED     SEED      van der Corput
#    decimal  binary    binary   decimal
#    -------  ------    ------   -------
#        0  =     0  =>  .0     = 0.0;
#        1  =     1  =>  .1     = 0.5
#        2  =    10  =>  .01    = 0.25
#        3  =    11  =>  .11    = 0.75
#        4  =   100  =>  .001   = 0.125
#        5  =   101  =>  .101   = 0.625
#        6  =   110  =>  .011   = 0.375
#        7  =   111  =>  .111   = 0.875
#        8  =  1000  =>  .0001  = 0.0;625
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    J H Halton,
#    On the efficiency of certain quasi-random sequences of points
#    in evaluating multi-dimensional integrals,
#    Numerische Mathematik,
#    Volume 2, pages 84-90, 1960.
# 
#    J M Hammersley,
#    Monte Carlo methods for solving multivariable problems,
#    Proceedings of the New York Academy of Science,
#    Volume 86, pages 844-874, 1960.
#
#    J G van der Corput,
#    Verteilungsfunktionen,
#    Proc Akad Amsterdam,
#    Volume 38, 1935, 
#    Volume 39, 1936.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer BASE, the base of the sequence.
#
#    integer SEED, the index of the element of the sequence.
#
#    real VALUE, the value of the SEED-th element of the
#    van der Corput sequence in base BASE.
#
  import numpy as np

  n_max = 75

  base_vec = np.array ( ( \
     2,   2,   2,   2,   2, \
     2,   2,   2,   2,   3, \
     3,   3,   3,   3,   3, \
     3,   3,   3,   4,   4, \
     4,   4,   4,   4,   4, \
     4,   4,   2,   3,   4, \
     5,   7,  11,  13,   2, \
     3,   4,   5,   7,  11, \
    13,   2,   3,   4,   5, \
     7,  11,  13,   2,   3, \
     4,   5,   7,  11,  13, \
    29,  29,  29,  29,  29, \
    71,  71,  71,  71,  71, \
   173, 173, 173, 173, 173, \
   409, 409, 409, 409, 409 ))

  seed_vec = np.array ( ( \
        0,     1,     2,     3,     4, \
        5,     6,     7,     8,     0, \
        1,     2,     3,     4,     5, \
        6,     7,     8,     0,     1, \
        2,     3,     4,     5,     6, \
        7,     8,    10,    10,    10, \
       10,    10,    10,    10,   100, \
      100,   100,   100,   100,   100, \
      100,  1000,  1000,  1000,  1000, \
     1000,  1000,  1000, 10000, 10000, \
    10000, 10000, 10000, 10000, 10000, \
     1000,  1001,  1002,  1003,  1004, \
     1000,  1001,  1002,  1003,  1004, \
     1000,  1001,  1002,  1003,  1004, \
     1000,  1001,  1002,  1003,  1004 ))

  value_vec = np.array ( ( \
     0.0000000000000000E+00, \
     0.5000000000000000E+00, \
     0.2500000000000000E+00, \
     0.7500000000000000E+00, \
     0.1250000000000000E+00, \
     0.6250000000000000E+00, \
     0.3750000000000000E+00, \
     0.8750000000000000E+00, \
     0.0625000000000000E+00, \
     0.0000000000000000E+00, \
     0.3333333333333333E+00, \
     0.6666666666666666E+00, \
     0.1111111111111111E+00, \
     0.4444444444444444E+00, \
     0.7777777777777777E+00, \
     0.2222222222222222E+00, \
     0.5555555555555556E+00, \
     0.8888888888888888E+00, \
     0.0000000000000000E+00, \
     0.2500000000000000E+00, \
     0.5000000000000000E+00, \
     0.7500000000000000E+00, \
     0.0625000000000000E+00, \
     0.3125000000000000E+00, \
     0.5625000000000000E+00, \
     0.8125000000000000E+00, \
     0.1250000000000000E+00, \
     0.3125000000000000E+00, \
     0.3703703703703703E+00, \
     0.6250000000000000E+00, \
     0.0800000000000000E+00, \
     0.4489795918367347E+00, \
     0.9090909090909092E+00, \
     0.7692307692307693E+00, \
     0.1484375000000000E+00, \
     0.4115226337448559E+00, \
     0.0976562500000000E+00, \
     0.0320000000000000E+00, \
     0.2915451895043731E+00, \
     0.1652892561983471E+00, \
     0.7337278106508875E+00, \
     0.0927734375000000E+00, \
     0.3475080018289895E+00, \
     0.1708984375000000E+00, \
     0.0051200000000000E+00, \
     0.9162848812994586E+00, \
     0.9316303531179565E+00, \
     0.9904415111515704E+00, \
     0.0347290039062500E+00, \
     0.3861200020322105E+00, \
     0.0189208984375000E+00, \
     0.0005120000000000E+00, \
     0.5749985125245433E+00, \
     0.1529950140017758E+00, \
     0.2459297643639929E+00, \
     0.4887449259912255E+00, \
     0.5232276846119153E+00, \
     0.5577104432326049E+00, \
     0.5921932018532945E+00, \
     0.6266759604739842E+00, \
     0.0872842689942472E+00, \
     0.1013687760365007E+00, \
     0.1154532830787542E+00, \
     0.1295377901210077E+00, \
     0.1436222971632613E+00, \
     0.7805138828560928E+00, \
     0.7862942296769020E+00, \
     0.7920745764977113E+00, \
     0.7978549233185205E+00, \
     0.8036352701393298E+00, \
     0.4449997309915651E+00, \
     0.4474447187666262E+00, \
     0.4498897065416874E+00, \
     0.4523346943167484E+00, \
     0.4547796820918096E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    base = 0
    seed = 0
    value = 0.0
  else:
    base = base_vec[n_data]
    seed = seed_vec[n_data]
    value = value_vec[n_data]
    n_data = n_data + 1

  return n_data, base, seed, value

def van_der_corput_values_test ( ):

#*****************************************************************************80
#
## van_der_corput_values_test() tests van_der_corput_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'van_der_corput_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  van_der_corput_values stores values of the van_der_corput function.' )
  print ( '' )
  print ( '    BASE    SEED    VALUE' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, base, seed, value = van_der_corput_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12d  %12d  %24.12g' % ( base, seed, value ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'van_der_corput_values_test:' )
  print ( '  Normal end of execution.' )
  return

def viscosity_values ( n_data ):

#*****************************************************************************80
#
## viscosity_values returns some values of the viscosity function.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Lester Haar, John Gallagher and George Kell,
#    NBS/NRC Steam Tables:
#    Thermodynamic and transport Properties and Computer Programs
#    for Vapor and Liquid States of Water in SI Units,
#    Hemisphere Publishing Corporation, Washington, 1984,
#    TJ270.H3, page 263.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real TC, the temperature, in degrees Celsius.
#
#    real P, the pressure, in bar.
#
#    real ETA, the viscosity, in MegaPascal seconds.
#
  import numpy as np

  n_max = 34

  eta_vec = np.array ( ( \
     1792.0E+00, \
     1791.0E+00, \
     1790.0E+00, \
     1786.0E+00, \
     1780.0E+00, \
     1775.0E+00, \
     1769.0E+00, \
     1764.0E+00, \
     1759.0E+00, \
     1754.0E+00, \
     1749.0E+00, \
     1744.0E+00, \
     1739.0E+00, \
     1735.0E+00, \
     1731.0E+00, \
     1722.0E+00, \
     1714.0E+00, \
     1707.0E+00, \
     1700.0E+00, \
     1694.0E+00, \
     1687.0E+00, \
     1682.0E+00, \
     1676.0E+00, \
     1667.0E+00, \
     1659.0E+00, \
     1653.0E+00, \
      890.8E+00, \
      547.1E+00, \
      378.4E+00, \
      12.28E+00, \
      16.18E+00, \
      24.45E+00, \
      32.61E+00, \
      40.38E+00 ))

  p_vec = np.array ( ( \
        1.0E+00, \
        5.0E+00, \
       10.0E+00, \
       25.0E+00, \
       50.0E+00, \
       75.0E+00, \
      100.0E+00, \
      125.0E+00, \
      150.0E+00, \
      175.0E+00, \
      200.0E+00, \
      225.0E+00, \
      250.0E+00, \
      275.0E+00, \
      300.0E+00, \
      350.0E+00, \
      400.0E+00, \
      450.0E+00, \
      500.0E+00, \
      550.0E+00, \
      600.0E+00, \
      650.0E+00, \
      700.0E+00, \
      800.0E+00, \
      900.0E+00, \
     1000.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00, \
        1.0E+00 ))

  tc_vec = np.array ( ( \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
       0.0E+00, \
      25.0E+00, \
      50.0E+00, \
      75.0E+00, \
     100.0E+00, \
     200.0E+00, \
     400.0E+00, \
     600.0E+00, \
     800.0E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    tc = 0.0
    p = 0.0
    eta = 0.0
  else:
    tc = tc_vec[n_data]
    p = p_vec[n_data]
    eta = eta_vec[n_data]
    n_data = n_data + 1

  return n_data, tc, p, eta

def viscosity_values_test ( ):

#*****************************************************************************80
#
## viscosity_values_test() tests viscosity_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'viscosity_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  viscosity_values stores values of the VISCOSITY function.' )
  print ( '' )
  print ( '      TC         P        ETA(TC,P)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, tc, p, eta = viscosity_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %24.16g' % ( tc, p, eta ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'viscosity_values_test:' )
  print ( '  Normal end of execution.' )
  return

def von_mises_cdf_values ( n_data ):

#*****************************************************************************80
#
## von_mises_cdf_values returns some values of the von Mises CDF.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Kanti Mardia and Peter Jupp,
#    Directional Statistics,
#    Wiley, 2000, QA276.M335
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real A, B, the parameters of the function.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 23

  a_vec = np.array ( ( \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.1E+01, \
     0.1E+01, \
     0.1E+01, \
     0.1E+01, \
     0.1E+01, \
     0.1E+01, \
    -0.2E+01, \
    -0.1E+01, \
     0.0E+01, \
     0.1E+01, \
     0.2E+01, \
     0.3E+01, \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.0E+00, \
     0.0E+00 ))

  b_vec = np.array ( ( \
     0.1E+01, \
     0.1E+01, \
     0.1E+01, \
     0.1E+01, \
     0.1E+01, \
     0.2E+01, \
     0.2E+01, \
     0.2E+01, \
     0.2E+01, \
     0.2E+01, \
     0.2E+01, \
     0.3E+01, \
     0.3E+01, \
     0.3E+01, \
     0.3E+01, \
     0.3E+01, \
     0.3E+01, \
     0.0E+00, \
     0.1E+01, \
     0.2E+01, \
     0.3E+01, \
     0.4E+01, \
     0.5E+01 ))

  f_vec = np.array ( ( \
    0.2535089956281180E-01, \
    0.1097539041177346E+00, \
    0.5000000000000000E+00, \
    0.8043381312498558E+00, \
    0.9417460124555197E+00, \
    0.5000000000000000E+00, \
    0.6018204118446155E+00, \
    0.6959356933122230E+00, \
    0.7765935901304593E+00, \
    0.8410725934916615E+00, \
    0.8895777369550366E+00, \
    0.9960322705517925E+00, \
    0.9404336090170247E+00, \
    0.5000000000000000E+00, \
    0.5956639098297530E-01, \
    0.3967729448207649E-02, \
    0.2321953958111930E-03, \
    0.6250000000000000E+00, \
    0.7438406999109122E+00, \
    0.8369224904294019E+00, \
    0.8941711407897124E+00, \
    0.9291058600568743E+00, \
    0.9514289900655436E+00 ))

  x_vec = np.array ( ( \
    -0.2617993977991494E+01, \
    -0.1570796326794897E+01, \
     0.0000000000000000E+00, \
     0.1047197551196598E+01, \
     0.2094395102393195E+01, \
     0.1000000000000000E+01, \
     0.1200000000000000E+01, \
     0.1400000000000000E+01, \
     0.1600000000000000E+01, \
     0.1800000000000000E+01, \
     0.2000000000000000E+01, \
     0.0000000000000000E+00, \
     0.0000000000000000E+00, \
     0.0000000000000000E+00, \
     0.0000000000000000E+00, \
     0.0000000000000000E+00, \
     0.0000000000000000E+00, \
     0.7853981633974483E+00, \
     0.7853981633974483E+00, \
     0.7853981633974483E+00, \
     0.7853981633974483E+00, \
     0.7853981633974483E+00, \
     0.7853981633974483E+00 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    a = 0.0
    b = 0.0
    x = 0.0
    f = 0.0
  else:
    a = a_vec[n_data]
    b = b_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, a, b, x, f

def von_mises_cdf_values_test ( ):

#*****************************************************************************80
#
## von_mises_cdf_values_test() tests von_mises_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'von_mises_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  von_mises_cdf_values stores values of the von Mises CDF.' )
  print ( '' )
  print ( '      A           B           X         CDF(A,B,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, a, b, x, f = von_mises_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %12g  %24.16g' % ( a, b, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'von_mises_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def weekday_values ( n_data ):

#*****************************************************************************80
#
## weekday_values returns the day of the week for various dates.
#
#  Discussion:
#
#    The CE or Common Era calendar is used, under the
#    hybrid Julian/Gregorian Calendar, with a transition from Julian
#    to Gregorian.  The day after 04 October 1582 was 15 October 1582.  
#
#    The year before 1 AD or CE is 1 BC or BCE.  In this data set,
#    years BC/BCE are indicated by a negative year value.  
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Edward Reingold, Nachum Dershowitz,
#    Calendrical Calculations: The Millennium Edition,
#    Cambridge University Press, 2001,
#    ISBN: 0 521 77752 6
#    LC: CE12.R45.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer Y, M, D, the Common Era date.
#
#    integer W, the day of the week.  Sunday = 1.
#
  import numpy as np

  n_max = 34

  d_vec = np.array ( ( \
    30, \
     8, \
    26, \
     3, \
     7, \
    18, \
     7, \
    19, \
    14, \
    18, \
    16, \
     3, \
    26, \
    20, \
     4, \
    25, \
    31, \
     9, \
    24, \
    10, \
    30, \
    24, \
    19, \
     2, \
    27, \
    19, \
    25, \
    29, \
    19, \
     7, \
    17, \
    25, \
    10, \
    18 ))

  m_vec = np.array ( ( \
     7, \
    12, \
     9, \
    10, \
     1, \
     5, \
    11, \
     4, \
    10, \
     5, \
     3, \
     3, \
     3, \
     4, \
     6, \
     1, \
     3, \
     9, \
     2, \
     6, \
     6, \
     7, \
     6, \
     8, \
     3, \
     4, \
     8, \
     9, \
     4, \
    10, \
     3, \
     2, \
    11, \
     7 ))

  w_vec = np.array ( ( \
    1, \
    4, \
    4, \
    1, \
    4, \
    2, \
    7, \
    1, \
    7, \
    1, \
    6, \
    7, \
    6, \
    1, \
    1, \
    4, \
    7, \
    7, \
    7, \
    4, \
    1, \
    6, \
    1, \
    2, \
    4, \
    1, \
    1, \
    2, \
    2, \
    5, \
    3, \
    1, \
    4, \
    1 ))

  y_vec = np.array ( ( \
    - 587, \
    - 169, \
       70, \
      135, \
      470, \
      576, \
      694, \
     1013, \
     1066, \
     1096, \
     1190, \
     1240, \
     1288, \
     1298, \
     1391, \
     1436, \
     1492, \
     1553, \
     1560, \
     1648, \
     1680, \
     1716, \
     1768, \
     1819, \
     1839, \
     1903, \
     1929, \
     1941, \
     1943, \
     1943, \
     1992, \
     1996, \
     2038, \
     2094 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    y = 0
    m = 0
    d = 0
    w = 0
  else:
    y = y_vec[n_data]
    m = m_vec[n_data]
    d = d_vec[n_data]
    w = w_vec[n_data]
    n_data = n_data + 1

  return n_data, y, m, d, w

def weekday_values_test ( ):

#*****************************************************************************80
#
## weekday_values_test() tests weekday_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'weekday_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  weekday_values stores values of' )
  print ( '  the weekday for a given Y/M/D date' )
  print ( '' )
  print ( '         Y       M       D           W' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, y, m, d, w = weekday_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %6d  %6d  %6d' % ( y, m, d, w ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'weekday_values_test:' )
  print ( '  Normal end of execution.' )
  return

def weibull_cdf_values ( n_data ):

#*****************************************************************************80
#
## weibull_cdf_values returns some values of the Weibull CDF.
#
#  Discussion:
#
#    In Mathematica, the function can be evaluated by:
#
#      Needs["Statistics`ContinuousDistributions`"]
#      dist = WeibullDistribution [ alpha, beta ]
#      CDF [ dist, x ]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real ALPHA, the first parameter of the distribution.
#
#    real BETA, the second parameter of the distribution.
#
#    real X, the argument of the function.
#
#    real F, the value of the function.
#
  import numpy as np

  n_max = 12

  alpha_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01 )) 

  beta_vec = np.array ( ( \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.5000000000000000E+00, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.5000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01 ))

  f_vec = np.array ( ( \
     0.8646647167633873E+00, \
     0.9816843611112658E+00, \
     0.9975212478233336E+00, \
     0.9996645373720975E+00, \
     0.6321205588285577E+00, \
     0.4865828809674080E+00, \
     0.3934693402873666E+00, \
     0.3296799539643607E+00, \
     0.8946007754381357E+00, \
     0.9657818816883340E+00, \
     0.9936702845725143E+00, \
     0.9994964109502630E+00 ))

  x_vec = np.array ( ( \
     0.1000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.4000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.2000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01, \
     0.3000000000000000E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    alpha = 0.0
    beta = 0.0
    x = 0.0
    f = 0.0
  else:
    alpha = alpha_vec[n_data]
    beta = beta_vec[n_data]
    x = x_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, alpha, beta, x, f

def weibull_cdf_values_test ( ):

#*****************************************************************************80
#
## weibull_cdf_values_test() tests weibull_cdf_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'weibull_cdf_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  weibull_cdf_values stores values of the von Mises CDF.' )
  print ( '' )
  print ( '      ALPHA       BETA        X         CDF(ALPHA,BETA,X)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, alpha, beta, x, f = weibull_cdf_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %12g  %24.16g' % ( alpha, beta, x, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'weibull_cdf_values_test:' )
  print ( '  Normal end of execution.' )
  return

def wright_omega_values ( n_data ):

#*****************************************************************************80
#
## wright_omega_values returns values of the Wright Omega function.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 May 2016
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Robert Corless, David Jeffrey,
#    The Wright Omega Function,
#    in Artificial Intelligence, Automated Reasoning, and Symbolic Computation,
#    ed J Calmet, B Benhamou, O Caprotti, L Henocque, V Sorge,
#    Lecture Notes in Artificial Intelligence, volume 2385,
#    Springer, 2002, pages 76-89.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    complex X, the argument of the function.
#
#    complex CAI, the value of the function.
#
  import numpy as np

  n_max = 10

  fz_vec = np.array ( [ \
    +0.5671432904097838  +0.0000000000000000j, \
    +1.000000000000000   +0.0000000000000000j, \
    +2.718281828459045   +0.0000000000000000j, \
    -1.000000000000000   +0.0000000000000000j, \
    -1.000000000000000   +0.0000000000000000j, \
    -2.000000000000000   +0.0000000000000000j, \
    -0.40637573995996    +0.0000000000000000j, \
    +0.000000000000000   +1.0000000000000000j, \
    -0.3181315052047641  +1.337235701430689j, \
    +0.9372082083733697  +0.5054213160131512j ] )

  z_vec = np.array ( [ \
     +0.000000000000000   +0.000000000000000j, \
     +1.000000000000000   +0.000000000000000j, \
     +3.718281828459045   +0.000000000000000j, \
     -1.000000000000000   +3.141592653589793j, \
     -1.000000000000000   -3.141592653589793j, \
     -1.306852819440055   +3.141592653589793j, \
     -1.306852819440055   -3.141592653589793j, \
     +0.000000000000000   +2.570796326794897j, \
     +0.000000000000000   +3.141592653589793j, \
     +1.000000000000000   +1.000000000000000j ] )

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    z = 0.0 + 0.0j
    fz = 0.0 + 0.0j
  else:
    z = z_vec[n_data]
    fz = fz_vec[n_data]
    n_data = n_data + 1

  return n_data, z, fz

def wright_omega_values_test ( ):

#*****************************************************************************80
#
## wright_omega_values_test() tests wright_omega_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 May 2016
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'wright_omega_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  wright_omega_values stores values of' )
  print ( '  the Wright Omega function.' )
  print ( '' )
  print ( '        Z.real        Z.imag          FZ.real                FZ.imag' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, z, fz = wright_omega_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %12g  %12g  %24.16g  %24.16g' \
      % ( z.real, z.imag, fz.real, fz.imag ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'wright_omega_values_test:' )
  print ( '  Normal end of execution.' )
  return

def zeta_m1_values ( n_data ):

#*****************************************************************************80
#
## zeta_m1_values returns some values of the Riemann Zeta function minus 1.
#
#  Discussion:
#
#    zeta_m1(N) = ZETA(N) - 1
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 January 2016
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    real P, the argument.
#
#    real F, the value.
#
  import numpy as np

  n_max = 17

  p_vec = np.array ( ( \
     2.0, \
     2.5, \
     3.0, \
     3.5, \
     4.0, \
     5.0, \
     6.0, \
     7.0, \
     8.0, \
     9.0, \
    10.0, \
    11.0, \
    12.0, \
    16.0, \
    20.0, \
    30.0, \
    40.0 ))

  f_vec = np.array ( ( \
     0.64493406684822643647E+00, \
     0.3414872573E+00, \
     0.20205690315959428540E+00, \
     0.1267338673E+00, \
     0.8232323371113819152E-01, \
     0.3692775514336992633E-01, \
     0.1734306198444913971E-01, \
     0.834927738192282684E-02, \
     0.407735619794433939E-02, \
     0.200839292608221442E-02, \
     0.99457512781808534E-03, \
     0.49418860411946456E-03, \
     0.24608655330804830E-03, \
     0.1528225940865187E-04, \
     0.95396203387280E-06, \
     0.93132743242E-10, \
     0.90949478E-12 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    p = 0.0
    f = 0.0
  else:
    p = p_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, p, f

def zeta_m1_values_test ( ):

#*****************************************************************************80
#
## zeta_m1_values_test() tests zeta_m1_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    15 January 2017
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'zeta_m1_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  zeta_m1_values stores values of the zeta_MINUS_ONE function.' )
  print ( '' )
  print ( '      N         zeta_m1(N)' )
  print ( '' )

  n_data = 0

  while ( True ):
    n_data, p, f = zeta_m1_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %8f  %24.16e' % ( p, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'zeta_m1_values_test:' )
  print ( '  Normal end of execution.' )
  return

def zeta_values ( n_data ):

#*****************************************************************************80
#
## zeta_values returns some values of the Riemann Zeta function.
#
#  Discussion:
#
#    ZETA(N) = sum ( 1 <= I < Infinity ) 1 / I^N
#
#    In Mathematica, the function can be evaluated by:
#
#      Zeta[n]
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
#  Reference:
#
#    Milton Abramowitz and Irene Stegun,
#    Handbook of Mathematical Functions,
#    US Department of Commerce, 1964.
#
#    Stephen Wolfram,
#    The Mathematica Book,
#    Fourth Edition,
#    Wolfram Media / Cambridge University Press, 1999.
#
#  Input:
#
#    integer N_data.  The user sets N_data to 0 before the first call.  
#
#  Output:
#
#    integer N_data.  On each call, the routine increments N_data by 1, and
#    returns the corresponding data; when there is no more data, the
#    output value of N_data will be 0 again.
#
#    integer N, the argument of the Zeta function.
#
#    real F, the value of the Zeta function.
#
  import numpy as np

  n_max = 15

  n_vec = np.array ( ( \
     2, \
     3, \
     4, \
     5, \
     6, \
     7, \
     8, \
     9, \
    10, \
    11, \
    12, \
    16, \
    20, \
    30, \
    40 ))

  f_vec = np.array ( ( \
     0.164493406684822643647E+01, \
     0.120205690315959428540E+01, \
     0.108232323371113819152E+01, \
     0.103692775514336992633E+01, \
     0.101734306198444913971E+01, \
     0.100834927738192282684E+01, \
     0.100407735619794433939E+01, \
     0.100200839292608221442E+01, \
     0.100099457512781808534E+01, \
     0.100049418860411946456E+01, \
     0.100024608655330804830E+01, \
     0.100001528225940865187E+01, \
     0.100000095396203387280E+01, \
     0.100000000093132743242E+01, \
     0.100000000000090949478E+01 ))

  if ( n_data < 0 ):
    n_data = 0

  if ( n_max <= n_data ):
    n_data = 0
    n = 0
    f = 0.0
  else:
    n = n_vec[n_data]
    f = f_vec[n_data]
    n_data = n_data + 1

  return n_data, n, f

def zeta_values_test ( ):

#*****************************************************************************80
#
## zeta_values_test() tests zeta_values.
#
#  Licensing:
#
#    This code is distributed under the GNU LGPL license.
#
#  Modified:
#
#    22 February 2015
#
#  Author:
#
#    John Burkardt
#
  import platform

  print ( '' )
  print ( 'zeta_values_test:' )
  print ( '  Python version: %s' % ( platform.python_version ( ) ) )
  print ( '  zeta_values stores values of the ZETA function.' )
  print ( '' )
  print ( '      N         ZETA(N)' )
  print ( '' )

  n_data = 0

  while ( True ):

    n_data, n, f = zeta_values ( n_data )

    if ( n_data == 0 ):
      break

    print ( '  %6d  %24.16f' % ( n, f ) )
#
#  Terminate.
#
  print ( '' )
  print ( 'zeta_values_test:' )
  print ( '  Normal end of execution.' )
  return

if ( __name__ == '__main__' ):
  timestamp ( )
  test_values_test ( )
  timestamp ( )
 
