Tue Oct 19 17:15:52 2021

subset_test()
  Python version: 3.6.9
  Test subset().

agm_values_test:
  Python version: 3.6.9
  agm_values stores values of
  the arithmetic geometric mean function.

      A           B         AGM(A,B)

     22.000000     96.000000       52.2746411987042379
     83.000000     56.000000       68.8365300598585179
     42.000000      7.000000       20.6593011967340097
     26.000000     11.000000       17.6968548737436500
      4.000000     63.000000       23.8670497217533004
      6.000000     45.000000       20.7170159828059930
     40.000000     75.000000       56.1278422556166845
     80.000000      0.000000        0.0000000000000000
     90.000000     35.000000       59.2695650812296364
      9.000000      1.000000        3.9362355036495553
     53.000000     53.000000       53.0000000000000000
      1.000000      2.000000        1.4567910310469068
      1.000000      4.000000        2.2430285802876027
      1.000000      8.000000        3.6157561775973628

agm_values_test:
  Normal end of execution.

asm_enum_test:
  Python version: 3.6.9
  asm_enum returns the number of alternating sign
  matrices of a given order.

   0         1
   1         1
   2         2
   3         7
   4        42
   5       429
   6      7436
   7    218348

asm_enum_test:
  Normal end of execution.

asm_triangle_test
  Python version: 3.6.9
  asm_triangle returns a row of the alternating sign
  matrix triangle.

   0         1
   1         1         1
   2         2         3         2
   3         7        14        14         7
   4        42       105       135       105        42
   5       429      1287      2002      2002      1287       429
   6      7436     26026     47320     56784     47320     26026      7436
   7    218348    873392   1813968   2519400   2519400   1813968    873392    218348

asm_triangle_test:
  Normal end of execution.

bell_test():
  Python version: 3.6.9
  bell() computes Bell numbers.

  N  exact C(I)  computed C(I)

     0         1         1
     1         1         1
     2         2         2
     3         5         5
     4        15        15
     5        52        52
     6       203       203
     7       877       877
     8      4140      4140
     9     21147     21147
    10    115975    115975

bell_test():
  Normal end of execution.

bell_values_test:
  Python version: 3.6.9
  bell_values returns values of
  the Bell numbers.

     N        BELL(N)

     0           1
     1           1
     2           2
     3           5
     4          15
     5          52
     6         203
     7         877
     8        4140
     9       21147
    10      115975

bell_values_test:
  Normal end of execution.

catalan_test
  Python version: 3.6.9
  catalan() computes Catalan numbers.

  N  exact C(I)  computed C(I)

     0       1       1
     1       1       1
     2       2       2
     3       5       5
     4      14      14
     5      42      42
     6     132     132
     7     429     429
     8    1430    1430
     9    4862    4862
    10   16796   16796

catalan_test
  Normal end of execution.

catalan_row_next_test
  Python version: 3.6.9
  catalan_row_next computes a row of Catalan's triangle.

  First, compute row 7 from scratch.
  Row 7: 1 7 27 75 165 297 429 429

  Now compute rows one at a time:

 1
 1 1
 1 2 2
 1 3 5 5
 1 4 9 14 14
 1 5 14 28 42 42
 1 6 20 48 90 132 132
 1 7 27 75 165 297 429 429
 1 8 35 110 275 572 1001 1430 1430
 1 9 44 154 429 1001 2002 3432 4862 4862
 1 10 54 208 637 1638 3640 7072 11934 16796 16796

catalan_row_next_test
  Normal end of execution.

catalan_values_test:
  Python version: 3.6.9
  catalan_values returns values of
  the Catalan numbers.

     N        C(N)

     0           1
     1           1
     2           2
     3           5
     4          14
     5          42
     6         132
     7         429
     8        1430
     9        4862
    10       16796

catalan_values_test:
  Normal end of execution.

cfrac_to_rat_test
  Python version: 3.6.9
  cfrac_to_rat continued fraction => fraction.

  Regular fraction is   4096 /  15625

  Continued fraction coefficients:

     0       0
     1       3
     2       1
     3       4
     4       2
     5       1
     6       1
     7      11
     8      13

  The continued fraction convergents.
  The last row contains the value of the continued
  fraction, written as a common fraction.

  I, P(I), Q(I), P(I)/Q(I)

    0       0       1        0.000000
    1       1       3        0.333333
    2       1       4        0.250000
    3       5      19        0.263158
    4      11      42        0.261905
    5      16      61        0.262295
    6      27     103        0.262136
    7     313    1194        0.262144
    8    4096   15625        0.262144

cfrac_to_rat_test
  Normal end of execution.

cfrac_to_rfrac_test
  Python version: 3.6.9
  cfrac_to_rfrac: continued fraction to rational polynomial fraction.

  Rational polynomial numerator coefficients:

     0:             1
     1:             1
     2:             2

  Rational polynomial numerator coefficients:

     0:             1
     1:             3
     2:             1
     3:             1

  Continued fraction coefficients:

     0:             1
     1:           0.5
     2:       1.33333
     3:          -0.5
     4:          -1.5
     5:             2

  Recovered rational polynomial numerator coefficients:

     0:             1
     1:             1
     2:             2

  Recovered rational polynomial numerator coefficients:

     0:             1
     1:             3
     2:             1
     3:             1

cfrac_to_rfrac_test
  Normal end of execution.

ch_to_digit_test
  Python version: 3.6.9
  ch_to_digit: character -> decimal digit

        -2  "*"        -1
        -1  "*"        -1
         0  "0"         0
         1  "1"         1
         2  "2"         2
         3  "3"         3
         4  "4"         4
         5  "5"         5
         6  "6"         6
         7  "7"         7
         8  "8"         8
         9  "9"         9
        10  "*"        -1
        11  "*"        -1

ch_to_digit_test:
  Normal end of execution.

change_greedy_test
  Python version: 3.6.9
  change_greedy makes change using the biggest
  coins first.

  The total for which change is to be made: 73

  The available coins are:

       0       1
       1       5
       2      10
       3      25
       4      50
       5     100

     6:     4    2    2    0    0    0
    73:    50   10   10    1    1    1

change_greedy_test
  Normal end of execution.

change_next_test
  Python version: 3.6.9
  change_next displays the next possible way to make
  change for a given total

  The total for which change is to be made: 50

  The available coins are:

       1
       5
      10
      25
      50
     100

    1:   50
    2:   25   25
    3:   25   10   10    5
    4:   25   10   10    1    1    1    1    1
    5:   25   10    5    5    5
    6:   25   10    5    5    1    1    1    1    1
    7:   25   10    5    1    1    1    1    1    1    1    1    1    1
    8:   25   10    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1
    9:   25    5    5    5    5    5
   10:   25    5    5    5    5    1    1    1    1    1

change_next_test
  Normal end of execution.

chinese_check_test
  Python version: 3.6.9
  chinese_check checks a set of moduluses for use with
  the Chinese Remainder representation.

  Modulus set #1:

     0       1
     1       3
     2       8
     3      25
  IERROR = 0

  Modulus set #2:

     0       1
     1       3
     2      -8
     3      25
  IERROR = 1

  Modulus set #3:

     0       1
     1       3
     2       1
     3      25
  IERROR = 2

  Modulus set #4:

     0       1
     1       3
     2       8
     3      24
  IERROR = 3

chinese_check_test
  Normal end of execution.

chinese_to_i4_test
  Python version: 3.6.9
  chinese_to_i4 computes an integer with the given
  Chinese Remainder representation.

  The moduli:

     0       3
     1       4
     2       5
     3       7

  The number being analyzed is 37

  The remainders:

     0       1
     1       1
     2       2
     3       2

  The reconstructed number is 37

  The remainders of the reconstructed number:

     0       1
     1       1
     2       2
     3       2

chinese_to_i4_test
  Normal end of execution.

comb_next_test
  Python version: 3.6.9
  comb_next produces combinations.
  We are selecting from a set of size 5

  Combinations of size 1:

 1
 2
 3
 4
 5

  Combinations of size 2:

 1 2
 1 3
 1 4
 1 5
 2 3
 2 4
 2 5
 3 4
 3 5
 4 5

  Combinations of size 3:

 1 2 3
 1 2 4
 1 2 5
 1 3 4
 1 3 5
 1 4 5
 2 3 4
 2 3 5
 2 4 5
 3 4 5

  Combinations of size 4:

 1 2 3 4
 1 2 3 5
 1 2 4 5
 1 3 4 5
 2 3 4 5

  Combinations of size 5:

 1 2 3 4 5

comb_next_test
  Normal end of execution.

comb_row_next_test
  Python version: 3.6.9
  comb_row_next computes a row of Pascal's triangle.

   0    1
   1    1    1
   2    1    2    1
   3    1    3    3    1
   4    1    4    6    4    1
   5    1    5   10   10    5    1
   6    1    6   15   20   15    6    1
   7    1    7   21   35   35   21    7    1
   8    1    8   28   56   70   56   28    8    1
   9    1    9   36   84  126  126   84   36    9    1
  10    1   10   45  120  210  252  210  120   45   10    1

comb_row_next_test
  Normal end of execution.

comb_unrank_test
  Python version: 3.6.9
  comb_unrank returns a combination of N things
  out of M, given the lexicographic rank.

  The total set size is M = 10
  The subset size is N =    5
  The number of combinations of N out of M is 252

   Rank	  Combination

    1      1      2      3      4      5
    2      1      2      3      4      6
    3      1      2      3      4      7
    6      1      2      3      4     10
    7      1      2      3      5      6
    8      1      2      3      5      7
  250      5      6      8      9     10
  251      5      7      8      9     10
  252      6      7      8      9     10

comb_unrank_test:
  Normal end of execution.

comp_enum_test
  Python version: 3.6.9
  comp_enum counts compositions.

       1       1       1       1       1       1       1       1       1       1
       1       2       3       4       5       6       7       8       9      10
       1       3       6      10      15      21      28      36      45      55
       1       4      10      20      35      56      84     120     165     220
       1       5      15      35      70     126     210     330     495     715
       1       6      21      56     126     252     462     792    1287    2002
       1       7      28      84     210     462     924    1716    3003    5005
       1       8      36     120     330     792    1716    3432    6435   11440
       1       9      45     165     495    1287    3003    6435   12870   24310
       1      10      55     220     715    2002    5005   11440   24310   48620
       1      11      66     286    1001    3003    8008   19448   43758   92378

comp_enum_test:
  Normal end of execution.

comp_next_test
  Python version: 3.6.9
  comp_next generates compositions.

  Seeking all compositions of N = 6
  using 3 parts.

   6   0   0  
   5   1   0  
   4   2   0  
   3   3   0  
   2   4   0  
   1   5   0  
   0   6   0  
   5   0   1  
   4   1   1  
   3   2   1  
   2   3   1  
   1   4   1  
   0   5   1  
   4   0   2  
   3   1   2  
   2   2   2  
   1   3   2  
   0   4   2  
   3   0   3  
   2   1   3  
   1   2   3  
   0   3   3  
   2   0   4  
   1   1   4  
   0   2   4  
   1   0   5  
   0   1   5  
   0   0   6  

comp_next_test
  Normal end of execution.

comp_next_grlex_test
  Python version: 3.6.9
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  comp_next_grlex determines the next COMP in
  graded lexicographic (grlex) order.

  Rank:     NC       COMP
  ----:     --   ------------
     1:      0 =  0 +  0 +  0
  ----:     --   ------------
     2:      1 =  0 +  0 +  1
     3:      1 =  0 +  1 +  0
     4:      1 =  1 +  0 +  0
  ----:     --   ------------
     5:      2 =  0 +  0 +  2
     6:      2 =  0 +  1 +  1
     7:      2 =  0 +  2 +  0
     8:      2 =  1 +  0 +  1
     9:      2 =  1 +  1 +  0
    10:      2 =  2 +  0 +  0
  ----:     --   ------------
    11:      3 =  0 +  0 +  3
    12:      3 =  0 +  1 +  2
    13:      3 =  0 +  2 +  1
    14:      3 =  0 +  3 +  0
    15:      3 =  1 +  0 +  2
    16:      3 =  1 +  1 +  1
    17:      3 =  1 +  2 +  0
    18:      3 =  2 +  0 +  1
    19:      3 =  2 +  1 +  0
    20:      3 =  3 +  0 +  0
  ----:     --   ------------
    21:      4 =  0 +  0 +  4
    22:      4 =  0 +  1 +  3
    23:      4 =  0 +  2 +  2
    24:      4 =  0 +  3 +  1
    25:      4 =  0 +  4 +  0
    26:      4 =  1 +  0 +  3
    27:      4 =  1 +  1 +  2
    28:      4 =  1 +  2 +  1
    29:      4 =  1 +  3 +  0
    30:      4 =  2 +  0 +  2
    31:      4 =  2 +  1 +  1
    32:      4 =  2 +  2 +  0
    33:      4 =  3 +  0 +  1
    34:      4 =  3 +  1 +  0
    35:      4 =  4 +  0 +  0
  ----:     --   ------------
    36:      5 =  0 +  0 +  5
    37:      5 =  0 +  1 +  4
    38:      5 =  0 +  2 +  3
    39:      5 =  0 +  3 +  2
    40:      5 =  0 +  4 +  1
    41:      5 =  0 +  5 +  0
    42:      5 =  1 +  0 +  4
    43:      5 =  1 +  1 +  3
    44:      5 =  1 +  2 +  2
    45:      5 =  1 +  3 +  1
    46:      5 =  1 +  4 +  0
    47:      5 =  2 +  0 +  3
    48:      5 =  2 +  1 +  2
    49:      5 =  2 +  2 +  1
    50:      5 =  2 +  3 +  0
    51:      5 =  3 +  0 +  2
    52:      5 =  3 +  1 +  1
    53:      5 =  3 +  2 +  0
    54:      5 =  4 +  0 +  1
    55:      5 =  4 +  1 +  0
    56:      5 =  5 +  0 +  0
  ----:     --   ------------
    57:      6 =  0 +  0 +  6
    58:      6 =  0 +  1 +  5
    59:      6 =  0 +  2 +  4
    60:      6 =  0 +  3 +  3
    61:      6 =  0 +  4 +  2
    62:      6 =  0 +  5 +  1
    63:      6 =  0 +  6 +  0
    64:      6 =  1 +  0 +  5
    65:      6 =  1 +  1 +  4
    66:      6 =  1 +  2 +  3
    67:      6 =  1 +  3 +  2
    68:      6 =  1 +  4 +  1
    69:      6 =  1 +  5 +  0
    70:      6 =  2 +  0 +  4
    71:      6 =  2 +  1 +  3

comp_next_grlex_test:
  Normal end of execution.

comp_random_grlex_test
  Python version: 3.6.9
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  comp_random_grlex selects a random COMP in
  graded lexicographic (grlex) order between indices RANK1 and RANK2.

    42: 
     5 = 
 1 + 
 0 + 
 4
    45: 
     5 = 
 1 + 
 3 + 
 1
    34: 
     4 = 
 3 + 
 1 + 
 0
    25: 
     4 = 
 0 + 
 4 + 
 0
    51: 
     5 = 
 3 + 
 0 + 
 2

comp_random_grlex_test:
  Normal end of execution.

comp_rank_grlex_test
  Python version: 3.6.9
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  comp_rank_grlex determines the rank of a COMP from
  its parts.

        Actual  Inferred
  Test    Rank      Rank

     0      28        28
     1      42        42
     2      60        60
     3      36        36
     4      60        60

comp_rank_grlex_test:
  Normal end of execution.

comp_to_ksub_test
  Python version: 3.6.9
  comp_to_ksub returns the K subset corresponding to a composition.

  COMP:     2   4   3   1   0
  KSUB:     3   8  12  14

  COMP:     0   6   4   0   0
  KSUB:     1   8  13  14

  COMP:     9   0   0   0   1
  KSUB:    10  11  12  13

  COMP:     3   1   0   0   6
  KSUB:     4   6   7   8

  COMP:     0   0   8   0   2
  KSUB:     1   2  11  12

comp_to_ksub_test:
  Normal end of execution.

comp_unrank_grlex_test
  Python version: 3.6.9
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  comp_unrank_grlex determines the parts
  of a COMP from its rank.

  Rank: ->  NC       COMP    
  ----:     --   ------------ 
     1:      0 =  0 +  0 +  0
  ----:     --   ------------
     2:      1 =  0 +  0 +  1
     3:      1 =  0 +  1 +  0
     4:      1 =  1 +  0 +  0
  ----:     --   ------------
     5:      2 =  0 +  0 +  2
     6:      2 =  0 +  1 +  1
     7:      2 =  0 +  2 +  0
     8:      2 =  1 +  0 +  1
     9:      2 =  1 +  1 +  0
    10:      2 =  2 +  0 +  0
  ----:     --   ------------
    11:      3 =  0 +  0 +  3
    12:      3 =  0 +  1 +  2
    13:      3 =  0 +  2 +  1
    14:      3 =  0 +  3 +  0
    15:      3 =  1 +  0 +  2
    16:      3 =  1 +  1 +  1
    17:      3 =  1 +  2 +  0
    18:      3 =  2 +  0 +  1
    19:      3 =  2 +  1 +  0
    20:      3 =  3 +  0 +  0
  ----:     --   ------------
    21:      4 =  0 +  0 +  4
    22:      4 =  0 +  1 +  3
    23:      4 =  0 +  2 +  2
    24:      4 =  0 +  3 +  1
    25:      4 =  0 +  4 +  0
    26:      4 =  1 +  0 +  3
    27:      4 =  1 +  1 +  2
    28:      4 =  1 +  2 +  1
    29:      4 =  1 +  3 +  0
    30:      4 =  2 +  0 +  2
    31:      4 =  2 +  1 +  1
    32:      4 =  2 +  2 +  0
    33:      4 =  3 +  0 +  1
    34:      4 =  3 +  1 +  0
    35:      4 =  4 +  0 +  0
  ----:     --   ------------
    36:      5 =  0 +  0 +  5
    37:      5 =  0 +  1 +  4
    38:      5 =  0 +  2 +  3
    39:      5 =  0 +  3 +  2
    40:      5 =  0 +  4 +  1
    41:      5 =  0 +  5 +  0
    42:      5 =  1 +  0 +  4
    43:      5 =  1 +  1 +  3
    44:      5 =  1 +  2 +  2
    45:      5 =  1 +  3 +  1
    46:      5 =  1 +  4 +  0
    47:      5 =  2 +  0 +  3
    48:      5 =  2 +  1 +  2
    49:      5 =  2 +  2 +  1
    50:      5 =  2 +  3 +  0
    51:      5 =  3 +  0 +  2
    52:      5 =  3 +  1 +  1
    53:      5 =  3 +  2 +  0
    54:      5 =  4 +  0 +  1
    55:      5 =  4 +  1 +  0
    56:      5 =  5 +  0 +  0
  ----:     --   ------------
    57:      6 =  0 +  0 +  6
    58:      6 =  0 +  1 +  5
    59:      6 =  0 +  2 +  4
    60:      6 =  0 +  3 +  3
    61:      6 =  0 +  4 +  2
    62:      6 =  0 +  5 +  1
    63:      6 =  0 +  6 +  0
    64:      6 =  1 +  0 +  5
    65:      6 =  1 +  1 +  4
    66:      6 =  1 +  2 +  3
    67:      6 =  1 +  3 +  2
    68:      6 =  1 +  4 +  1
    69:      6 =  1 +  5 +  0
    70:      6 =  2 +  0 +  4
    71:      6 =  2 +  1 +  3

comp_unrank_grlex_test:
  Normal end of execution.

compnz_enum_test:
  Python version: 3.6.9
  compnz_enum returns the number of nonzero compositions
  of N into K parts.

   N\K      0     1     2     3     4     5     6     7

   0:       0
   1:       0     1
   2:       0     1     1
   3:       0     1     2     1
   4:       0     1     3     3     1
   5:       0     1     4     6     4     1
   6:       0     1     5    10    10     5     1
   7:       0     1     6    15    20    15     6     1

compnz_enum_test:
  Normal end of execution.

compnz_next_test
  Python version: 3.6.9
  compnz_next generates compositions
  with nonzero parts.

  Seeking all compositions of N = 6
  using 3 nonzero parts.

   4   1   1  
   3   2   1  
   2   3   1  
   1   4   1  
   3   1   2  
   2   2   2  
   1   3   2  
   2   1   3  
   1   2   3  
   1   1   4  

compnz_next_test
  Normal end of execution.

compnz_random_test
  Python version: 3.6.9
  compnz_random generates random compositions
  using nonzero parts.

  Seeking random compositions of N = 10
  using 5 nonzero parts.

   2   1   1   5   1
   4   1   2   1   2
   2   1   1   5   1
   5   1   1   1   2
   1   3   3   2   1

compnz_random_test:
  Normal end of execution.

compnz_to_ksub_test
  Python version: 3.6.9
  compnz_to_ksub returns the K subset corresponding
  to a nonzero composition.

  The composition sums to 10
  and contains 5 parts.

  COMPNZ:   1   3   2   1   3
  KSUB:     1   4   6   7

  COMPNZ:   4   1   1   2   2
  KSUB:     4   5   6   8

  COMPNZ:   4   2   1   1   2
  KSUB:     4   6   7   8

  COMPNZ:   1   2   3   2   2
  KSUB:     1   3   6   8

  COMPNZ:   3   1   2   3   1
  KSUB:     3   4   6   9

compnz_to_ksub_test:
  Normal end of execution.

congruence_test
  Python version: 3.6.9
  congruence solves a congruence equation:
    A * X = C mod ( B )

   I        A         B         C         X     Mod ( A*X-C,B)

   0      1027       712         7       269         0
   1      1027       712        -7       443         0
   2      1027      -712         7     -1155         0
   3      1027      -712        -7      -981         0
   4     -1027       712         7       443         0
   5     -1027       712        -7       269         0
   6     -1027      -712         7      -981         0
   7     -1027      -712        -7     -1155         0
   8         6         8        50         7         0
   9         0         0         0         0         0
  10         0         1         0         0         0
  11         0         1         1         0         0
  12         1         0         0         0         0
  13         1         0         1         1         0
  14         1         1         0         0         0
  15      1024    -15625     11529    -15629         0
  16         0         0         1         0         0
  17         0         3        11         0         1
  18         5         0        19         3         0
  19         2         4         7         0         1

congruence_test
  Normal end of execution.

count_pose_random_test
  Python version: 3.6.9
  count_pose_random poses a random problem for
  the game "The Count is Good".

  Problem #0

    The goal number:

      390

    The available numbers are

         1     2     8     9    10    25

  Problem #1

    The goal number:

      120

    The available numbers are

         1     2     6     8    25    50

  Problem #2

    The goal number:

      553

    The available numbers are

         3     6     8    10    50   100

  Problem #3

    The goal number:

      505

    The available numbers are

         2     3     5     8     9    25

  Problem #4

    The goal number:

      641

    The available numbers are

         3     4     5     8    10   100

count_pose_random_test:
  Normal end of execution.

debruijn_test
  Python version: 3.6.9
  debruijn computes a de Bruijn string.

  The alphabet size is M = 2
  The string length is N = 3

    21222111

  The alphabet size is M = 3
  The string length is N = 3

    212221132131232231332333111

  The alphabet size is M = 2
  The string length is N = 4

    2121122122221111

debruijn_test:
  Normal end of execution.

dec_add_test
  Python version: 3.6.9
  dec_add adds two decimals.

  Number of decimal places is 3

  A = 12.8
  B = 4.38
  C = 17.2

dec_add_test
  Normal end of execution.

dec_div_test
  Python version: 3.6.9
  dec_div divides two decimals.

  Number of decimal places is 3

  A = 52.3
  B = 13400
  C = 0.0039

dec_div_test
  Normal end of execution.

dec_mul_test
  Python version: 3.6.9
  dec_mul multiplies two decimals.

  Number of decimal places is 2

  A = 0.0014
  B = 1600
  C = 2.2

dec_mul_test
  Normal end of execution.

dec_round_test
  Python version: 3.6.9
  dec_round "rounds" a decimal to a number of digits.

           -----Before-------  -----After--------
  Digits   Mantissa  Exponent  Mantissa  Exponent

       1     523      -1           5       1
       2     523      -1          52       0
       3     523      -1         523      -1
       4     523      -1         523      -1
       2    6340       2          63       4
       3    6340       2         634       3
       4    6340       2         634       3

dec_round_test
  Normal end of execution.

dec_to_r8_test
  Python version: 3.6.9
  dec_to_r8 converts a decimal to a real number.

  The number of decimal digits is 5

     R   =>  A * 10^B  =>  R2

    6.974366   69743      -4    6.974300
   -2.155194  -21551      -4   -2.155100
    7.014973   70149      -4    7.014900
    6.554701   65547      -4    6.554700
   -5.250031    -525      -2   -5.250000
    2.294931   22949      -4    2.294900
   -3.448587  -34485      -4   -3.448500
   -1.440540  -14405      -4   -1.440500
   -7.594657  -75946      -4   -7.594600
   -0.689154  -68915      -5   -0.689150

dec_to_r8_test
  Normal end of execution.

dec_to_rat_test
  Python version: 3.6.9
  dec_to_rat decimal => fraction.

  In this test, choose the top and bottom
  of a rational at random, and compute the
  equivalent real number.

  Then convert to decimal, and the equivalent real.

  Then convert back to rational and the equivalent real.

  -0.198582 = -140 / 705
  -0.198582 = -198581560283688 * 10^-15
  -0.198582 = -24822695035461 / 125000000000000

  0.419753 = 102 / 243
  0.419753 = 4197530864197531 * 10^-16
  0.419753 = 4197530864197531 / 10000000000000000

  1.66995 = 339 / 203
  1.66995 = 16699507389162562 * 10^-16
  1.66995 = 8349753694581281 / 5000000000000000

  0.770175 = 439 / 570
  0.770175 = 7701754385964912 * 10^-16
  0.770175 = 481359649122807 / 625000000000000

  2.88496 = 978 / 339
  2.88496 = 28849557522123904 * 10^-16
  2.88496 = 225387168141593 / 78125000000000

  14.5373 = 974 / 67
  14.5373 = 1453731343283582 * 10^-14
  14.5373 = 726865671641791 / 50000000000000

  -0.575456 = -347 / 603
  -0.575456 = -5754560530679932 * 10^-16
  -0.575456 = -1438640132669983 / 2500000000000000

  -9.96491 = -568 / 57
  -9.96491 = -9964912280701756 * 10^-15
  -9.96491 = -2491228070175439 / 250000000000000

  -6.94656 = -910 / 131
  -6.94656 = -6946564885496186 * 10^-15
  -6.94656 = -3473282442748093 / 500000000000000

  -0.694985 = -679 / 977
  -0.694985 = -6949846468781985 * 10^-16
  -0.694985 = -1389969293756397 / 2000000000000000

dec_to_rat_test
  Normal end of execution.

dec_to_s_test
  Python version: 3.6.9
  dec_to_s prints a decimal value.

  Mantissa  Exponent  String

       523        -1  52.3
       134         2  13400
      -134         2  -13400
         0        10  0
    123456        -8  0.00123456
    123456        -7  0.0123456
    123456        -6  0.123456
    123456        -5  1.23456
    123456        -4  12.3456
    123456        -3  123.456
    123456        -2  1234.56
    123456        -1  12345.6
    123456         0  123456
    123456         1  1234560
    123456         2  12345600
    123456         3  123456000

dec_to_s_test:
  Normal end of execution.

dec_width_test
  Python version: 3.6.9
  dec_width determines the "width" of a decimal.

  Mantissa  Exponent  Width

     523      -1       4
     134       2       5
    -134       2       6
       0      10       1
  123456      -8      10
  123456      -7       9
  123456      -6       8
  123456      -5       7
  123456      -4       7
  123456      -3       7
  123456      -2       7
  123456      -1       7
  123456       0       6
  123456       1       7
  123456       2       8
  123456       3       9

dec_width_test
  Normal end of execution.

derange_enum_test
  Python version: 3.6.9
  derange_enum counts derangements;

  N    # of derangements

         0         1
         1         0
         2         1
         3         2
         4         9
         5        44
         6       265
         7      1854
         8     14833
         9    133496
        10   1334961

derange_enum_test:
  Normal end of execution.

derange_enum2_test
  Python version: 3.6.9
  derange_enum2 counts derangements;

  N    # of derangements

         0         1
         1         0
         2         1
         3         2
         4         9
         5        44
         6       265
         7      1854
         8     14833
         9    133496
        10   1334961

derange_enum2_test:
  Normal end of execution.

derange_enum3_test
  Python version: 3.6.9
  derange_enum3 counts derangements;

  N    # of derangements

         0         1
         1         0
         2         0
         3         2
         4         8
         5        44
         6       264
         7      1854
         8     14832
         9    133496
        10   1334960

derange_enum3_test:
  Normal end of execution.

derange0_back_next_test
  Python version: 3.6.9
  derange0_back_next generates derangements
  using backtracking.

  Here, we seek all derangements of order N = 5

   1
   4
   3
   1
   2
   0

   2
   4
   3
   1
   0
   2

   3
   4
   3
   0
   2
   1

   4
   4
   3
   0
   1
   2

   5
   4
   2
   3
   1
   0

   6
   4
   2
   3
   0
   1

   7
   4
   2
   1
   0
   3

   8
   4
   2
   0
   1
   3

   9
   4
   0
   3
   2
   1

  10
   4
   0
   3
   1
   2

  11
   4
   0
   1
   2
   3

  12
   3
   4
   1
   2
   0

  13
   3
   4
   1
   0
   2

  14
   3
   4
   0
   2
   1

  15
   3
   4
   0
   1
   2

  16
   3
   2
   4
   1
   0

  17
   3
   2
   4
   0
   1

  18
   3
   2
   1
   4
   0

  19
   3
   2
   0
   4
   1

  20
   3
   0
   4
   2
   1

  21
   3
   0
   4
   1
   2

  22
   3
   0
   1
   4
   2

  23
   2
   4
   3
   1
   0

  24
   2
   4
   3
   0
   1

  25
   2
   4
   1
   0
   3

  26
   2
   4
   0
   1
   3

  27
   2
   3
   4
   1
   0

  28
   2
   3
   4
   0
   1

  29
   2
   3
   1
   4
   0

  30
   2
   3
   0
   4
   1

  31
   2
   0
   4
   1
   3

  32
   2
   0
   3
   4
   1

  33
   2
   0
   1
   4
   3

  34
   1
   4
   3
   2
   0

  35
   1
   4
   3
   0
   2

  36
   1
   4
   0
   2
   3

  37
   1
   3
   4
   2
   0

  38
   1
   3
   4
   0
   2

  39
   1
   3
   0
   4
   2

  40
   1
   2
   4
   0
   3

  41
   1
   2
   3
   4
   0

  42
   1
   2
   0
   4
   3

  43
   1
   0
   4
   2
   3

  44
   1
   0
   3
   4
   2


derange0_back_next_test:
  Normal end of execution.

derange0_check_test
  Python version: 3.6.9
  derange0_check_checks whether a vector of N objects
  represents a derangement of (1,...,N).
  Potential derangement: 1 2 3 4 0
  CHECK = True
  Potential derangement: 1 4 2 0 3
  CHECK = False
  Potential derangement: 1 2 3 0 3
  CHECK = False
  Potential derangement: -1 2 3 4 0
  CHECK = False
  Potential derangement: 0 3 8 1 2
  CHECK = False

derange0_check_test
  Normal end of execution.

derange0_weed_next_test
  Python version: 3.6.9
  derange0_weed_next generates derangements
  by generating ALL permutations, and "weeding out"
  the ones that are not derangements.

  Here, we seek all derangements of order N = 5

   1:
   1
   0
   3
   4
   2

   2:
   1
   0
   4
   2
   3

   3:
   1
   2
   0
   4
   3

   4:
   1
   2
   3
   4
   0

   5:
   1
   2
   4
   0
   3

   6:
   1
   3
   0
   4
   2

   7:
   1
   3
   4
   0
   2

   8:
   1
   3
   4
   2
   0

   9:
   1
   4
   0
   2
   3

  10:
   1
   4
   3
   0
   2

  11:
   1
   4
   3
   2
   0

  12:
   2
   0
   1
   4
   3

  13:
   2
   0
   3
   4
   1

  14:
   2
   0
   4
   1
   3

  15:
   2
   3
   0
   4
   1

  16:
   2
   3
   1
   4
   0

  17:
   2
   3
   4
   0
   1

  18:
   2
   3
   4
   1
   0

  19:
   2
   4
   0
   1
   3

  20:
   2
   4
   1
   0
   3

  21:
   2
   4
   3
   0
   1

  22:
   2
   4
   3
   1
   0

  23:
   3
   0
   1
   4
   2

  24:
   3
   0
   4
   1
   2

  25:
   3
   0
   4
   2
   1

  26:
   3
   2
   0
   4
   1

  27:
   3
   2
   1
   4
   0

  28:
   3
   2
   4
   0
   1

  29:
   3
   2
   4
   1
   0

  30:
   3
   4
   0
   1
   2

  31:
   3
   4
   0
   2
   1

  32:
   3
   4
   1
   0
   2

  33:
   3
   4
   1
   2
   0

  34:
   4
   0
   1
   2
   3

  35:
   4
   0
   3
   1
   2

  36:
   4
   0
   3
   2
   1

  37:
   4
   2
   0
   1
   3

  38:
   4
   2
   1
   0
   3

  39:
   4
   2
   3
   0
   1

  40:
   4
   2
   3
   1
   0

  41:
   4
   3
   0
   1
   2

  42:
   4
   3
   0
   2
   1

  43:
   4
   3
   1
   0
   2

  44:
   4
   3
   1
   2
   0


derange0_weed_next_test
  Normal end of execution.

digit_to_ch_test
  Python version: 3.6.9
  digit_to_ch: decimal digit -> character.

        -2  "*"        -1
        -1  "*"        -1
         0  "0"         0
         1  "1"         1
         2  "2"         2
         3  "3"         3
         4  "4"         4
         5  "5"         5
         6  "6"         6
         7  "7"         7
         8  "8"         8
         9  "9"         9
        10  "*"        -1
        11  "*"        -1

digit_to_ch_test:
  Normal end of execution.

digraph_arc_euler_test
  Python version: 3.6.9
  digraph_arc_euler finds an Euler circuit of a digraph.

  The arc list of the digraph:

     0       2     5
     1       1     4
     2       2     3
     3       1     2
     4       3     1
     5       5     1
     6       4     2

  The edge list of the Euler circuit:

     0       6
     1       4
     2       3
     3       5
     4       2
     5       7
     6       1

  The node list of the Euler circuit:

    I  Edge  Node

     1     6     1
     2     4     2
     3     3     3
     4     5     1
     5     2     4
     6     7     2
     7     1     5

digraph_arc_euler_test:
  Normal end of execution.

digraph_arc_print_test
  Python version: 3.6.9
  digraph_arc_print prints a digraph.

  The arc list of the digraph:

     0       2     5
     1       1     4
     2       2     3
     3       1     2
     4       3     1
     5       5     1
     6       4     2

digraph_arc_print_test
  Normal end of execution.

diophantine_test
  Python version: 3.6.9
  diophantine solves a Diophantine equation:
    A * X + B * Y = C

        A         B         C         X     Y     Error

      1027       712         7       269      -388         0
      1027       712        -7      -269       388         0
      1027      -712         7       269       388         0
      1027      -712        -7      -269      -388         0
     -1027       712         7      -269      -388         0
     -1027       712        -7       269       388         0
     -1027      -712         7      -269       388         0
     -1027      -712        -7       269      -388         0
         6         8        50         3         4         0
         0         0         0         0         0         0
         0         1         0         0         0         0
         0         1         1         0         1         0
         1         0         0         0         0         0
         1         0         1         1         0         0
         1         1         0         1        -1         0
      1024    -15625     11529        -4        -1         0
         0         0         1  Error code = 1
         0         3        11  Error code = 2
         5         0        19  Error code = 3
         2         4         7  Error code = 4

diophantine_test
  Normal end of execution.

diophantine_solution_minimize_test
  Python version: 3.6.9
  diophantine_solution_minimize computes a minimal
  Euclidean norm solution of a Diophantine equation:
    A * X + B * Y = C

  Coefficients:
    A =         4096
    B =       -15625
    C =        46116
  Solution:
    X =    665499996
    Y =    174456828
  Residual R = A * X + B * Y - C:
    R =            0

  The minimized solution:
    X =           -4
    Y =           -4
  Residual R = A * X + B * Y - C:
    R =            0

  The minimal positive solution:
    X =        15621
    Y =         4092
  Residual R = A * X + B * Y - C:
    R =            0

diophantine_solution_minimize_test
  Normal end of execution.

dvec_add_test
  Python version: 3.6.9
  dvec_add adds decimal vectors representing integers

        I        J        K = I + J


        -5       -22
  Directly:                -27
  dvec_add       -27

        79        73
  Directly:                152
  dvec_add       152

       -99        66
  Directly:                -33
  dvec_add       -33

       -79       -32
  Directly:               -111
  dvec_add      -111

       -30       -41
  Directly:                -71
  dvec_add       -71

       -12        -1
  Directly:                -13
  dvec_add       -13

        54       -90
  Directly:                -36
  dvec_add       -36

       -93       -51
  Directly:               -144
  dvec_add      -144

        94        70
  Directly:                164
  dvec_add       164

       -10        14
  Directly:                  4
  dvec_add         4

dvec_add_test
  Normal end of execution.

dvec_complementx_test
  Python version: 3.6.9
  dvec_complementx returns the ten's complement
  of a (signed) decimal vector;

  I =       82
  J =      -82
+000000082
-999999918

  I =       -5
  J =        5
-999999995
+000000005

  I =       64
  J =      -64
+000000064
-999999936

  I =       -7
  J =        7
-999999993
+000000007

  I =       -6
  J =        6
-999999994
+000000006

dvec_complementx_test:
  Normal end of execution.

dvec_mul_test
  Python version: 3.6.9
  dvec_mul multiplies decimal vectors
  representing integers;

        I        J        K = I * J

        87       459
  Directly:              39933
  dvec_mul               39933


       344       826
  Directly:             284144
  dvec_mul              284144


       937      -404
  Directly:            -378548
  dvec_mul             -378548


      -269       103
  Directly:             -27707
  dvec_mul              -27707


      -482       297
  Directly:            -143154
  dvec_mul             -143154


        -4       -97
  Directly:                388
  dvec_mul                 388


      -401       610
  Directly:            -244610
  dvec_mul             -244610


       701       735
  Directly:             515235
  dvec_mul              515235


      -515       629
  Directly:            -323935
  dvec_mul             -323935


      -933       461
  Directly:            -430113
  dvec_mul             -430113


  NOW REPEAT THE TEST...

  but use too few digits to represent big products.
  This corresponds to an "overflow".
  The result here should get the final decimal
  digits correctly, though.

        I        J        K = I * J

       340       -46
  Directly:             -15640
  dvec_mul              -15640


      -346        33
  Directly:             -11418
  dvec_mul              -11418


      -543       -78
  Directly:              42354
  dvec_mul               42354


      -959      -260
  Directly:             249340
  dvec_mul               49340


       522       897
  Directly:             468234
  dvec_mul               68234


      -794       129
  Directly:            -102426
  dvec_mul               -2426


       426       554
  Directly:             236004
  dvec_mul               36004


       603      -926
  Directly:            -558378
  dvec_mul              -58378


      -416       249
  Directly:            -103584
  dvec_mul               -3584


      -668      -608
  Directly:             406144
  dvec_mul                6144


dvec_mul_test
  Normal end of execution.

dvec_print_test
  Python version: 3.6.9
  dvec_print prints a (signed) decimal vector;

  The DVEC:

-0055771439876543210

dvec_print_test:
  Normal end of execution.

dvec_sub_test
  Python version: 3.6.9
  dvec_sub subtracts decimal vectors representing integers;

        I        J        L = I - J

        94        24
  Directly:                 70
  dvec_sub        70

        36       -29
  Directly:                 65
  dvec_sub        65

       -33       -90
  Directly:                 57
  dvec_sub        57

         7        40
  Directly:                -33
  dvec_sub       -33

       -29       -12
  Directly:                -17
  dvec_sub       -17

        47       -25
  Directly:                 72
  dvec_sub        72

        18       -75
  Directly:                 93
  dvec_sub        93

        38       -54
  Directly:                 92
  dvec_sub        92

        75        12
  Directly:                 63
  dvec_sub        63

       -91        95
  Directly:               -186
  dvec_sub      -186

dvec_sub_test
  Normal end of execution.

dvec_to_i4_test
  Python version: 3.6.9
  dvec_to_i4 converts a DVEC to an I4.

        I4 => DVEC => I4

   -6799  
 9
 9
 3
 2
 0
 1
   -6799

dvec_to_i4_test:
  Normal end of execution.

equiv_print_test
  Python version: 3.6.9
  equiv_print prints a set partition.

  The partition:

   Set  Size
     1     2 :: 
   2
   3

     2     2 :: 
   0
   1


  The partition:

   Set  Size
     1     2 :: 
   0
   1

     2     2 :: 
   2
   3


  The partition:

   Set  Size
     1     1 :: 
   0

     2     3 :: 
   1
   2
   3


  The partition:

   Set  Size
     1     2 :: 
   1
   3

     2     1 :: 
   2

     3     1 :: 
   0


  The partition:

   Set  Size
     1     2 :: 
   0
   1

     2     1 :: 
   2

     3     1 :: 
   3


equiv_print_test
  Normal end of execution.

equiv_print2_test
  Python version: 3.6.9
  equiv_print2 prints a set partition.

  The partition:

subset 1: (
0
,
1
,
2
,
3
)

  The partition:

subset 1: (
0
,
3
)
subset 2: (
1
,
2
)

  The partition:

subset 1: (
0
,
1
)
subset 2: (
2
,
3
)

  The partition:

subset 1: (
0
,
1
,
3
)
subset 2: (
2
)

  The partition:

subset 1: (
2
)
subset 2: (
1
,
3
)
subset 3: (
0
)

equiv_print2_test
  Normal end of execution.

equiv0_next_test
  Python version: 3.6.9
  equiv0_next generates all partitions of a set.

               0     1     2     3

   1   1:      0     0     0     0
   2   2:      0     0     0     1
   3   2:      0     0     1     0
   4   2:      0     0     1     1
   5   3:      0     0     1     2
   6   2:      0     1     0     0
   7   2:      0     1     0     1
   8   3:      0     1     0     2
   9   2:      0     1     1     0
  10   2:      0     1     1     1
  11   3:      0     1     1     2
  12   3:      0     1     2     0
  13   3:      0     1     2     1
  14   3:      0     1     2     2
  15   4:      0     1     2     3

equiv0_next_test
  Normal end of execution.

equiv0_random_test
  Python version: 3.6.9
  equiv0_random selects a random set partition.

  The partition:

subset 1: (
0
,
2
,
3
)
subset 2: (
1
)

  The partition:

subset 1: (
0
,
1
,
2
,
3
)

  The partition:

subset 1: (
0
,
1
)
subset 2: (
3
)
subset 3: (
2
)

  The partition:

subset 1: (
0
,
1
)
subset 2: (
2
,
3
)

  The partition:

subset 1: (
2
,
3
)
subset 2: (
0
,
1
)

equiv0_random_test
  Normal end of execution.

equiv1_next_test
  Python version: 3.6.9
  equiv1_next generates all partitions of a set.

               0     1     2     3

   1   1:      1     1     1     1
   2   2:      1     1     1     2
   3   2:      1     1     2     1
   4   2:      1     1     2     2
   5   3:      1     1     2     3
   6   2:      1     2     1     1
   7   2:      1     2     1     2
   8   3:      1     2     1     3
   9   2:      1     2     2     1
  10   2:      1     2     2     2
  11   3:      1     2     2     3
  12   3:      1     2     3     1
  13   3:      1     2     3     2
  14   3:      1     2     3     3
  15   4:      1     2     3     4

equiv1_next_test
  Normal end of execution.

equiv1_next2_test
  Python version: 3.6.9
  equiv1_next2 generates all partitions of a set.
  Here, N = 4
 
      
     0
     1
     2
     3


   1: 
     1
     1
     1
     1

   2: 
     1
     1
     1
     2

   3: 
     1
     1
     2
     1

   4: 
     1
     1
     2
     2

   5: 
     1
     1
     2
     3

   6: 
     1
     2
     1
     1

   7: 
     1
     2
     1
     2

   8: 
     1
     2
     1
     3

   9: 
     1
     2
     2
     1

  10: 
     1
     2
     2
     2

  11: 
     1
     2
     2
     3

  12: 
     1
     2
     3
     1

  13: 
     1
     2
     3
     2

  14: 
     1
     2
     3
     3

  15: 
     1
     2
     3
     4


equiv1_next2_test
  Normal end of execution.

euler_row_test
  Python version: 3.6.9
  euler_row gets rows of Euler's triangle.

  1

  1
  0

  1
  1
  0

  1
  4
  1
  0

  1
  11
  11
  1
  0

  1
  26
  66
  26
  1
  0

  1
  57
  302
  302
  57
  1
  0

  1
  120
  1191
  2416
  1191
  120
  1
  0

  1
  247
  4293
  15619
  15619
  4293
  247
  1
  0

  1
  502
  14608
  88234
  156190
  88234
  14608
  502
  1
  0


euler_row_test
  Normal end of execution.

frobenius_number_order2_test
  Python version: 3.6.9
  frobenius_number_order2 computes Frobenius numbers of order 2.

        C1        C1   exact F  computed F

         2         5         3         3
         3        17        31        31
         4        19        53        53
         5        13        47        47
        12        11       109       109
        99       100      9701      9701

frobenius_number_order2_test:
  Normal end of execution.

frobenius_number_order2_values_test:
  Python version: 3.6.9
  frobenius_number_order2_values returns values of
  the Frobenius number of order 2.

         C1        C2          F(C1,C2)

         2         5         3
         3        17        31
         4        19        53
         5        13        47
        12        11       109
        99       100      9701

frobenius_number_order2_values_test:
  Normal end of execution.

gray_next_test
  Python version: 3.6.9
  gray_next returns the index of the single item
  to be changed in order to get the next Gray code.

   K  Change  Gray Code

   1       0  
0
0
0
0

   2       1  
1
0
0
0

   3       2  
1
1
0
0

   4      -1  
0
1
0
0

   5       3  
0
1
1
0

   6       1  
1
1
1
0

   7      -2  
1
0
1
0

   8      -1  
0
0
1
0

   9       4  
0
0
1
1

  10       1  
1
0
1
1

  11       2  
1
1
1
1

  12      -1  
0
1
1
1

  13      -3  
0
1
0
1

  14       1  
1
1
0
1

  15      -2  
1
0
0
1

  16      -1  
0
0
0
1


gray_next_test
  Normal end of execution.

gray_rank2_test
  Python version: 3.6.9
  gray_rank2 ranks a Gray code;

    R  =                         RANK
    G  =            gray_unrank2(RANK)
    R2 = gray_rank2(gray_unrank2(RANK))

       R       G       R2

       0       0       0
       1       1       1
       2       3       2
       3       2       3
       4       6       4
       5       7       5
       6       5       6
       7       4       7
       8      12       8
       9      13       9
      10      15      10
      11      14      11
      12      10      12
      13      11      13
      14       9      14
      15       8      15
      16      24      16
      17      25      17
      18      27      18
      19      26      19
      20      30      20
      21      31      21
      22      29      22
      23      28      23
      24      20      24

gray_rank2_test:
  Normal end of execution.

gray_unrank2_test
  Python version: 3.6.9
  gray_unrank2 unranks a Gray code.

    R  =                         RANK
    G  =            gray_unrank2(RANK)
    R2 = gray_rank2(gray_unrank2(RANK))

       R       G       R2

       0       0       0
       1       1       1
       2       3       2
       3       2       3
       4       6       4
       5       7       5
       6       5       6
       7       4       7
       8      12       8
       9      13       9
      10      15      10
      11      14      11
      12      10      12
      13      11      13
      14       9      14
      15       8      15
      16      24      16
      17      25      17
      18      27      18
      19      26      19
      20      30      20
      21      31      21
      22      29      22
      23      28      23
      24      20      24

gray_unrank2_test:
  Normal end of execution.

i4_bclr_test
  Python version: 3.6.9
  i4_bclr sets a given bit to 0.

  Working on I4 = 101

       Pos     i4_bclr(I4,Pos)

         0           100
         1           101
         2            97
         3           101
         4           101
         5            69
         6            37
         7           101
         8           101
         9           101
        10           101
        11           101
        12           101
        13           101
        14           101
        15           101
        16           101
        17           101
        18           101
        19           101
        20           101
        21           101
        22           101
        23           101
        24           101
        25           101
        26           101
        27           101
        28           101
        29           101
        30           101
        31           101

  Working on I4 = -31

       Pos     i4_bclr(I4,Pos)

         0           -32
         1           -31
         2           -31
         3           -31
         4           -31
         5           -63
         6           -95
         7          -159
         8          -287
         9          -543
        10         -1055
        11         -2079
        12         -4127
        13         -8223
        14        -16415
        15        -32799
        16        -65567
        17       -131103
        18       -262175
        19       -524319
        20      -1048607
        21      -2097183
        22      -4194335
        23      -8388639
        24     -16777247
        25     -33554463
        26     -67108895
        27    -134217759
        28    -268435487
        29    -536870943
        30   -1073741855
        31    2147483617

i4_bclr_test
  Normal end of execution.

i4_bset_test
  Python version: 3.6.9
  i4_bset sets a given bit to 1.

  Working on I4 = 101

       Pos     i4_bset(I4,Pos)

         0           101
         1           103
         2           101
         3           109
         4           117
         5           101
         6           101
         7           229
         8           357
         9           613
        10          1125
        11          2149
        12          4197
        13          8293
        14         16485
        15         32869
        16         65637
        17        131173
        18        262245
        19        524389
        20       1048677
        21       2097253
        22       4194405
        23       8388709
        24      16777317
        25      33554533
        26      67108965
        27     134217829
        28     268435557
        29     536871013
        30    1073741925
        31   -2147483547

  Working on I4 = -31

       Pos     i4_bset(I4,Pos)

         0           -31
         1           -29
         2           -27
         3           -23
         4           -15
         5           -31
         6           -31
         7           -31
         8           -31
         9           -31
        10           -31
        11           -31
        12           -31
        13           -31
        14           -31
        15           -31
        16           -31
        17           -31
        18           -31
        19           -31
        20           -31
        21           -31
        22           -31
        23           -31
        24           -31
        25           -31
        26           -31
        27           -31
        28           -31
        29           -31
        30           -31
        31           -31

i4_bset_test
  Normal end of execution.

i4_btest_test
  Python version: 3.6.9
  i4_btest reports whether a given bit is 0 or 1.

  Analyze the integer I4 = 101

       Pos     i4_btest(I4,POS)

             0             True
             1             False
             2             True
             3             False
             4             False
             5             True
             6             True
             7             False
             8             False
             9             False
            10             False
            11             False
            12             False
            13             False
            14             False
            15             False
            16             False
            17             False
            18             False
            19             False
            20             False
            21             False
            22             False
            23             False
            24             False
            25             False
            26             False
            27             False
            28             False
            29             False
            30             False
            31             False

  Analyze the integer I4 = -31

       Pos     i4_btest(I4,POS)

             0             True
             1             False
             2             False
             3             False
             4             False
             5             True
             6             True
             7             True
             8             True
             9             True
            10             True
            11             True
            12             True
            13             True
            14             True
            15             True
            16             True
            17             True
            18             True
            19             True
            20             True
            21             True
            22             True
            23             True
            24             True
            25             True
            26             True
            27             True
            28             True
            29             True
            30             True
            31             True

i4_btest_test
  Normal end of execution.

i4_factor_test
  Python version: 3.6.9
  i4_factor factors an integer.

  The integer is 2516

  Prime representation:

  I, FACTOR(I), POWER(I)

       0       2       2
       1      17       1
       2      37       1

i4_factor_test
  Normal end of execution.

i4_fall_test
  Python version: 3.6.9
  i4_fall evaluates the falling factorial Fall(I,N).

         M         N      Exact         i4_fall(M,N)

         5         0             1             1
         5         1             5             5
         5         2            20            20
         5         3            60            60
         5         4           120           120
         5         5           120           120
         5         6             0             0
        50         0             1             1
        10         1            10            10
      4000         1          4000          4000
        10         2            90            90
        18         3          4896          4896
         4         4            24            24
        98         3        912576        912576
         1         7             0             0

i4_fall_test:
  Normal end of execution.

i4_gcd_test
  Python version: 3.6.9
  i4_gcd computes the greatest common factor

     I     J   i4_gcd

      36      30       6
      49      -7       7
       0      71      71
      12      12      12
      36      49       1
       1      42       1
      91      28       7

i4_gcd_test
  Normal end of execution

i4_huge_test
  Python version: 3.6.9
  i4_huge returns a huge integer.

  i4_huge() = 2147483647

i4_huge_test
  Normal end of execution.

i4_log_10_test
  Python version: 3.6.9
  i4_log_10: whole part of log base 10,

  X, i4_log_10

     0             0
     1             0
     2             0
     3             0
     9             0
    10             1
    11             1
    99             1
   101             2
    -1             0
    -2             0
    -3             0
    -9             0

i4_log_10_test
  Normal end of execution.

i4_modp_test
  Python version: 3.6.9
  i4_modp factors a number
  into a multiple M and a positive remainder R.

    Number   Divisor  Multiple Remainder

       107        50         2         7
       107       -50        -2         7
      -107        50        -3        43
      -107       -50         3        43

  Repeat using Python % Operator:

       107        50         2         7
       107       -50        -3       -43
      -107        50        -3        43
      -107       -50         2        -7

i4_modp_test
  Normal end of execution.

i4_moebius_test:
  Python version: 3.6.9
  i4_moebius evaluates the Moebius function:

         N      Exact         i4_moebius(N)

         1             1             1
         2            -1            -1
         3            -1            -1
         4             0             0
         5            -1            -1
         6             1             1
         7            -1            -1
         8             0             0
         9             0             0
        10             1             1
        11            -1            -1
        12             0             0
        13            -1            -1
        14             1             1
        15             1             1
        16             0             0
        17            -1            -1
        18             0             0
        19            -1            -1
        20             0             0

i4_moebius_test
  Normal end of execution.

i4_partition_conj_test
  Python version: 3.6.9
  i4_partition_conj conjugates an integer partition.

  Original partition:

  14 =

1 * 2
+
1 * 5
+
3 * 1
+
1 * 4


  Conjugate partition:

  14 =

1 * 6
+
1 * 3
+
2 * 2
+
1 * 1


i4_partition_conj_test
  Normal end of execution.

i4_partition_count_test
  Python version: 3.6.9
  i4_partition_count counts partitions of an integer.

   N     Exact     Count

     0         1         1
     1         1         1
     2         2         2
     3         3         3
     4         5         5
     5         7         7
     6        11        11
     7        15        15
     8        22        22
     9        30        30
    10        42        42
    11        56        56
    12        77        77
    13       101       101
    14       135       135
    15       176       176
    16       231       231
    17       297       297
    18       385       385
    19       490       490
    20       627       627

i4_partition_count_test
  Normal end of execution.

i4_partition_count2_test
  Python version: 3.6.9
  i4_partition_count2 counts partitions of an integer.

   N     Exact     Count

     0         1         1
     1         1         1
     2         2         2
     3         3         3
     4         5         5
     5         7         7
     6        11        11
     7        15        15
     8        22        22
     9        30        30
    10        42        42
    11        56        56
    12        77        77
    13       101       101
    14       135       135
    15       176       176
    16       231       231
    17       297       297
    18       385       385
    19       490       490
    20       627       627

i4_partition_count2_test
  Normal end of execution.

i4_partition_count_values_test:
  Python version: 3.6.9
  i4_partition_count_values returns values of 
  the integer partition count function.

     N         P(N)

     0           1
     1           1
     2           2
     3           3
     4           5
     5           7
     6          11
     7          15
     8          22
     9          30
    10          42
    11          56
    12          77
    13         101
    14         135
    15         176
    16         231
    17         297
    18         385
    19         490
    20         627

i4_partition_count_values_test:
  Normal end of execution.

i4_partition_next_test
  Python version: 3.6.9
  i4_partition_next generates partitions of an integer.
  Here N = 7

  7 =

1 * 7

  7 =

1 * 6
+
1 * 1

  7 =

1 * 5
+
1 * 2

  7 =

1 * 5
+
2 * 1

  7 =

1 * 4
+
1 * 3

  7 =

1 * 4
+
1 * 2
+
1 * 1

  7 =

1 * 4
+
3 * 1

  7 =

2 * 3
+
1 * 1

  7 =

1 * 3
+
2 * 2

  7 =

1 * 3
+
1 * 2
+
2 * 1

  7 =

1 * 3
+
4 * 1

  7 =

3 * 2
+
1 * 1

  7 =

2 * 2
+
3 * 1

  7 =

1 * 2
+
5 * 1

  7 =

7 * 1


i4_partition_next_test
  Normal end of execution.

i4_partition_next2_test
  Python version: 3.6.9
  i4_partition_next2 produces partitions of an integer.

  7 =

1 * 7

  7 =

1 * 6
+
1 * 1

  7 =

1 * 5
+
1 * 2

  7 =

1 * 5
+
2 * 1

  7 =

1 * 4
+
1 * 3

  7 =

1 * 4
+
1 * 2
+
1 * 1

  7 =

1 * 4
+
3 * 1

  7 =

2 * 3
+
1 * 1

  7 =

1 * 3
+
2 * 2

  7 =

1 * 3
+
1 * 2
+
2 * 1

  7 =

1 * 3
+
4 * 1

  7 =

3 * 2
+
1 * 1

  7 =

2 * 2
+
3 * 1

  7 =

1 * 2
+
5 * 1

  7 =

7 * 1


i4_partition_next2_test
  Normal end of execution.

i4_partition_print_test
  Python version: 3.6.9
  i4_partition_print prints an integer partition.

  14 =

1 * 2
+
1 * 5
+
3 * 1
+
1 * 4


i4_partition_print_test
  Normal end of execution.

i4_partition_random_test
  Python version: 3.6.9
  i4_partition_random generates a random partition.


  The number of partitions of N

     N    Number of partitions

     0         1
     1         1
     2         2
     3         3
     4         5
     5         7
     6        11
     7        15

  8 =

2 * 1
+
2 * 3

  8 =

1 * 1
+
1 * 7

  8 =

1 * 1
+
1 * 3
+
1 * 4

  8 =

1 * 8

  8 =

1 * 1
+
1 * 7


i4_partition_random_test:
  Normal end of execution.

i4_partitions_next_test
  Python version: 3.6.9
  i4_partitions_next produces the next
  nondecreasing partitions of an integer, and
  if necessary, increments the integer to keep on going.

   I Sum    Partition

   0   0  
   0
   0
   0

   0   1  
   1
   0
   0

   1   2  
   2
   0
   0

   2   2  
   1
   1
   0

   3   3  
   3
   0
   0

   4   3  
   2
   1
   0

   5   3  
   1
   1
   1

   6   4  
   4
   0
   0

   7   4  
   3
   1
   0

   8   4  
   2
   2
   0

   9   4  
   2
   1
   1

  10   5  
   5
   0
   0

  11   5  
   4
   1
   0

  12   5  
   3
   2
   0

  13   5  
   3
   1
   1

  14   5  
   2
   2
   1


  You can start from any legal partition.
  Here, we restart at ( 2, 1, 0 ).

   I Sum    Partition

   0   3  
   2
   1
   0

   0   3  
   1
   1
   1

   1   4  
   4
   0
   0

   2   4  
   3
   1
   0

   3   4  
   2
   2
   0

   4   4  
   2
   1
   1

   5   5  
   5
   0
   0

   6   5  
   4
   1
   0

   7   5  
   3
   2
   0

   8   5  
   3
   1
   1

   9   5  
   2
   2
   1

  10   6  
   6
   0
   0

  11   6  
   5
   1
   0

  12   6  
   4
   2
   0

  13   6  
   3
   3
   0

  14   6  
   4
   1
   1


i4_partitions_next_test:
  Normal end of execution.

i4_rise_test
  Python version: 3.6.9
  i4_rise evaluates the rising factorial Fall(I,N).

         M         N      Exact         i4_rise(M,N)

         5         0             1             1
         5         1             5             5
         5         2            30            30
         5         3           210           210
         5         4          1680          1680
         5         5         15120         15120
         5         6        151200        151200
        50         0             1             1
        10         1            10            10
      4000         1          4000          4000
        10         2           110           110
        18         3          6840          6840
         4         4           840           840
        98         3        970200        970200
         1         7          5040          5040

i4_rise_test
  Normal end of execution.

i4_sign_test
  Python version: 3.6.9
  i4_sign returns the sign of an I4.

    I4  i4_sign(I4)

   -10           -1
    -7           -1
     0            1
     5            1
     9            1

i4_sign_test
  Normal end of execution.

i4_sqrt_test
  Python version: 3.6.9
  i4_sqrt computes the square root of an I4.

       N  Sqrt(N) Remainder

       -5        2        1
       -4        2        0
       -3        1        2
       -2        1        1
       -1        1        0
        0        0        0
        1        1        0
        2        1        1
        3        1        2
        4        2        0
        5        2        1
        6        2        2
        7        2        3
        8        2        4
        9        3        0
       10        3        1
       11        3        2
       12        3        3
       13        3        4
       14        3        5
       15        3        6
       16        4        0
       17        4        1
       18        4        2
       19        4        3
       20        4        4

i4_sqrt_test
  Normal end of execution.

i4_sqrt_cf_test
  Python version: 3.6.9
  i4_sqrt_cf computes the continued fraction form
  of the square root of an integer.

   N  Period  Whole  Repeating Part

    1       0      1

    2       1      1
    2

    3       2      1
    1
    2

    4       0      2

    5       1      2
    4

    6       2      2
    2
    4

    7       4      2
    1
    1
    1
    4

    8       2      2
    1
    4

    9       0      3

   10       1      3
    6

   11       2      3
    3
    6

   12       2      3
    2
    6

   13       5      3
    1
    1
    1
    1
    6

   14       4      3
    1
    2
    1
    6

   15       2      3
    1
    6

   16       0      4

   17       1      4
    8

   18       2      4
    4
    8

   19       6      4
    2
    1
    3
    1
    2
    8

   20       2      4
    2
    8


i4_sqrt_cf_test
  Normal end of execution.

i4_to_chinese_test
  Python version: 3.6.9
  i4_to_chinese computes the Chinese Remainder
  representation of an integer.

  The moduli:

     0       3
     1       4
     2       5
     3       7

  The number being analyzed is 37

  The remainders:

     0       1
     1       1
     2       2
     3       2

  The reconstructed number is 37

  The remainders of the reconstructed number are:

     0       1
     1       1
     2       2
     3       2

i4_to_chinese_test:
  Normal end of execution.

i4_to_dvec_test
  Python version: 3.6.9
  i4_to_dvec converts an I4 to a DVEC.

        I4 => DVEC => I4

   -3352  
 9
 9
 6
 6
 4
 8
   -3352

i4_to_dvec_test:
  Normal end of execution.

i4_to_i4poly_test
  Python version: 3.6.9
  i4_to_i4poly converts an integer to a polynomial
  in a given base

       I    BASE  DEGREE  Coefficients

       1       2       0
       1

       6       2       2
       1
       1
       0

      23       2       4
       1
       0
       1
       1
       1

      23       3       2
       2
       1
       2

      23       4       2
       1
       1
       3

      23       5       1
       4
       3

      23       6       1
       3
       5

      23      23       1
       1
       0

      23      24       0
      23


i4_to_i4poly_test
  Normal end of execution.

i4_to_van_der_corput_test
  Python version: 3.6.9
  i4_to_van_der_corput computes the elements
  of a van der Corput sequence.
  The sequence depends on the prime numbers used
  as a base.

  Bases:


             2
             3
             5
             7
            11


   0
      0.000000
      0.000000
      0.000000
      0.000000
      0.000000

   1
      0.500000
      0.333333
      0.200000
      0.142857
      0.090909

   2
      0.250000
      0.666667
      0.400000
      0.285714
      0.181818

   3
      0.750000
      0.111111
      0.600000
      0.428571
      0.272727

   4
      0.125000
      0.444444
      0.800000
      0.571429
      0.363636

   5
      0.625000
      0.777778
      0.040000
      0.714286
      0.454545

   6
      0.375000
      0.222222
      0.240000
      0.857143
      0.545455

   7
      0.875000
      0.555556
      0.440000
      0.020408
      0.636364

   8
      0.062500
      0.888889
      0.640000
      0.163265
      0.727273

   9
      0.562500
      0.037037
      0.840000
      0.306122
      0.818182


i4_to_van_der_corput_test
  Normal end of execution.

i4mat_mm_test
  Python version: 3.6.9
  i4mat_mm multiplies two I4MAT's

  Matrix A:

  Col:       0        1  
  Row
    0:      11       12  
    1:      21       22  
    2:      31       32  

  Matrix B:

  Col:       0        1        2        3  
  Row
    0:      11       12       13       14  
    1:      21       22       23       24  

  C = A*B:

  Col:       0        1        2        3  
  Row
    0:     373      396      419      442  
    1:     693      736      779      822  
    2:    1013     1076     1139     1202  

i4mat_mm_test:
  Normal end of execution.

i4mat_2perm0_test
  Python version: 3.6.9
  i4mat_2perm0 reorders an integer matrix in place.
  Rows and columns use different permutations.

  The input matrix:

  Col:       0        1        2        3        4        5        6  
  Row
    0:      11       12       13       14       15       16       17  
    1:      21       22       23       24       25       26       27  
    2:      31       32       33       34       35       36       37  
    3:      41       42       43       44       45       46       47  
    4:      51       52       53       54       55       56       57  
    5:      61       62       63       64       65       66       67  
    6:      71       72       73       74       75       76       77  
    7:      81       82       83       84       85       86       87  
    8:      91       92       93       94       95       96       97  

  The row permutation:

  
   0
   1
   2
   3
   4
   5
   6
   7
   8

  
   1
   2
   8
   5
   6
   7
   4
   3
   0


  The column permutation:

  
   0
   1
   2
   3
   4
   5
   6

  
   2
   3
   4
   5
   6
   0
   1


  The permuted matrix:

  Col:       0        1        2        3        4        5        6  
  Row
    0:      96       97       91       92       93       94       95  
    1:      16       17       11       12       13       14       15  
    2:      26       27       21       22       23       24       25  
    3:      86       87       81       82       83       84       85  
    4:      76       77       71       72       73       74       75  
    5:      46       47       41       42       43       44       45  
    6:      56       57       51       52       53       54       55  
    7:      66       67       61       62       63       64       65  
    8:      36       37       31       32       33       34       35  

i4mat_2perm0_test
  Normal end of execution.

i4mat_perm0_test
  Python version: 3.6.9
  i4mat_perm0 reorders an integer matrix in place.
  The rows and columns use the same permutation.

  The input matrix:

  Col:       0        1        2        3        4        5        6        7        8  
  Row
    0:      11       12       13       14       15       16       17       18       19  
    1:      21       22       23       24       25       26       27       28       29  
    2:      31       32       33       34       35       36       37       38       39  
    3:      41       42       43       44       45       46       47       48       49  
    4:      51       52       53       54       55       56       57       58       59  
    5:      61       62       63       64       65       66       67       68       69  
    6:      71       72       73       74       75       76       77       78       79  
    7:      81       82       83       84       85       86       87       88       89  
    8:      91       92       93       94       95       96       97       98       99  

  The row and column permutation:

  
   0
   1
   2
   3
   4
   5
   6
   7
   8

  
   1
   2
   8
   5
   6
   7
   4
   3
   0


  The permuted matrix:

  Col:       0        1        2        3        4        5        6        7        8  
  Row
    0:      99       91       92       98       97       94       95       96       93  
    1:      19       11       12       18       17       14       15       16       13  
    2:      29       21       22       28       27       24       25       26       23  
    3:      89       81       82       88       87       84       85       86       83  
    4:      79       71       72       78       77       74       75       76       73  
    5:      49       41       42       48       47       44       45       46       43  
    6:      59       51       52       58       57       54       55       56       53  
    7:      69       61       62       68       67       64       65       66       63  
    8:      39       31       32       38       37       34       35       36       33  

i4mat_perm0_test
  Normal end of execution.

i4mat_print_test:
  Python version: 3.6.9
  Test i4mat_print, which prints an I4MAT.

  A 5 x 6 integer matrix:

  Col:       0        1        2        3        4        5  
  Row
    0:      11       12       13       14       15       16  
    1:      21       22       23       24       25       26  
    2:      31       32       33       34       35       36  
    3:      41       42       43       44       45       46  
    4:      51       52       53       54       55       56  

i4mat_print_test:
  Normal end of execution.

i4mat_print_some_test
  Python version: 3.6.9
  i4mat_print_some prints some of an I4MAT.

  Here is I4MAT, rows 0:2, cols 3:5:

  Col:       3        4        5  
  Row
    0:      14       15       16  
    1:      24       25       26  
    2:      34       35       36  

i4mat_print_some_test:
  Normal end of execution.

i4mat_u1_inverse_test
  Python version: 3.6.9
  i4mat_u1_inverse inverts a unit upper triangular matrix.

  The original matrix:

  Col:       0        1        2        3        4        5  
  Row
    0:       1        2        0        5        0       75  
    1:       0        1        0        0        0        0  
    2:       0        0        1        3        0        0  
    3:       0        0        0        1        0        6  
    4:       0        0        0        0        1        4  
    5:       0        0        0        0        0        1  

  The inverse matrix:

  Col:       0        1        2        3        4        5  
  Row
    0:       1       -2        0       -5        0      -45  
    1:       0        1        0        0        0        0  
    2:       0        0        1       -3        0       18  
    3:       0        0        0        1        0       -6  
    4:       0        0        0        0        1       -4  
    5:       0        0        0        0        0        1  

  The product:

  Col:       0        1        2        3        4        5  
  Row
    0:       1        0        0        0        0        0  
    1:       0        1        0        0        0        0  
    2:       0        0        1        0        0        0  
    3:       0        0        0        1        0        0  
    4:       0        0        0        0        1        0  
    5:       0        0        0        0        0        1  

i4mat_u1_inverse_test:
  Normal end of execution.

i4poly_test
  Python version: 3.6.9
  i4poly() converts between power sum, factorial
  and Taylor forms, and can evaluate a polynomial


  All calls have input A as follows:
   0
   0
   0
   0
   0
   1


  Option IOPT = -3
  Output array:
   0
  24
  -50
  35
  -10
   1


  Option IOPT = -2
  Output array:
   0
   1
  15
  25
  10
   1


  Option IOPT = -1
  X0 = 2
  Value = 0

  Option IOPT = 0
  X0 = 2
  Value = 32

  Option IOPT = 6
  X0 = 2
  Output array:
  32
  80
  80
  40
  10
   1


  Option IOPT = 6
  X0 = -2
  Output array:
  -32
  80
  -80
  40
  -10
   1


i4poly_test:
  Normal end of execution.

i4poly_add_test
  Python version: 3.6.9
  i4poly_add adds two I4POLY's.

  Polynomial A:

 p(x) =  5 * x^5
        +4 * x^4
        +3 * x^3
        +2 * x^2
        +1 * x

  Polynomial B:

 p(x) = -5 * x^5
        +8 * x^3
        +7 * x^2
        -2 * x
        +1

  Polynomial C = A+B:

 p(x) =  4 * x^4
        +11 * x^3
        +9 * x^2
        -1 * x
        +1

i4poly_add_test:
  Normal end of execution.

i4poly_cyclo_test
  Python version: 3.6.9
  i4poly_cyclo computes cyclotomic polynomials.

  N = 0

  The cyclotomic polynomial:

 p(x) =  1

  N = 1

  The cyclotomic polynomial:

 p(x) =  1 * x
        -1

  N = 2

  The cyclotomic polynomial:

 p(x) =  1 * x
        +1

  N = 3

  The cyclotomic polynomial:

 p(x) =  1 * x^2
        +1 * x
        +1

  N = 4

  The cyclotomic polynomial:

 p(x) =  1 * x^2
        +1

  N = 5

  The cyclotomic polynomial:

 p(x) =  1 * x^4
        +1 * x^3
        +1 * x^2
        +1 * x
        +1

  N = 6

  The cyclotomic polynomial:

 p(x) =  1 * x^2
        -1 * x
        +1

  N = 7

  The cyclotomic polynomial:

 p(x) =  1 * x^6
        +1 * x^5
        +1 * x^4
        +1 * x^3
        +1 * x^2
        +1 * x
        +1

  N = 8

  The cyclotomic polynomial:

 p(x) =  1 * x^4
        +1

  N = 9

  The cyclotomic polynomial:

 p(x) =  1 * x^6
        +1 * x^3
        +1

  N = 10

  The cyclotomic polynomial:

 p(x) =  1 * x^4
        -1 * x^3
        +1 * x^2
        -1 * x
        +1

i4poly_cyclo_test
  Normal end of execution.

i4poly_degree_test
  Python version: 3.6.9
  i4poly_degree returns the degree of an I4POLY.

  The polynomial:

 p(x) =  7 * x^7
        +6 * x^6
        +4 * x^4
        +3 * x^3
        +1 * x

  The polynomial degree is 7

i4poly_degree_test:
  Normal end of execution.

i4poly_dif_test
  Python version: 3.6.9
  i4poly_dif computes derivatives of an I4POLY.

  The polynomial A:

 p(x) =  1 * x^3
        +2 * x^2
        -5 * x
        -6

  Differentiate A 1 times.

  The derivative, B:

 p(x) =  3 * x^2
        +4 * x
        -5

  The polynomial A:

 p(x) =  1 * x^4
        +3 * x^3
        +2 * x^2
        +5 * x
        -2

  Differentiate A 3 times.

  The derivative, B:

 p(x) =  24 * x
        +18

i4poly_dif_test:
  Normal end of execution.

i4poly_div_test
  Python version: 3.6.9
  i4poly_div computes the quotient and
  remainder for polynomial division.


  The polynomial to be divided, A:

 p(x) =  1 * x^3
        +2 * x^2
        -5 * x
        -6

  The divisor polynomial, B:

 p(x) =  1 * x
        -2

  The quotient polynomial, Q:

 p(x) =  1 * x^2
        +4 * x
        +3

  The remainder polynomial, R:

 p(x) =  0

  The polynomial to be divided, A:

 p(x) =  1 * x^4
        +3 * x^3
        +2 * x^2
        +5 * x
        -2

  The divisor polynomial, B:

 p(x) =  1 * x^2
        +1 * x
        -3

  The quotient polynomial, Q:

 p(x) =  1 * x^2
        +2 * x
        +3

  The remainder polynomial, R:

 p(x) =  8 * x
        +7

i4poly_div_test:
  Normal end of execution.

i4poly_mul_test
  Python version: 3.6.9
  i4poly_mul multiplies two polynomials.

  The factor A:

 p(x) =  1 * x
        +1

  The factor B:

 p(x) = -1 * x
        +1

  The product C = A*B:

 p(x) = -1 * x^2
        +1

  The factor A:

 p(x) =  3 * x^2
        +2 * x
        +1

  The factor B:

 p(x) = -2 * x
        +1

  The product C = A*B:

 p(x) = -6 * x^3
        -1 * x^2
        +1

i4poly_mul_test:
  Normal end of execution.

i4poly_print_test
  Python version: 3.6.9
  i4poly_print prints an I4POLY.

  The polynomial:

 p(x) =  1 * x^4
        +3 * x^3
        +2 * x^2
        +5 * x
        -2

i4poly_print_test
  Normal end of execution.

i4poly_to_i4_test
  Python version: 3.6.9
  i4poly_to_i4 evaluates an integer polynomial.

       I    BASE  DEGREE  Coefficients

       1       2       0
       1

       6       2       2
       1
       1
       0

      23       2       4
       1
       0
       1
       1
       1

      23       3       2
       2
       1
       2

      23       4       2
       1
       1
       3

      23       5       1
       4
       3

      23       6       1
       3
       5

      23      23       1
       1
       0

      23      24       0
      23


  Now let i4_to_i4poly convert I to a polynomial,
  use i4poly_to_i4 to evaluate it, and compare.

       I    I2

       1       1
       6       6
      23      23
      23      23
      23      23
      23      23
      23      23
      23      23
      23      23

i4poly_to_i4_test
  Normal end of execution.

i4vec_ascends_test
  Python version: 3.6.9
  i4vec_ascends determines if an I4VEC ascends.
  Test vector: 1 3 2 4
  i4vec_ascends = False
  Test vector: 2 2 2 2
  i4vec_ascends = True
  Test vector: 1 2 2 4
  i4vec_ascends = True
  Test vector: 1 2 3 4
  i4vec_ascends = True
  Test vector: 4 4 3 1
  i4vec_ascends = False
  Test vector: 9 7 3 0
  i4vec_ascends = False

i4vec_ascends_test
  Normal end of execution.

i4vec_backtrack_test
  Python version: 3.6.9
  i4vec_backtrack uses backtracking, seeking a vector X of
  N values which satisfies some condition.

  In this demonstration, we have 8 integers W(I).
  We seek all subsets that sum to 53.
  X(I) is 0 or 1 if the entry is skipped or used.

   1   
  53:  
  15
  22
  16

   2   
  53:  
  15
  14
  16
  8

   3   
  53:  
  22
  14
  9
  8


  Done!

i4vec_backtrack_test:
  Normal end of execution.

i4vec_decrement_test
  Python version: 3.6.9
  i4vec_decrement decrements an I4VEC.

  The I4VEC:

     0       5
     1      -3
     2       0
     3       8

  The I4VEC after decrementing:

     0       4
     1      -4
     2      -1
     3       7

i4vec_decrement_test:
  Normal end of execution.

i4vec_descends_test
  Python version: 3.6.9
  i4vec_descends determines if an I4VEC descends.
  Test vector: 1 3 2 4
  i4vec_descends = False
  Test vector: 2 2 2 2
  i4vec_descends = True
  Test vector: 1 2 2 4
  i4vec_descends = False
  Test vector: 1 2 3 4
  i4vec_descends = False
  Test vector: 4 4 3 1
  i4vec_descends = True
  Test vector: 9 7 3 0
  i4vec_descends = True

i4vec_descends_test
  Normal end of execution.

i4vec_frac_test
  Python version: 3.6.9
  i4vec_frac: K-th smallest integer vector entry.

  The array to search:

     0       8
     1       4
     2      15
     3       2
     4      10
     5      18
     6       6
     7      12
     8      20
     9      19

  Fractile    Value

       1       2
       4       8
       7      15
      10      20

i4vec_frac_test
  Normal end of execution.

i4vec_index_test
  Python version: 3.6.9
  For an integer vector:
  i4vec_index:              first index of given value;

  Input vector:

     0       4
     1      -8
     2      -1
     3       4
     4       8
     5      -8
     6      -9
     7       8
     8      -7
     9       9

  Index of first occurrence of -8 is 1
  Index of first occurrence of -7 is 8

i4vec_index_test:
  Normal end of execution.

i4vec_indicator0_test
  Python version: 3.6.9
  i4vec_indicator0 returns an indicator vector.

  The indicator0 vector:

     0       0
     1       1
     2       2
     3       3
     4       4
     5       5
     6       6
     7       7
     8       8
     9       9

i4vec_indicator0_test
  Normal end of execution.

i4vec_indicator1_test
  Python version: 3.6.9
  i4vec_indicator1 returns an indicator vector.

  The indicator1 vector:

     0       1
     1       2
     2       3
     3       4
     4       5
     5       6
     6       7
     7       8
     8       9
     9      10

i4vec_indicator1_test
  Normal end of execution.

i4vec_max_index_last_test
  Python version: 3.6.9
  i4vec_max_index_last:     last maximal index

  Input vector:

     0       3
     1       1
     2       3
     3       1
     4       3
     5       0
     6       1
     7       0
     8       2
     9       3
    10       3
    11       1
    12       3
    13       1
    14       1

  Last maximum index: 12

i4vec_max_index_last_test:
  Normal end of execution.

i4vec_pairwise_prime_test
  Python version: 3.6.9
  i4vec_pairwise_prime determines if a vector of
  integers is pairwise prime.

                          Pairwise
  Row Vector              Prime?

    1
    3
    2
    4
  False
    2
    2
    2
    2
  False
    5
    7
   12
   29
  True
    1
   13
    1
   11
  True
    1
    4
    9
   16
  False
    6
   35
   13
   77
  False

i4vec_pairwise_prime_test
  Normal end of execution.

i4vec_print_test
  Python version: 3.6.9
  i4vec_print prints an I4VEC.

  Here is an I4VEC:

     0      91
     1      92
     2      93
     3      94

i4vec_print_test:
  Normal end of execution.

i4vec_product_test
  Python version: 3.6.9
  i4vec_product computes the product of the entries in an I4VEC.

  Input vector:

     0       5
     1      -1
     2       5
     3      -1
     4       2
     5      -3
     6       3
     7       4
     8       4
     9      -3

  Product of entries = 21600

i4vec_product_test:
  Normal end of execution.

i4vec_reverse_test
  Python version: 3.6.9
  i4vec_reverse reverses a list of integers.

  Original vector:

     0      18
     1       8
     2       3
     3      29
     4       7
     5      20
     6       8
     7      25
     8      30
     9      24

  Reversed:

     0      24
     1      30
     2      25
     3       8
     4      20
     5       7
     6      29
     7       3
     8       8
     9      18

i4vec_reverse_test:
  Normal end of execution.

i4vec_sort_bubble_a_test
  Python version: 3.6.9
  i4vec_sort_bubble_a ascending sorts,

  Unsorted:

     0      29
     1      32
     2      40
     3       5
     4      45
     5       8
     6      14
     7      14
     8       5
     9      31
    10      17
    11       0
    12      38
    13       2
    14      20
    15      52
    16       5
    17      25
    18      27
    19      20

  Ascending sorted:

     0       0
     1       2
     2       5
     3       5
     4       5
     5       8
     6      14
     7      14
     8      17
     9      20
    10      20
    11      25
    12      27
    13      29
    14      31
    15      32
    16      38
    17      40
    18      45
    19      52

i4vec_sort_bubble_a_test:
  Normal end of execution.

i4vec_sort_heap_index_d_test
  Python version: 3.6.9
  i4vec_sort_heap_index_d creates a descending
  sort index for an I4VEC.

  Unsorted array A:

     0      40
     1      35
     2      12
     3      33
     4      26
     5      20
     6       1
     7      38
     8      12
     9      58
    10      50
    11      14
    12       1
    13      22
    14      12
    15      51
    16       4
    17      41
    18      34
    19      29

  Sort vector INDX:

     0       9
     1      15
     2      10
     3      17
     4       0
     5       7
     6       1
     7      18
     8       3
     9      19
    10       4
    11      13
    12       5
    13      11
    14      14
    15       2
    16       8
    17      16
    18       6
    19      12

       I   INDX(I)  A(INDX(I))

         0         9        58
         1        15        51
         2        10        50
         3        17        41
         4         0        40
         5         7        38
         6         1        35
         7        18        34
         8         3        33
         9        19        29
        10         4        26
        11        13        22
        12         5        20
        13        11        14
        14        14        12
        15         2        12
        16         8        12
        17        16         4
        18         6         1
        19        12         1

i4vec_sort_heap_index_d_test:
  Normal end of execution.

i4vec_transpose_print_test
  Python version: 3.6.9
  i4vec_transpose_print prints an I4VEC
  with 5 entries to a row, and an optional title.

  My array:   1 2 3 4 5 6 7 8 9 10 11 12

i4vec_transpose_print_test:
  Normal end of execution.

index_box_next_2d_test
  Python version: 3.6.9
  index_box_next_2d produces IJ indices that
  lie on the surface of a box in 2D.

  The box has logical dimensions:
    5 by   3

    #    I    J

    1    1    1
    2    1    2
    3    1    3
    4    2    1
    5    2    3
    6    3    1
    7    3    3
    8    4    1
    9    4    3
   10    5    1
   11    5    2
   12    5    3

index_box_next_2d_test:
  Normal end of execution.

index_box_next_3d_test
  Python version: 3.6.9
  index_box_next_3d produces IJK indices that
  lie on the surface of a box.

  The box has logical dimensions:
    5    3    4

   #    I   J   K

    1    1    1    1
    2    1    1    2
    3    1    1    3
    4    1    1    4
    5    1    2    1
    6    1    2    2
    7    1    2    3
    8    1    2    4
    9    1    3    1
   10    1    3    2
   11    1    3    3
   12    1    3    4
   13    2    1    1
   14    2    1    2
   15    2    1    3
   16    2    1    4
   17    2    2    1
   18    2    2    4
   19    2    3    1
   20    2    3    2
   21    2    3    3
   22    2    3    4
   23    3    1    1
   24    3    1    2
   25    3    1    3
   26    3    1    4
   27    3    2    1
   28    3    2    4
   29    3    3    1
   30    3    3    2
   31    3    3    3
   32    3    3    4
   33    4    1    1
   34    4    1    2
   35    4    1    3
   36    4    1    4
   37    4    2    1
   38    4    2    4
   39    4    3    1
   40    4    3    2
   41    4    3    3
   42    4    3    4
   43    5    1    1
   44    5    1    2
   45    5    1    3
   46    5    1    4
   47    5    2    1
   48    5    2    2
   49    5    2    3
   50    5    2    4
   51    5    3    1
   52    5    3    2
   53    5    3    3
   54    5    3    4

index_box_next_3d_test:
  Normal end of execution.

index_box2_next_2d_test
  Python version: 3.6.9
  index_box2_next_2d produces IJ indices that
  lie on the surface of a box2 in 2D.

  The box has half-widths:
    4    3

  and has center cell:
   10   20

   #    I   J

    1    6   17
    2    6   18
    3    6   19
    4    6   20
    5    6   21
    6    6   22
    7    6   23
    8    7   17
    9    7   23
   10    8   17
   11    8   23
   12    9   17
   13    9   23
   14   10   17
   15   10   23
   16   11   17
   17   11   23
   18   12   17
   19   12   23
   20   13   17
   21   13   23
   22   14   17
   23   14   18
   24   14   19
   25   14   20
   26   14   21
   27   14   22
   28   14   23

index_box2_next_2d_test:
  Normal end of execution.

index_box2_next_3d_test
  Python version: 3.6.9
  index_box2_next_3d produces IJK indices that
  lie on the surface of a box.

  The box has half widths:
    5    3    4

  and central cell:
   10   20   30

  We will only print a PORTION of the data!

   #    I   J   K

    1    5   17   26
    2    5   17   27
    3    5   17   28
    4    5   17   29
    5    5   17   30
    6    5   17   31
    7    5   17   32
    8    5   17   33
    9    5   17   34
   10    5   18   26
   11    5   18   27
   12    5   18   28
   13    5   18   29
   14    5   18   30
   15    5   18   31
   16    5   18   32
   17    5   18   33
   18    5   18   34
   19    5   19   26
   20    5   19   27
   21    5   19   28
   22    5   19   29
   23    5   19   30
   24    5   19   31
   25    5   19   32
   26    5   19   33
   27    5   19   34
   28    5   20   26
   29    5   20   27
   30    5   20   28
   31    5   20   29
   32    5   20   30
   33    5   20   31
   34    5   20   32
   35    5   20   33
   36    5   20   34
   37    5   21   26
   38    5   21   27
   39    5   21   28
   40    5   21   29
   41    5   21   30
   42    5   21   31
   43    5   21   32
   44    5   21   33
   45    5   21   34
   46    5   22   26
   47    5   22   27
   48    5   22   28
   49    5   22   29
   50    5   22   30
   51    5   22   31
   52    5   22   32
   53    5   22   33
   54    5   22   34
   55    5   23   26
   56    5   23   27
   57    5   23   28
   58    5   23   29
   59    5   23   30
   60    5   23   31
   61    5   23   32
   62    5   23   33
   63    5   23   34
   64    6   17   26
   65    6   17   27
   66    6   17   28
   67    6   17   29
   68    6   17   30
   69    6   17   31
   70    6   17   32
   71    6   17   33
   72    6   17   34
   73    6   18   26
   74    6   18   34
   75    6   19   26
   76    6   19   34
   77    6   20   26
   78    6   20   34
   79    6   21   26
   80    6   21   34
   81    6   22   26
   82    6   22   34
   83    6   23   26
   84    6   23   27
   85    6   23   28
   86    6   23   29
   87    6   23   30
   88    6   23   31
   89    6   23   32
   90    6   23   33
   91    6   23   34
   92    7   17   26
   93    7   17   27
   94    7   17   28
   95    7   17   29
   96    7   17   30
   97    7   17   31
   98    7   17   32
   99    7   17   33
  100    7   17   34
  101    7   18   26
  102    7   18   34
  103    7   19   26
  104    7   19   34
  105    7   20   26
  106    7   20   34
  107    7   21   26
  108    7   21   34
  109    7   22   26
  110    7   22   34
  111    7   23   26
  112    7   23   27
  113    7   23   28
  114    7   23   29
  115    7   23   30
  116    7   23   31
  117    7   23   32
  118    7   23   33
  119    7   23   34
  120    8   17   26
  121    8   17   27
  122    8   17   28
  123    8   17   29
  124    8   17   30
  125    8   17   31
  126    8   17   32
  127    8   17   33
  128    8   17   34
  129    8   18   26
  130    8   18   34
  131    8   19   26
  132    8   19   34
  133    8   20   26
  134    8   20   34
  135    8   21   26
  136    8   21   34
  137    8   22   26
  138    8   22   34
  139    8   23   26
  140    8   23   27
  141    8   23   28
  142    8   23   29
  143    8   23   30
  144    8   23   31
  145    8   23   32
  146    8   23   33
  147    8   23   34
  148    9   17   26
  149    9   17   27
  150    9   17   28
  151    9   17   29
  152    9   17   30
  153    9   17   31
  154    9   17   32
  155    9   17   33
  156    9   17   34
  157    9   18   26
  158    9   18   34
  159    9   19   26
  160    9   19   34
  161    9   20   26
  162    9   20   34
  163    9   21   26
  164    9   21   34
  165    9   22   26
  166    9   22   34
  167    9   23   26
  168    9   23   27
  169    9   23   28
  170    9   23   29
  171    9   23   30
  172    9   23   31
  173    9   23   32
  174    9   23   33
  175    9   23   34
  176   10   17   26
  177   10   17   27
  178   10   17   28
  179   10   17   29
  180   10   17   30
  181   10   17   31
  182   10   17   32
  183   10   17   33
  184   10   17   34
  185   10   18   26
  186   10   18   34
  187   10   19   26
  188   10   19   34
  189   10   20   26
  190   10   20   34
  191   10   21   26
  192   10   21   34
  193   10   22   26
  194   10   22   34
  195   10   23   26
  196   10   23   27
  197   10   23   28
  198   10   23   29
  199   10   23   30
  200   10   23   31
  201   10   23   32
  202   10   23   33
  203   10   23   34
  204   11   17   26
  205   11   17   27
  206   11   17   28
  207   11   17   29
  208   11   17   30
  209   11   17   31
  210   11   17   32
  211   11   17   33
  212   11   17   34
  213   11   18   26
  214   11   18   34
  215   11   19   26
  216   11   19   34
  217   11   20   26
  218   11   20   34
  219   11   21   26
  220   11   21   34
  221   11   22   26
  222   11   22   34
  223   11   23   26
  224   11   23   27
  225   11   23   28
  226   11   23   29
  227   11   23   30
  228   11   23   31
  229   11   23   32
  230   11   23   33
  231   11   23   34
  232   12   17   26
  233   12   17   27
  234   12   17   28
  235   12   17   29
  236   12   17   30
  237   12   17   31
  238   12   17   32
  239   12   17   33
  240   12   17   34
  241   12   18   26
  242   12   18   34
  243   12   19   26
  244   12   19   34
  245   12   20   26
  246   12   20   34
  247   12   21   26
  248   12   21   34
  249   12   22   26
  250   12   22   34
  251   12   23   26
  252   12   23   27
  253   12   23   28
  254   12   23   29
  255   12   23   30
  256   12   23   31
  257   12   23   32
  258   12   23   33
  259   12   23   34
  260   13   17   26
  261   13   17   27
  262   13   17   28
  263   13   17   29
  264   13   17   30
  265   13   17   31
  266   13   17   32
  267   13   17   33
  268   13   17   34
  269   13   18   26
  270   13   18   34
  271   13   19   26
  272   13   19   34
  273   13   20   26
  274   13   20   34
  275   13   21   26
  276   13   21   34
  277   13   22   26
  278   13   22   34
  279   13   23   26
  280   13   23   27
  281   13   23   28
  282   13   23   29
  283   13   23   30
  284   13   23   31
  285   13   23   32
  286   13   23   33
  287   13   23   34
  288   14   17   26
  289   14   17   27
  290   14   17   28
  291   14   17   29
  292   14   17   30
  293   14   17   31
  294   14   17   32
  295   14   17   33
  296   14   17   34
  297   14   18   26
  298   14   18   34
  299   14   19   26
  300   14   19   34
  301   14   20   26
  302   14   20   34
  303   14   21   26
  304   14   21   34
  305   14   22   26
  306   14   22   34
  307   14   23   26
  308   14   23   27
  309   14   23   28
  310   14   23   29
  311   14   23   30
  312   14   23   31
  313   14   23   32
  314   14   23   33
  315   14   23   34
  316   15   17   26
  317   15   17   27
  318   15   17   28
  319   15   17   29
  320   15   17   30
  321   15   17   31
  322   15   17   32
  323   15   17   33
  324   15   17   34
  325   15   18   26
  326   15   18   27
  327   15   18   28
  328   15   18   29
  329   15   18   30
  330   15   18   31
  331   15   18   32
  332   15   18   33
  333   15   18   34
  334   15   19   26
  335   15   19   27
  336   15   19   28
  337   15   19   29
  338   15   19   30
  339   15   19   31
  340   15   19   32
  341   15   19   33
  342   15   19   34
  343   15   20   26
  344   15   20   27
  345   15   20   28
  346   15   20   29
  347   15   20   30
  348   15   20   31
  349   15   20   32
  350   15   20   33
  351   15   20   34
  352   15   21   26
  353   15   21   27
  354   15   21   28
  355   15   21   29
  356   15   21   30
  357   15   21   31
  358   15   21   32
  359   15   21   33
  360   15   21   34
  361   15   22   26
  362   15   22   27
  363   15   22   28
  364   15   22   29
  365   15   22   30
  366   15   22   31
  367   15   22   32
  368   15   22   33
  369   15   22   34
  370   15   23   26
  371   15   23   27
  372   15   23   28
  373   15   23   29
  374   15   23   30
  375   15   23   31
  376   15   23   32
  377   15   23   33
  378   15   23   34

index_box2_next_3d_test:
  Normal end of execution.

index_next0_test
  Python version: 3.6.9
  index_next0 generates all indices of an
  array of given shape, with
  lower limit 1 and given upper limit.

  Number of index entries = 3
  Coordinate maximum HI =   3

  Index arrays:

   1
   1
   1

   2
   1
   1

   3
   1
   1

   1
   2
   1

   2
   2
   1

   3
   2
   1

   1
   3
   1

   2
   3
   1

   3
   3
   1

   1
   1
   2

   2
   1
   2

   3
   1
   2

   1
   2
   2

   2
   2
   2

   3
   2
   2

   1
   3
   2

   2
   3
   2

   3
   3
   2

   1
   1
   3

   2
   1
   3

   3
   1
   3

   1
   2
   3

   2
   2
   3

   3
   2
   3

   1
   3
   3

   2
   3
   3

   3
   3
   3


index_next0_test:
  Normal end of execution.

index_next1_test
  Python version: 3.6.9
  index_next1 generates all indices of an
  array of given shape, with
  lower limit 1 and given upper limits.

  Number of index entries = 3


  Coordinate maximum indices:

     0       4
     1       2
     2       3

  Index arrays:

   1
   1
   1

   2
   1
   1

   3
   1
   1

   4
   1
   1

   1
   2
   1

   2
   2
   1

   3
   2
   1

   4
   2
   1

   1
   1
   2

   2
   1
   2

   3
   1
   2

   4
   1
   2

   1
   2
   2

   2
   2
   2

   3
   2
   2

   4
   2
   2

   1
   1
   3

   2
   1
   3

   3
   1
   3

   4
   1
   3

   1
   2
   3

   2
   2
   3

   3
   2
   3

   4
   2
   3


index_next1_test:
  Normal end of execution.

index_next2_test
  index_next2 generates all indices of an
  array of given shape with given
  lower and upper limits.

  Number of index entries = 3

  Coordinate, Maximum Index

         0        10        11
         1        -5        -3
         2         0         1

  Index arrays:

  10
  -5
   0

  11
  -5
   0

  10
  -4
   0

  11
  -4
   0

  10
  -3
   0

  11
  -3
   0

  10
  -5
   1

  11
  -5
   1

  10
  -4
   1

  11
  -4
   1

  10
  -3
   1

  11
  -3
   1


index_next2_test:
  Normal end of execution.

index_rank0_test
  Python version: 3.6.9
  index_rank0 ranks an index with
  lower limit 1 and given upper limit.

  Number of index entries = 3
  Coordinate maximum index = 3

  The index array:

     0       3
     1       1
     2       2

  The rank of this object is 12

index_rank0_test:
  Normal end of execution.

index_rank1_test
  Python version: 3.6.9
  index_rank1 ranks an index with
  lower limit 1 and given upper limits.

  Number of index entries = 3

  Coordinate, Maximum Index

         0         4
         1         2
         2         3

  The index array:

     0       4
     1       1
     2       2

  The rank of this object is 12

index_rank1_test:
  Normal end of execution.

index_rank2_test
  Python version: 3.6.9
  index_rank2 ranks an index with given
  lower and upper limits.

  Number of index entries = 3

  Coordinate, Minimum index, Maximum Index

         0         1         2
         1        10        11
         2         4         6

  The index array:

     0       1
     1      11
     2       5

  The rank of this object is 7

index_rank2_test:
  Normal end of execution.

index_unrank0_test
  Python version: 3.6.9
  index_unrank0 unranks a multi-index.

  The multi-index has dimension 3

  The upper limit is HI = 3

  Rank, Multi-Index:

   1  
   1
   1
   1

   2  
   2
   1
   1

   3  
   3
   1
   1

   4  
   1
   2
   1

   5  
   2
   2
   1

   6  
   3
   2
   1

   7  
   1
   3
   1

   8  
   2
   3
   1

   9  
   3
   3
   1

  10  
   1
   1
   2

  11  
   2
   1
   2

  12  
   3
   1
   2

  13  
   1
   2
   2

  14  
   2
   2
   2

  15  
   3
   2
   2

  16  
   1
   3
   2

  17  
   2
   3
   2

  18  
   3
   3
   2

  19  
   1
   1
   3

  20  
   2
   1
   3

  21  
   3
   1
   3

  22  
   1
   2
   3

  23  
   2
   2
   3

  24  
   3
   2
   3

  25  
   1
   3
   3

  26  
   2
   3
   3

  27  
   3
   3
   3


index_unrank0_test:
  Normal end of execution.

index_unrank1_test
  Python version: 3.6.9
  index_unrank1 unranks a multi-index.

  The multi-index has dimension 3

  The upper limits:

     0       4
     1       2
     2       3

  Rank, Multi-Index:

   1  
   1
   1
   1

   2  
   2
   1
   1

   3  
   3
   1
   1

   4  
   4
   1
   1

   5  
   1
   2
   1

   6  
   2
   2
   1

   7  
   3
   2
   1

   8  
   4
   2
   1

   9  
   1
   1
   2

  10  
   2
   1
   2

  11  
   3
   1
   2

  12  
   4
   1
   2

  13  
   1
   2
   2

  14  
   2
   2
   2

  15  
   3
   2
   2

  16  
   4
   2
   2

  17  
   1
   1
   3

  18  
   2
   1
   3

  19  
   3
   1
   3

  20  
   4
   1
   3

  21  
   1
   2
   3

  22  
   2
   2
   3

  23  
   3
   2
   3

  24  
   4
   2
   3


index_unrank1_test:
  Normal end of execution.

index_unrank2_test
  Python version: 3.6.9
  index_unrank2 unranks a multi-index.

  The multi-index has dimension 3

  The lower and upper limits are:

         0         1         2
         1        10        11
         2         4         6

  Rank, Multi-Index:

   7
   1
  11
   5


index_unrank2_test:
  Normal end of execution.

inverse_mod_n_test
  Python version: 3.6.9
  inverse_mod_n seeks Y, the inverse of B mod N,
  so that mod ( B * Y, N ) = 1, but returns 0
  if the inverse does not exist.

     B     N     Y     Z = mod ( B * Y, N )


     1     2     1     1

     1     3     1     1
     2     3     2     1

     1     4     1     1
     2     4     0     0
     3     4     3     1

     1     5     1     1
     2     5     3     1
     3     5     2     1
     4     5     4     1

     1     6     1     1
     2     6     0     0
     3     6     0     0
     4     6     0     0
     5     6     5     1

     1     7     1     1
     2     7     4     1
     3     7     5     1
     4     7     2     1
     5     7     3     1
     6     7     6     1

     1     8     1     1
     2     8     0     0
     3     8     3     1
     4     8     0     0
     5     8     5     1
     6     8     0     0
     7     8     7     1

     1     9     1     1
     2     9     5     1
     3     9     0     0
     4     9     7     1
     5     9     2     1
     6     9     0     0
     7     9     4     1
     8     9     8     1

     1    10     1     1
     2    10     0     0
     3    10     7     1
     4    10     0     0
     5    10     0     0
     6    10     0     0
     7    10     3     1
     8    10     0     0
     9    10     9     1

inverse_mod_n_test
  Normal end of execution

inversion_to_perm0_test
  Python version: 3.6.9
  inversion_to_perm0: inversion => permutation (0,...,N-1).

  Permutation:

     0       2
     1       4
     2       0
     3       3
     4       1

  Inversion:

     0       0
     1       0
     2       2
     3       1
     4       3

  Recovered permutation:

     0       2
     1       4
     2       0
     3       3
     4       1

inversion_to_perm0_test:
  Normal end of execution.

involute_enum_test
  Python version: 3.6.9
  involute_enum counts involutions;

  N    # of involutions

         0         1
         1         1
         2         2
         3         4
         4        10
         5        26
         6        76
         7       232
         8       764
         9      2620
        10      9496

involute_enum_test:
  Normal end of execution.

jfrac_to_rfrac_test
  Python version: 3.6.9
  jfrac_to_rfrac converts a J fraction
  to a rational polynomial fraction.

  RFRAC P:

     0:      0.886407
     1:      0.147495
     2:      0.312649
     3:      0.987809
     4:      0.809327
     5:      0.774797

  RFRAC Q:

     0:      0.364993
     1:       0.22548
     2:      0.602574
     3:      0.762512
     4:      0.155225
     5:      0.827322
     6:             1

  JFRAC R:

     0:      0.774797
     1:     -0.892774
     2:       3.08635
     3:     -0.174335
     4:     -0.535162
     5:       2.28278

  JFRAC S:

     0:     -0.217245
     1:       1.75691
     2:     -0.843452
     3:     0.0665984
     4:       1.45632
     5:       -1.3918

  Recovered RFRAC P:

     0:      0.886407
     1:      0.147495
     2:      0.312649
     3:      0.987809
     4:      0.809327
     5:      0.774797

  Recovered RFRAC Q:

     0:      0.364993
     1:       0.22548
     2:      0.602574
     3:      0.762512
     4:      0.155225
     5:      0.827322
     6:             1

jfrac_to_rfrac_test:
  Normal end of execution.

josephus_test
  Python version: 3.6.9
  josephus solves Josephus problems.

     N     M     K     X

    41     3    41    31
    41   -38    41    31
    41     3    40    16
    64     2    64     1
  1000     2  1000   977

josephus_test
  Normal end of execution.

ksub_next_test
  Python version: 3.6.9
  ksub_next generates all K subsets of an N set
  in lexicographic order.

   1  
   1
   2
   3

   2  
   1
   2
   4

   3  
   1
   2
   5

   4  
   1
   3
   4

   5  
   1
   3
   5

   6  
   1
   4
   5

   7  
   2
   3
   4

   8  
   2
   3
   5

   9  
   2
   4
   5

  10  
   3
   4
   5


ksub_next_test:
  Normal end of execution.

ksub_next2_test
  Python version: 3.6.9
  ksub_next2 generates the next K subset of an
  N set by the revolving door method.

Rank         Subset      Add  Remove
          -----------

   1  
   1
   2
   3
     0
   0
   2  
   1
   3
   4
     4
   2
   3  
   2
   3
   4
     2
   1
   4  
   1
   2
   4
     1
   3
   5  
   1
   4
   5
     5
   2
   6  
   2
   4
   5
     2
   1
   7  
   3
   4
   5
     3
   2
   8  
   1
   3
   5
     1
   4
   9  
   2
   3
   5
     2
   1
  10  
   1
   2
   5
     1
   3

ksub_next2_test:
  Normal end of execution.

ksub_next3_test
  Python version: 3.6.9
  ksub_next3 generates all K subsets of an N set
  using the revolving door method.

Rank    Subset  Added Removed

   1
   1
   2
   3
     -1  -1
   2
   1
   3
   4
      4   2
   3
   2
   3
   4
      2   1
   4
   1
   2
   4
      1   3
   5
   1
   4
   5
      5   2
   6
   2
   4
   5
      2   1
   7
   3
   4
   5
      3   2
   8
   1
   3
   5
      1   4
   9
   2
   3
   5
      2   1
  10
   1
   2
   5
      1   3

ksub_next3_test:
  Normal end of execution.

ksub_next4_test
  Python version: 3.6.9
  ksub_next4() generates K subsets of an N set.
  N = 5
  K = 3

Rank    Subset

   1     1   2   3
   2     1   2   4
   3     1   3   4
   4     2   3   4
   5     1   2   5
   6     1   3   5
   7     2   3   5
   8     1   4   5
   9     2   4   5
  10     3   4   5

ksub_next4_test:
  Normal end of execution.
ksub_random_test skipped, ksub_random() is flawed.

ksub_random2_test
  Python version: 3.6.9
  ksub_random2 generates a random K subset of an N set.
  Set size is N =    5
  Subset size is K = 3

    1    2    4
    1    2    4
    2    4    5
    1    2    4
    1    2    5
    3    4    5
    2    3    4
    1    2    5
    1    2    3
    1    2    3

ksub_random2_test:
  Normal end of execution.

ksub_random3_test
  Python version: 3.6.9
  ksub_random3 generates a random K subset of an N set.
  Set size is N =    5
  Subset size is K = 3

    1
    1
    0
    1
    0

    1
    0
    0
    1
    1

    0
    1
    1
    0
    1

    1
    1
    1
    0
    0

    0
    1
    0
    1
    1

    0
    0
    1
    1
    1

    1
    1
    0
    0
    1

    1
    0
    1
    0
    1

    0
    0
    1
    1
    1

    1
    0
    1
    0
    1


ksub_random3_test:
  Normal end of execution.

ksub_random4_test
  Python version: 3.6.9
  ksub_random4 generates a random K subset of an N set.
  Set size is N =    100
  Subset size is K = 3

   64
   69
   92

   35
   51
   96

   41
    2
   59

   24
    5
   89

   48
   93
   97

   38
   71
   86

    5
   48
   87

   43
   31
   50

   41
   32
   55

   40
   74
   92


ksub_random4_test:
  Normal end of execution.

ksub_random5_test
  Python version: 3.6.9
  ksub_random5 generates a random K subset of an N set.
  Set size is N =    100
  Subset size is K = 3

    9
   31
   54

   14
   31
   47

   30
   80
   97

   37
   42
   84

    0
   84
   93

   49
   76
   85

    6
   27
   98

   69
   77
   85

   48
   65
   74

   44
   47
   90


ksub_random5_test:
  Normal end of execution.

ksub_rank_test
  Python version: 3.6.9
  ksub_rank: rank of a K subset of an N set.

  For N = 5
  and K = 3
  the subset is:
     1
     3
     5


  The rank is 6

ksub_rank_test:
  Normal end of execution.

ksub_to_comp_test
  Python version: 3.6.9
  ksub_to_comp returns the composition corresponding to a K subset.

  KSUB:
   2
   3
   6
   9

  COMP:
   1
   1
   3
   3
   5


  KSUB:
   2
  10
  11
  12

  COMP:
   1
   8
   1
   1
   2


  KSUB:
   2
   5
   6
   9

  COMP:
   1
   3
   1
   3
   5


  KSUB:
   1
   6
  10
  11

  COMP:
   0
   5
   4
   1
   3


  KSUB:
   4
   6
  12
  13

  COMP:
   3
   2
   6
   1
   1


ksub_to_comp_test:
  Normal end of execution.

ksub_to_compnz_test
  Python version: 3.6.9
  ksub_to_compnz returns the nonzero composition
  corresponding to a K subset.

  KSUB:  
   1
   3
   4
  10

  COMPNZ:
   1
   2
   1
   6
   5


  KSUB:  
   3
   4
   7
   9

  COMPNZ:
   3
   1
   3
   2
   6


  KSUB:  
   2
   6
   8
  14

  COMPNZ:
   2
   4
   2
   6
   1


  KSUB:  
   2
   5
   6
  11

  COMPNZ:
   2
   3
   1
   5
   4


  KSUB:  
   1
   3
  11
  13

  COMPNZ:
   1
   2
   8
   2
   2


ksub_to_compnz_test:
  Normal end of execution.

ksub_unrank_test
  Python version: 3.6.9
  ksub_unrank: find the K-subset of an N set
  of a given rank.

  N is 5
  K is 3
  and the desired rank is 8

  The subset of the given rank is:
   1
   4
   5


ksub_unrank_test:
  Normal end of execution.

l4vec_next_test
  Python version: 3.6.9
  l4vec_next generates logical vectors of dimension N one at a time.

  Vector size N = 2

   0:  
  False
  False

   1:  
  False
  True

   2:  
  True
  False

   3:  
  True
  True


  Vector size N = 3

   0:  
  False
  False
  False

   1:  
  False
  False
  True

   2:  
  False
  True
  False

   3:  
  False
  True
  True

   4:  
  True
  False
  False

   5:  
  True
  False
  True

   6:  
  True
  True
  False

   7:  
  True
  True
  True


l4vec_next_test:
  Normal end of execution.

moebius_values_test:
  Python version: 3.6.9
  moebius_values stores values of the MOEBIUS function.

             N    MOEBIUS(N)

             1             1
             2            -1
             3            -1
             4             0
             5            -1
             6             1
             7            -1
             8             0
             9             0
            10             1
            11            -1
            12             0
            13            -1
            14             1
            15             1
            16             0
            17            -1
            18             0
            19            -1
            20             0

moebius_values_test:
  Normal end of execution.

monomial_count_test
  Python version: 3.6.9
  monomial_count counts the number of monomials of
  degrees 0 through DEGREE_max in a space of dimension DIM.

  Using DEGREE_max = 9

  Dim  Count

   1        10
   2        55
   3       220
   4       715
   5      2002
   6      5005

monomial_count_test:
  Normal end of execution.

monomial_counts_test
  Python version: 3.6.9
  monomial_counts counts the number of monomials of
  degrees 0 through DEGREE_max in a space of dimension DIM.

  DIM = 1

         1         1
         2         1
         3         1
         4         1
         5         1
         6         1
         7         1
         8         1
         9         1
        10         1

     Total        10

  DIM = 2

         1         1
         2         2
         3         3
         4         4
         5         5
         6         6
         7         7
         8         8
         9         9
        10        10

     Total        55

  DIM = 3

         1         1
         2         3
         3         6
         4        10
         5        15
         6        21
         7        28
         8        36
         9        45
        10        55

     Total       220

  DIM = 4

         1         1
         2         4
         3        10
         4        20
         5        35
         6        56
         7        84
         8       120
         9       165
        10       220

     Total       715

  DIM = 5

         1         1
         2         5
         3        15
         4        35
         5        70
         6       126
         7       210
         8       330
         9       495
        10       715

     Total      2002

  DIM = 6

         1         1
         2         6
         3        21
         4        56
         5       126
         6       252
         7       462
         8       792
         9      1287
        10      2002

     Total      5005

monomial_counts_test:
  Normal end of execution.

morse_thue_test
  Python version: 3.6.9
  morse_thue computes the Morse-Thue numbers.

     0  0
     1  1
     2  1
     3  0
     4  1
     5  0
     6  0
     7  1
     8  1
     9  0
    10  0
    11  1
    12  0
    13  1
    14  1
    15  0
    16  1
    17  0
    18  0
    19  1
    20  0
    21  1
    22  1
    23  0
    24  0
    25  1
    26  1
    27  0
    28  1
    29  0
    30  0
    31  1
    32  1
    33  0
    34  0
    35  1
    36  0
    37  1
    38  1
    39  0
    40  0
    41  1
    42  1
    43  0
    44  1
    45  0
    46  0
    47  1
    48  0
    49  1
    50  1
    51  0
    52  1
    53  0
    54  0
    55  1
    56  1
    57  0
    58  0
    59  1
    60  0
    61  1
    62  1
    63  0
    64  1
    65  0
    66  0
    67  1
    68  0
    69  1
    70  1
    71  0
    72  0
    73  1
    74  1
    75  0
    76  1
    77  0
    78  0
    79  1
    80  0
    81  1
    82  1
    83  0
    84  1
    85  0
    86  0
    87  1
    88  1
    89  0
    90  0
    91  1
    92  0
    93  1
    94  1
    95  0
    96  0
    97  1
    98  1
    99  0
   100  1

morse_thue_test
  Normal end of execution.

multinomial_coef1_test
  Python version: 3.6.9
  multinomial_coef1 computes multinomial
  coefficients using the Gamma function

  Line 10 of the BINOMIAL table:

   0  10     1
   1   9    10
   2   8    45
   3   7   120
   4   6   210
   5   5   252
   6   4   210
   7   3   120
   8   2    45
   9   1    10
  10   0     1

  Level 5 of the TRINOMIAL coefficients:

   0   0   5     1
   0   1   4     5
   0   2   3    10
   0   3   2    10
   0   4   1     5
   0   5   0     1

   1   0   4     5
   1   1   3    20
   1   2   2    30
   1   3   1    20
   1   4   0     5

   2   0   3    10
   2   1   2    30
   2   2   1    30
   2   3   0    10

   3   0   2    10
   3   1   1    20
   3   2   0    10

   4   0   1     5
   4   1   0     5

   5   0   0     1

multinomial_coef1_test:
  Normal end of execution.

multinomial_coef2_test
  Python version: 3.6.9
  multinomial_coef2 computes multinomial
  coefficients directly.

  Line 10 of the BINOMIAL table:

   0  10     1
   1   9    10
   2   8    45
   3   7   120
   4   6   210
   5   5   252
   6   4   210
   7   3   120
   8   2    45
   9   1    10
  10   0     1

  Level 5 of the TRINOMIAL coefficients:

   0   0   5     1
   0   1   4     5
   0   2   3    10
   0   3   2    10
   0   4   1     5
   0   5   0     1

   1   0   4     5
   1   1   3    20
   1   2   2    30
   1   3   1    20
   1   4   0     5

   2   0   3    10
   2   1   2    30
   2   2   1    30
   2   3   0    10

   3   0   2    10
   3   1   1    20
   3   2   0    10

   4   0   1     5
   4   1   0     5

   5   0   0     1

multinomial_coef2_test:
  Normal end of execution.

multiperm_enum_test:
  Python version: 3.6.9
  multiperm_enum enumerates multipermutations.

  N is the number of objects to be permuted.
  K is the number of distinct types of objects.
  COUNTS is the number of objects of each type.
  NUMBER is the number of multipermutations.

  Number       N       K       Counts(1:K)

     120       5       5
     1
     1
     1
     1
     1

       1       5       1
     5

      60       5       4
     1
     2
     1
     1

      30       5       3
     1
     2
     2

     120       5       5
     1
     1
     1
     1
     1


multiperm_enum_test:
  Normal end of execution.

multiperm_next_test
  Python version: 3.6.9
  multiperm_next computes multipermutations in
  lexical order.

     1    
   1
   2
   2
   3
   3
   3

     2    
   1
   2
   3
   2
   3
   3

     3    
   1
   2
   3
   3
   2
   3

     4    
   1
   2
   3
   3
   3
   2

     5    
   1
   3
   2
   2
   3
   3

     6    
   1
   3
   2
   3
   2
   3

     7    
   1
   3
   2
   3
   3
   2

     8    
   1
   3
   3
   2
   2
   3

     9    
   1
   3
   3
   2
   3
   2

    10    
   1
   3
   3
   3
   2
   2

    11    
   2
   1
   2
   3
   3
   3

    12    
   2
   1
   3
   2
   3
   3

    13    
   2
   1
   3
   3
   2
   3

    14    
   2
   1
   3
   3
   3
   2

    15    
   2
   2
   1
   3
   3
   3

    16    
   2
   2
   3
   1
   3
   3

    17    
   2
   2
   3
   3
   1
   3

    18    
   2
   2
   3
   3
   3
   1

    19    
   2
   3
   1
   2
   3
   3

    20    
   2
   3
   1
   3
   2
   3

    21    
   2
   3
   1
   3
   3
   2

    22    
   2
   3
   2
   1
   3
   3

    23    
   2
   3
   2
   3
   1
   3

    24    
   2
   3
   2
   3
   3
   1

    25    
   2
   3
   3
   1
   2
   3

    26    
   2
   3
   3
   1
   3
   2

    27    
   2
   3
   3
   2
   1
   3

    28    
   2
   3
   3
   2
   3
   1

    29    
   2
   3
   3
   3
   1
   2

    30    
   2
   3
   3
   3
   2
   1

    31    
   3
   1
   2
   2
   3
   3

    32    
   3
   1
   2
   3
   2
   3

    33    
   3
   1
   2
   3
   3
   2

    34    
   3
   1
   3
   2
   2
   3

    35    
   3
   1
   3
   2
   3
   2

    36    
   3
   1
   3
   3
   2
   2

    37    
   3
   2
   1
   2
   3
   3

    38    
   3
   2
   1
   3
   2
   3

    39    
   3
   2
   1
   3
   3
   2

    40    
   3
   2
   2
   1
   3
   3

    41    
   3
   2
   2
   3
   1
   3

    42    
   3
   2
   2
   3
   3
   1

    43    
   3
   2
   3
   1
   2
   3

    44    
   3
   2
   3
   1
   3
   2

    45    
   3
   2
   3
   2
   1
   3

    46    
   3
   2
   3
   2
   3
   1

    47    
   3
   2
   3
   3
   1
   2

    48    
   3
   2
   3
   3
   2
   1

    49    
   3
   3
   1
   2
   2
   3

    50    
   3
   3
   1
   2
   3
   2

    51    
   3
   3
   1
   3
   2
   2

    52    
   3
   3
   2
   1
   2
   3

    53    
   3
   3
   2
   1
   3
   2

    54    
   3
   3
   2
   2
   1
   3

    55    
   3
   3
   2
   2
   3
   1

    56    
   3
   3
   2
   3
   1
   2

    57    
   3
   3
   2
   3
   2
   1

    58    
   3
   3
   3
   1
   2
   2

    59    
   3
   3
   3
   2
   1
   2

    60    
   3
   3
   3
   2
   2
   1


multiperm_next_test:
  Normal end of execution.

nim_sum_test
  Python version: 3.6.9
  nim_sum computes the Nim sum of two integers.

    I    J    Nim(I+J)


  I1, I2, I3 in decimal:

  704
  836
  388

  I1, I2, I3 in binary:

  
0
0
0
0
0
0
1
1
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

  
0
0
1
0
0
0
1
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

  
0
0
1
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0


  I1, I2, I3 in decimal:

  229
  141
  104

  I1, I2, I3 in binary:

  
1
0
1
0
0
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

  
1
0
1
1
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

  
0
0
0
1
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0


  I1, I2, I3 in decimal:

  164
  731
  639

  I1, I2, I3 in binary:

  
0
0
1
0
0
1
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

  
1
1
0
1
1
0
1
1
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

  
1
1
1
1
1
1
1
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0


  I1, I2, I3 in decimal:

  329
  310
  127

  I1, I2, I3 in binary:

  
1
0
0
1
0
0
1
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

  
0
1
1
0
1
1
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

  
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0


  I1, I2, I3 in decimal:

  795
  434
  681

  I1, I2, I3 in binary:

  
1
1
0
1
1
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

  
0
1
0
0
1
1
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0

  
1
0
0
1
0
1
0
1
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0


nim_sum_test:
  Normal end of execution.

padovan_test
  Python version: 3.6.9
  padovan computes the Padovan numbers.

  Initial Padovan sequence:

     0       1
     1       1
     2       1
     3       2
     4       2
     5       3
     6       4
     7       5
     8       7
     9       9

padovan_test:
  Normal end of execution.

pell_basic_test
  Python version: 3.6.9
  pell_basic solves the basic Pell equation.

        D        X        Y        R

        2        2        1        2
        3        2        1        1
        5        5        2        5
        6        5        2        1
        7        8        3        1
        8        3        1        1
       10       10        3       10
       11       10        3        1
       12        7        2        1
       13      379      105      316
       14       15        4        1
       15        4        1        1
       17       17        4       17
       18       17        4        1
       19      170       39        1
       20        9        2        1

pell_basic_test
  Normal end of execution.

pell_next_test
  Python version: 3.6.9
  pell_next computes the "next" solution of the Pell equation.

       D       X        Y         R

        2        2        1        2
                 6        4        4
        3        2        1        1
                 7        4        1
        5        5        2        5
                45       20       25
        6        5        2        1
                49       20        1
        7        8        3        1
               127       48        1
        8        3        1        1
                17        6        1
       10       10        3       10
               190       60      100
       11       10        3        1
               199       60        1
       12        7        2        1
                97       28        1
       13      379      105      316
            286966    79590    99856
       14       15        4        1
               449      120        1
       15        4        1        1
                31        8        1
       17       17        4       17
               561      136      289
       18       17        4        1
               577      136        1
       19      170       39        1
             57799    13260        1
       20        9        2        1
               161       36        1

pell_next_test
  Normal end of execution.

pent_enum_test
  Python version: 3.6.9
  pent_enum counts points in pentagons;

  N    Pent(N)

         0         0
         1         1
         2         5
         3        12
         4        22
         5        35
         6        51
         7        70
         8        92
         9       117
        10       145

pent_enum_test:
  Normal end of execution.

perm_ascend_test
  Python version: 3.6.9
  perm_ascend determines the length of the longest
  increasing subsequence in a permutation.

  The permutation:

  
   0
   1
   2
   3
   4
   5
   6
   7
   8

  
   1
   2
   8
   5
   6
   7
   4
   3
   0


  The longest increasing subsequence has length 5

  A longest increasing subsequence:

     0       1
     1       2
     2       5
     3       6
     4       7

perm_ascend_test
  Normal end of execution.

perm_fixed_enum_test
  Python version: 3.6.9
  perm_fixed_enum enumerates the permutations
  of N objects that leave M unchanged.

  For this test, N = 10

  M    F(N,M)

   0   1334961
   1   1334960
   2    667485
   3    222480
   4     55650
   5     11088
   6      1890
   7       240
   8        45
   9         0
  10         1

perm_fixed_enum_test:
  Normal end of execution.

perm0_break_count_test
  Python version: 3.6.9
  perm0_break_count counts the breaks in a permutation.

  The permutation:

  
   0
   1
   2
   3
   4
   5

  
   3
   4
   1
   0
   5
   2


  The number of breaks is 5

perm0_break_count_test:
  Normal end of execution.

perm0_check_test
  Python version: 3.6.9
  perm0_check checks a permutation of 0,...,N-1.
  Permutation 1: 5 2 3 4 1

perm0_check - Warning!
  Permutation is missing the value 0.
  Permutation 2: 4 1 3 0 2
  Permutation 3: 0 2 1 3 2

perm0_check - Warning!
  Permutation is missing the value 4.

perm0_check_test:
  Normal end of execution.

perm0_cycle_test
  Python version: 3.6.9
  perm0_cycle analyzes a permutation.

  The permutation:

  
   0
   1
   2
   3
   4
   5
   6
   7
   8

  
   1
   2
   8
   5
   6
   7
   4
   3
   0


  S    =   1
  NCYCLE = 3

  The permutation cycle tags:

  
   0
   1
   2
   3
   4
   5
   6
   7
   8

  
  -1
   1
   1
  -1
  -1
   1
   1
   1
   1


perm0_cycle_test:
  Normal end of execution.

perm0_distance_test
  Python version: 3.6.9
  perm0_distance computes the Ulam metric distance
  between two permutations.

  Permutation P1

  
   0
   1
   2
   3
   4
   5
   6
   7
   8
   9

  
   4
   1
   5
   0
   2
   8
   7
   3
   9
   6


  Permutation P2

  
   0
   1
   2
   3
   4
   5
   6
   7
   8
   9

  
   8
   9
   0
   7
   6
   4
   3
   5
   1
   2


  Permutation P3

  
   0
   1
   2
   3
   4
   5
   6
   7
   8
   9

  
   1
   2
   7
   9
   4
   8
   6
   3
   0
   5


  K(P1,P1) should be 0.

  K(P1,P1) = 0

  K(P1,P2) should equal K(P2,P1).

  K(P1,P2) = 7
  K(P2,P1) = 7

  K(P1,P3) <= K(P1,P2) + K(P2,P3).

  K(P1,P3) = 5
  K(P1,P2) = 7
  K(P2,P3) = 6
  K(P1,P2) + K(P2,P3) = 13

perm0_distance_test:
  Normal end of execution.

perm0_free_test
  Python version: 3.6.9
  perm0_free returns the unused values in a partial permutation.
  Partial permutation: 4
  Values not yet used: 0 1 2 3
  Partial permutation: 4 1
  Values not yet used: 0 2 3
  Partial permutation: 4 1 2
  Values not yet used: 0 3
  Partial permutation: 4 1 2 3
  Values not yet used: 0
  Partial permutation: 4 1 2 3 0
  Values not yet used:(empty vector)

perm0_free_test:
  Normal end of execution.

perm0_inverse_test
  Python version: 3.6.9
  perm0_inverse inverts a permutation of (0,...,N-1)

  The original permutation:

  
   0
   1
   2
   3
   4
   5
   6

  
   3
   2
   4
   0
   6
   5
   1


  The inverted permutation:

  
   0
   1
   2
   3
   4
   5
   6

  
   3
   6
   1
   0
   2
   5
   4


perm0_inverse_test:
  Normal end of execution.

perm0_inverse2_test
  Python version: 3.6.9
  perm0_inverse2 inverts a permutation in place.

  The original permutation:

  
   0
   1
   2
   3
   4
   5
   6

  
   3
   2
   4
   0
   6
   5
   1


  The inverted permutation:

  
   0
   1
   2
   3
   4
   5
   6

  
   3
   6
   1
   0
   2
   5
   4


perm0_inverse2_test:
  Normal end of execution.

perm0_inverse3_test
  Python version: 3.6.9
  perm0_inverse3 inverts a permutation.

  The original permutation:

  
   0
   1
   2
   3
   4
   5
   6

  
   3
   2
   4
   0
   6
   5
   1


  The inverted permutation:

  
   0
   1
   2
   3
   4
   5
   6

  
   3
   6
   1
   0
   2
   5
   4


perm0_inverse3_test:
  Normal end of execution.

perm0_lex_next_test
  Python version: 3.6.9
  perm0_lex_next generates permutations in order.

  
   0
   1
   2
   3

  
   0
   1
   3
   2

  
   0
   2
   1
   3

  
   0
   2
   3
   1

  
   0
   3
   1
   2

  
   0
   3
   2
   1

  
   1
   0
   2
   3

  
   1
   0
   3
   2

  
   1
   2
   0
   3

  
   1
   2
   3
   0

  
   1
   3
   0
   2

  
   1
   3
   2
   0

  
   2
   0
   1
   3

  
   2
   0
   3
   1

  
   2
   1
   0
   3

  
   2
   1
   3
   0

  
   2
   3
   0
   1

  
   2
   3
   1
   0

  
   3
   0
   1
   2

  
   3
   0
   2
   1

  
   3
   1
   0
   2

  
   3
   1
   2
   0

  
   3
   2
   0
   1

  
   3
   2
   1
   0


perm0_lex_next_test
  Normal end of execution.

perm0_mul_test
  Python version: 3.6.9
  perm0_mul multiplies two permutations.

  Permutation P1:

  
   0
   1
   2
   3
   4

  
   2
   4
   0
   1
   3


  Permutation P2:

  
   0
   1
   2
   3
   4

  
   1
   2
   0
   3
   4


  Product permutation:

  
   0
   1
   2
   3
   4

  
   0
   4
   1
   2
   3


perm0_mul_test:
  Normal end of execution.

perm0_next_test
  Python version: 3.6.9
  perm0_next generates permutations.

  
   0
   1
   2
   3

  
   1
   0
   2
   3

  
   2
   0
   1
   3

  
   0
   2
   1
   3

  
   1
   2
   0
   3

  
   2
   1
   0
   3

  
   3
   1
   0
   2

  
   1
   3
   0
   2

  
   0
   3
   1
   2

  
   3
   0
   1
   2

  
   1
   0
   3
   2

  
   0
   1
   3
   2

  
   0
   2
   3
   1

  
   2
   0
   3
   1

  
   3
   0
   2
   1

  
   0
   3
   2
   1

  
   2
   3
   0
   1

  
   3
   2
   0
   1

  
   3
   2
   1
   0

  
   2
   3
   1
   0

  
   1
   3
   2
   0

  
   3
   1
   2
   0

  
   2
   1
   3
   0

  
   1
   2
   3
   0


perm0_next_test:
  Normal end of execution.

perm0_next3_test
  Python version: 3.6.9
  perm0_next3 generates permutations in order.

    1:   0   1   2   3
    2:   0   1   3   2
    3:   0   3   1   2
    4:   3   0   1   2
    5:   3   0   2   1
    6:   0   3   2   1
    7:   0   2   3   1
    8:   0   2   1   3
    9:   2   0   1   3
   10:   2   0   3   1
   11:   2   3   0   1
   12:   3   2   0   1
   13:   3   2   1   0
   14:   2   3   1   0
   15:   2   1   3   0
   16:   2   1   0   3
   17:   1   2   0   3
   18:   1   2   3   0
   19:   1   3   2   0
   20:   3   1   2   0
   21:   3   1   0   2
   22:   1   3   0   2
   23:   1   0   3   2
   24:   1   0   2   3

perm0_next3_test:
  Normal end of execution.

perm0_print_test
  Python version: 3.6.9
  perm0_print prints a permutation.

  A 0-based permutation:

  
   0
   1
   2
   3
   4
   5
   6

  
   6
   1
   3
   0
   4
   2
   5


perm0_print_test
  Normal end of execution.

perm0_random_test
  Python version: 3.6.9
  perm0_random randomly selects a 0-based permutation.

  
   6
   5
   7
   9
   1
   4
   0
   3
   2
   8

  
   4
   5
   6
   2
   9
   7
   1
   0
   3
   8

  
   7
   1
   5
   8
   4
   0
   2
   6
   9
   3

  
   4
   9
   6
   3
   5
   1
   7
   0
   2
   8

  
   9
   7
   0
   6
   3
   1
   4
   2
   8
   5


perm0_random_test
  Normal end of execution.

perm0_random2_test
  Python version: 3.6.9
  perm0_random2 randomly selects a 0-based permutation.

  
   7
   8
   2
   6
   5
   9
   4
   0
   3
   1

  
   8
   1
   2
   3
   5
   7
   0
   6
   9
   4

  
   9
   5
   2
   4
   6
   7
   1
   8
   3
   0

  
   6
   1
   7
   0
   8
   9
   3
   4
   5
   2

  
   2
   7
   0
   6
   3
   1
   5
   4
   8
   9


perm0_random2_test
  Normal end of execution.

perm0_rank_test
  Python version: 3.6.9
  perm0_rank ranks a permutation.

  The permutation:

  
   0
   1
   2
   3

  
   0
   3
   1
   2


  The rank is: 3

perm0_rank_test
  Normal end of execution.

perm0_sign_test
  Python version: 3.6.9
  perm0_sign computes the sign of a permutation of (0,...,N-1).

  RANK  SIGN  Permutation

   0     1  
   0
   1
   2
   3

   1    -1  
   0
   1
   3
   2

   2    -1  
   0
   2
   1
   3

   3     1  
   0
   2
   3
   1

   4     1  
   0
   3
   1
   2

   5    -1  
   0
   3
   2
   1

   6    -1  
   1
   0
   2
   3

   7     1  
   1
   0
   3
   2

   8     1  
   1
   2
   0
   3

   9    -1  
   1
   2
   3
   0

  10    -1  
   1
   3
   0
   2

  11     1  
   1
   3
   2
   0

  12     1  
   2
   0
   1
   3

  13    -1  
   2
   0
   3
   1

  14    -1  
   2
   1
   0
   3

  15     1  
   2
   1
   3
   0

  16     1  
   2
   3
   0
   1

  17    -1  
   2
   3
   1
   0

  18    -1  
   3
   0
   1
   2

  19     1  
   3
   0
   2
   1

  20     1  
   3
   1
   0
   2

  21    -1  
   3
   1
   2
   0

  22    -1  
   3
   2
   0
   1

  23     1  
   3
   2
   1
   0


perm0_sign_test
  Normal end of execution.

perm0_to_equiv_test
  Python version: 3.6.9
  perm0_to_equiv returns the set partition
  or equivalence classes determined by a
  permutation.

  The input permutation:

  
   0
   1
   2
   3
   4
   5
   6
   7
   8

  
   1
   2
   8
   5
   6
   7
   4
   3
   0


  The partition:

   Set  Size
     1     4 :: 
   0
   1
   2
   8

     2     3 :: 
   3
   5
   7

     3     2 :: 
   4
   6


perm0_to_equiv_test
  Normal end of execution

perm0_to_inversion_test
  Python version: 3.6.9
  perm0_to_inversion: permutation (0,...,N-1) => inversion.

  Permutation:

  
   0
   1
   2
   3
   4

  
   2
   4
   0
   3
   1


  Inversion:

     0       0
     1       0
     2       2
     3       1
     4       3

  Recovered permutation:

  
   0
   1
   2
   3
   4

  
   2
   4
   0
   3
   1


perm0_to_inversion_test:
  Normal end of execution.

perm0_to_ytb_test
  Python version: 3.6.9
  perm0_to_ytb converts a permutation to a
  Young tableau.

  The permutation

  
   0
   1
   2
   3
   4
   5
   6

  
   6
   1
   3
   0
   4
   2
   5


  The Young tableau
   1     3     5     6  
   2     4  
   7  

perm0_to_ytb_test:
  Normal end of execution.

perm0_unrank_test
  Python version: 3.6.9
  perm0_unrank, given a rank, computes the
  corresponding permutation.

  The requested rank is 6

  The permutation:

  
   0
   1
   2
   3

  
   0
   3
   2
   1


perm0_unrank_test
  Normal end of execution.

perm1_canon_to_cycle_test
  Python version: 3.6.9
  perm1_canon_to_cycle converts a permutation of (1,...,N) from
  canonical to cycle form.

  The permutation in canonical form:

  
   1
   2
   3
   4
   5
   6

  
   4
   5
   2
   1
   6
   3


  The permutation in cycle form:

  
   1
   2
   3
   4
   5
   6

  
  -4
   5
  -2
  -1
   6
   3


perm1_canon_to_cycle_test:
  Normal end of execution.

perm1_check_test
  Python version: 3.6.9
  perm1_check checks a permutation of 1,...,N.

  Permutation 1:

  
   1
   2
   3
   4
   5

  
   5
   2
   3
   4
   1


  Permutation 2:

  
   1
   2
   3
   4
   5

  
   4
   1
   3
   0
   2


perm1_check - Warning!
  Permutation is missing the value 5.

  Permutation 3:

  
   1
   2
   3
   4
   5

  
   0
   2
   1
   3
   2


perm1_check - Warning!
  Permutation is missing the value 4.

perm1_check_test:
  Normal end of execution.

perm1_cycle_to_canon_test
  Python version: 3.6.9
  perm1_cycle_to_canon converts a permutation of (1,...,N) from
  cycle to canonical form.

  The permutation in cycle form:

  
   1
   2
   3
   4
   5
   6

  
  -6
   3
   1
  -5
   4
  -2


  The permutation in canonical form:

  
   1
   2
   3
   4
   5
   6

  
   4
   5
   2
   1
   6
   3


perm1_cycle_to_canon_test
  Normal end of execution.

perm1_cycle_to_index_test
  Python version: 3.6.9
  perm1_cycle_to_index converts a permutation of (1,...,N) from
  cycle to standard index form.

  The standard index form permutation:

  
   1
   2
   3
   4
   5
   6
   7
   8
   9

  
   2
   3
   9
   6
   7
   8
   5
   4
   1


  The permutation in cycle form:

  
   1
   2
   3
   4
   5
   6
   7
   8
   9

  
  -1
   2
   3
   9
  -4
   6
   8
  -5
   7


  The standard index form permutation:

  
   1
   2
   3
   4
   5
   6
   7
   8
   9

  
   2
   3
   9
   6
   7
   8
   5
   4
   1


perm1_cycle_to_index_test
  Normal end of execution.

perm1_index_to_cycle_test
  Python version: 3.6.9
  perm1_index_to_cycle converts a permutation of (1,...,N) from
  standard index to cycle form.

  The standard index form permutation:

  
   1
   2
   3
   4
   5
   6
   7
   8
   9

  
   2
   3
   9
   6
   7
   8
   5
   4
   1


  The permutation in cycle form:

  
   1
   2
   3
   4
   5
   6
   7
   8
   9

  
  -1
   2
   3
   9
  -4
   6
   8
  -5
   7


  The standard index form permutation:

  
   1
   2
   3
   4
   5
   6
   7
   8
   9

  
   2
   3
   9
   6
   7
   8
   5
   4
   1


perm1_index_to_cycle_test
  Normal end of execution.

perm1_print_test
  Python version: 3.6.9
  perm1_print prints a permutation of (1,...,N).

  A 1-based permutation:

  
   1
   2
   3
   4
   5
   6
   7

  
   7
   2
   4
   1
   5
   3
   6


perm1_print_test
  Normal end of execution.

perrin_test
  Python version: 3.6.9
  perrin computes the Perrin numbers.

  The Perrin sequence:

     0       3
     1       0
     2       2
     3       3
     4       2
     5       5
     6       5
     7       7
     8      10
     9      12
    10      17
    11      22
    12      29
    13      39
    14      51
    15      68
    16      90
    17     119
    18     158
    19     209

perrin_test:
  Normal end of execution.

pord_check_test
  Python version: 3.6.9
  pord_check checks a partial ordering.

  The partial ordering matrix:

  Col:       0        1        2        3        4        5        6        7        8        9  
  Row
    0:       1        0        0        0        0        0        0        0        0        0  
    1:       0        1        0        1        0        1        0        1        0        0  
    2:       1        0        1        1        0        0        0        0        0        0  
    3:       0        0        0        1        0        0        0        0        0        0  
    4:       1        1        1        1        1        1        1        1        0        1  
    5:       0        0        0        1        0        1        0        1        0        0  
    6:       1        0        1        1        0        1        1        1        0        1  
    7:       0        0        0        1        0        0        0        1        0        0  
    8:       0        0        0        0        0        0        0        0        0        0  
    9:       1        0        1        1        0        0        0        1        0        1  

  CHECK FLAG = 0
  0 means no error.
  1 means illegal value of N.
  2 means some A(I,J) and A(J,I) are both nonzero.

pord_check_test:
  Normal end of execution.

power_mod_test
  Python version: 3.6.9
  power_mod computes the remainder of a power
  of an integer modulo another integer.

  A = 7
  N = 50
  M = 11
  mod ( A^N, M ) = 1

  A = 3
  N = 118
  M = 119
  mod ( A^N, M ) = 32

power_mod_test
  Normal end of execution.

power_series1_test
  Python version: 3.6.9
  power_series1 composes a power series

  Power series of G(x) = (1+F(x))^alpha

  N = 10
  ALPHA = 7

  Series for F(x):

             1
             0
             0
             0
             0

             0
             0
             0
             0
             0


  Series for G(x):

             7
            21
            35
            35
            21

             7
             1
             0
             0
             0


power_series1_test:
  Normal end of execution.

power_series2_test
  Python version: 3.6.9
  power_series2 composes a power series
  Here we compute the power series of G(x) = exp(F(x))-1
  The number of terms is N = 4

  Series for F(x):

     0:            -4
     1:             0
     2:             0
     3:             0

  Series for G(x):

     0:            -4
     1:             8
     2:      -10.6667
     3:       10.6667

power_series2_test:
  Normal end of execution.

power_series3_test
  Python version: 3.6.9
  power_series3 composes a power series

  Power series of H(x) = G(F(x))

  Number of terms, N = 4

  Series for F(x):

     0:             1
     1:             1
     2:             0
     3:             0

  Series for G(x):

     0:             1
     1:             1
     2:             0
     3:             0

  Series for H(x):

     0:             1
     1:             2
     2:             2
     3:             3

power_series3_test:
  Normal end of execution.

power_series4_test
  Python version: 3.6.9
  power_series4 composes a power series.
  Power series of H(x) = G(1/F(x))

  Number of terms N = 10

  Series for F(x):

     0:             1
     1:           0.5
     2:      0.333333
     3:          0.25
     4:           0.2
     5:      0.166667
     6:      0.142857
     7:         0.125
     8:      0.111111
     9:           0.1

  Series for G(x):

     0:             1
     1:             0
     2:             0
     3:             0
     4:             0
     5:             0
     6:             0
     7:             0
     8:             0
     9:             0

  Series for H(x):

     0:             1
     1:          -0.5
     2:      0.166667
     3:    -0.0416667
     4:    0.00833333
     5:   -0.00138889
     6:   0.000198413
     7:  -2.48016e-05
     8:   2.75573e-06
     9:  -2.75573e-07

power_series4_test:
  Normal end of execution.

prime_test
  Python version: 3.6.9
  prime returns primes from a table.

  Number of primes stored is 1600

     I    Prime(I)

       1       2
       2       3
       3       5
       4       7
       5      11
       6      13
       7      17
       8      19
       9      23
      10      29

    1590   13411
    1591   13417
    1592   13421
    1593   13441
    1594   13451
    1595   13457
    1596   13463
    1597   13469
    1598   13477
    1599   13487
    1600   13499

prime_test
  Normal end of execution.

pythag_triple_ijk_test
  Python version: 3.6.9
  pythag_triple_ijk computes a primitive Pythagorean triple
  by the i, j, k "coordinates".

   I   J   K   A   B   C  A^2+B^2   C^2

   0     0     0       3       4       5           25           25
   0     0     1       5      12      13          169          169
   0     0     2       7      24      25          625          625
   0     0     3       9      40      41         1681         1681
   0     1     0      15       8      17          289          289
   0     1     1      45      28      53         2809         2809
   0     1     2      91      60     109        11881        11881
   0     1     3     153     104     185        34225        34225
   0     2     0      35      12      37         1369         1369
   0     2     1     117      44     125        15625        15625
   0     2     2     247      96     265        70225        70225
   0     2     3     425     168     457       208849       208849
   0     3     0      63      16      65         4225         4225
   0     3     1     221      60     229        52441        52441
   0     3     2     475     132     493       243049       243049
   0     3     3     825     232     857       734449       734449
   1     0     0      21      20      29          841          841
   1     0     1      55      48      73         5329         5329
   1     0     2     105      88     137        18769        18769
   1     0     3     171     140     221        48841        48841
   1     1     0      65      72      97         9409         9409
   1     1     1     207     224     305        93025        93025
   1     1     2     429     460     629       395641       395641
   1     1     3     731     780    1069      1142761      1142761
   1     2     0     133     156     205        42025        42025
   1     2     1     455     528     697       485809       485809
   1     2     2     969    1120    1481      2193361      2193361
   1     2     3    1675    1932    2557      6538249      6538249
   1     3     0     225     272     353       124609       124609
   1     3     1     799     960    1249      1560001      1560001
   1     3     2    1725    2068    2693      7252249      7252249
   1     3     3    3003    3596    4685     21949225     21949225
   2     0     0     119     120     169        28561        28561
   2     0     1     297     304     425       180625       180625
   2     0     2     555     572     797       635209       635209
   2     0     3     893     924    1285      1651225      1651225
   2     1     0     403     396     565       319225       319225
   2     1     1    1265    1248    1777      3157729      3157729
   2     1     2    2607    2576    3665     13432225     13432225
   2     1     3    4429    4380    6229     38800441     38800441
   2     2     0     855     832    1193      1423249      1423249
   2     2     1    2905    2832    4057     16459249     16459249
   2     2     2    6171    6020    8621     74321641     74321641
   2     2     3   10653   10396   14885    221563225    221563225
   2     3     0    1475    1428    2053      4214809      4214809
   2     3     1    5217    5056    7265     52780225     52780225
   2     3     2   11247   10904   15665    245392225    245392225
   2     3     3   19565   18972   27253    742726009    742726009
   3     0     0     697     696     985       970225       970225
   3     0     1    1755    1748    2477      6135529      6135529
   3     0     2    3293    3276    4645     21576025     21576025
   3     0     3    5311    5280    7489     56085121     56085121
   3     1     0    2325    2332    3293     10843849     10843849
   3     1     1    7315    7332   10357    107267449    107267449
   3     1     2   15089   15120   21361    456292321    456292321
   3     1     3   25647   25696   36305   1318053025   1318053025
   3     2     0    4905    4928    6953     48344209     48344209
   3     2     1   16683   16756   23645    559086025    559086025
   3     2     2   35453   35604   50245   2524560025   2524560025
   3     2     3   61215   61472   86753   7526083009   7526083009
   3     3     0    8437    8484   11965    143161225    143161225
   3     3     1   29859   30020   42341   1792760281   1792760281
   3     3     2   64385   64728   91297   8335142209   8335142209
   3     3     3  112015  112608  158833  25227921889  25227921889

pythag_triple_next_test
  Python version: 3.6.9
  pythag_triple_next computes the "next"
    Pythagorean triple.

   I   J   A   B   C  A^2+B^2   C^2

   2     1     3     4     5        25        25
   3     2     5    12    13       169       169
   4     1    15     8    17       289       289
   4     3     7    24    25       625       625
   5     2    21    20    29       841       841
   5     4     9    40    41      1681      1681
   6     1    35    12    37      1369      1369
   6     3    27    36    45      2025      2025
   6     5    11    60    61      3721      3721
   7     2    45    28    53      2809      2809
   7     4    33    56    65      4225      4225
   7     6    13    84    85      7225      7225
   8     1    63    16    65      4225      4225
   8     3    55    48    73      5329      5329
   8     5    39    80    89      7921      7921
   8     7    15   112   113     12769     12769
   9     2    77    36    85      7225      7225
   9     4    65    72    97      9409      9409
   9     6    45   108   117     13689     13689
   9     8    17   144   145     21025     21025
  10     1    99    20   101     10201     10201

pythag_triple_next_test:
  Normal end of execution.

r8_agm_test:
  Python version: 3.6.9
  r8_agm computes the arithmetic geometric mean.

             X              Y              AGM           AGM
                                           Exact         Computed

       22.000000       96.000000         52.27464119870424         52.27464119870424
       83.000000       56.000000         68.83653005985852         68.83653005985852
       42.000000        7.000000         20.65930119673401         20.65930119673401
       26.000000       11.000000         17.69685487374365         17.69685487374367
        4.000000       63.000000          23.8670497217533          23.8670497217533
        6.000000       45.000000         20.71701598280599         20.71701598280599
       40.000000       75.000000         56.12784225561668         56.12784225561668
       80.000000        0.000000                         0                         0
       90.000000       35.000000         59.26956508122964         59.26956508122989
        9.000000        1.000000         3.936235503649555         3.936235503649556
       53.000000       53.000000                        53                        53
        1.000000        2.000000         1.456791031046907         1.456791031046907
        1.000000        4.000000         2.243028580287603         2.243028580287603
        1.000000        8.000000         3.615756177597363         3.615756177597363

r8_agm_test
  Normal end of execution.

r8_choose_test
  Python version: 3.6.9
  r8_choose evaluates C(N,K).

         N         K       CNK

         0         0               1

         1         0               1
         1         1               1

         2         0               1
         2         1               2
         2         2               1

         3         0               1
         3         1               3
         3         2               3
         3         3               1

         4         0               1
         4         1               4
         4         2               6
         4         3               4
         4         4               1

         5         0               1
         5         1               5
         5         2              10
         5         3              10
         5         4               5
         5         5               1

r8_choose_test
  Normal end of execution.

r8_fall_test
  Python version: 3.6.9
  r8_fall evaluates the falling factorial Fall(X,N).

      X        N                     Exact
                  Computed
         5     4                       120                       120
      5.25     4              163.16015625              163.16015625
       5.5     4                  216.5625                  216.5625
      5.75     4              281.66015625              281.66015625
         6     4                       360                       360
       7.5     0                         1                         1
       7.5     1                       7.5                       7.5
       7.5     2                     48.75                     48.75
       7.5     3                   268.125                   268.125
       7.5     4                 1206.5625                 1206.5625
       7.5     5                4222.96875                4222.96875
       7.5     6              10557.421875              10557.421875
       7.5     7             15836.1328125             15836.1328125
       7.5     8             7918.06640625             7918.06640625
       7.5     9           -3959.033203125           -3959.033203125

r8_fall_test
  Normal end of execution.

r8_fall_values_test:
  Python version: 3.6.9
  r8_fall_values returns values of the falling factorial.

          X         N          r8_fall(X,N)

    5.0000         4                       120
    5.2500         4              163.16015625
    5.5000         4                  216.5625
    5.7500         4              281.66015625
    6.0000         4                       360
    7.5000         0                         1
    7.5000         1                       7.5
    7.5000         2                     48.75
    7.5000         3                   268.125
    7.5000         4                 1206.5625
    7.5000         5                4222.96875
    7.5000         6              10557.421875
    7.5000         7             15836.1328125
    7.5000         8             7918.06640625
    7.5000         9           -3959.033203125

r8_fall_values_test:
  Normal end of execution.

r8_rise_test
  Python version: 3.6.9
  r8_rise evaluates the rising factorial Rise(X,N).

      X        N                     Exact                  Computed

         5     4                      1680                      1680
      5.25     4             1962.59765625             1962.59765625
       5.5     4                 2279.0625                 2279.0625
      5.75     4             2631.97265625             2631.97265625
         6     4                      3024                      3024
       7.5     0                         1                         1
       7.5     1                       7.5                       7.5
       7.5     2                     63.75                     63.75
       7.5     3                   605.625                   605.625
       7.5     4                 6359.0625                 6359.0625
       7.5     5               73129.21875               73129.21875
       7.5     6             914115.234375             914115.234375
       7.5     7          12340555.6640625          12340555.6640625
       7.5     8         178938057.1289063         178938057.1289062
       7.5     9         2773539885.498047         2773539885.498047

r8_rise_test
  Normal end of execution.

r8_rise_values_test:
  Python version: 3.6.9
  r8_rise_values returns values of the rising factorial.

          X         N          r8_rise(X,N)

    5.0000         4                      1680
    5.2500         4             1962.59765625
    5.5000         4                 2279.0625
    5.7500         4             2631.97265625
    6.0000         4                      3024
    7.5000         0                         1
    7.5000         1                       7.5
    7.5000         2                     63.75
    7.5000         3                   605.625
    7.5000         4                 6359.0625
    7.5000         5               73129.21875
    7.5000         6             914115.234375
    7.5000         7          12340555.6640625
    7.5000         8         178938057.1289063
    7.5000         9         2773539885.498047

r8_rise_values_test:
  Normal end of execution.

r8_to_cfrac_test
  Python version: 3.6.9
  r8_to_cfrac converts a real number to a sequence
  of continued fraction convergents.

  Use the real number R = 6.28319

       6       6       1      6.000000      0.283185
       3      19       3      6.333333     -0.050148
       1      25       4      6.250000      0.033185
       1      44       7      6.285714     -0.002529
       7     333      53      6.283019      0.000166
       2     710     113      6.283186     -0.000001
     146  103993   16551      6.283185      0.000000

r8_to_cfrac_test
  Normal end of execution.

r8_to_dec_test
  Python version: 3.6.9
  r8_to_dec converts a real number to a decimal

  The number of decimal digits is 5

     R   =>  A * 10^B  =>  R2

   -5.358518  -53585      -4   -5.358500
    5.683581   56835      -4    5.683500
    1.506281   15062      -4    1.506200
   -6.408752  -64087      -4   -6.408700
   -6.329552  -63295      -4   -6.329500
   -0.597003    -597      -3   -0.597000
    5.605706   56057      -4    5.605700
   -4.850446  -48504      -4   -4.850400
   -8.183502  -81835      -4   -8.183500
   -5.225820  -52258      -4   -5.225800

r8_to_rat_test
  Python version: 3.6.9
  r8_to_rat converts a real number to a rational

  The maximum number of digits allowed is 4

     R   =>  A / B  =>  R2

     2.64758    6619    2500      2.6476
     3.73263   18663    5000      3.7326
     1.76325    1102     625      1.7632
    0.506339    5063   10000      0.5063
    -2.26013  -22601   10000     -2.2601
    -0.28815   -1441    5000     -0.2882
    0.952046     119     125       0.952
     6.01258   30063    5000      6.0126
    -1.07156   -2679    2500     -1.0716
    -1.74322   -2179    1250     -1.7432

r8_to_rat_test
  Normal end of execution.

r8mat_det_test
  Python version: 3.6.9
  r8mat_det: determinant of a real matrix.

  The 123/456/789 matrix:

  Col:       0             1             2       
  Row
      0 :           1             2             3  
      1 :           4             5             6  
      2 :           7             8             9  

  Determinant of the 123/456/789 matrix is 0

  The Hilbert matrix:

  Col:       0             1             2             3       
  Row
      0 :         0.5      0.333333          0.25           0.2  
      1 :    0.333333          0.25           0.2      0.166667  
      2 :        0.25           0.2      0.166667      0.142857  
      3 :         0.2      0.166667      0.142857         0.125  

  Determinant of the Hilbert matrix is 2.36206e-09

  The -1,2,-1 matrix:

  Col:       0             1             2       
  Row
      0 :           2            -1             0  
      1 :          -1             2            -1  
      2 :           0            -1             2  

  Determinant of the -1,2,-1 matrix is 4

r8mat_det_test:
  Normal end of execution.

r8mat_2perm0_test
  Python version: 3.6.9
  r8mat_2perm0 reorders an R8MAT in place.
  Rows and columns use different permutations.

  The input matrix:

  Col:       0             1             2             3             4       
  Row
      0 :          11            12            13            14            15  
      1 :          21            22            23            24            25  
      2 :          31            32            33            34            35  
      3 :          41            42            43            44            45  
      4 :          51            52            53            54            55  
      5 :          61            62            63            64            65  
      6 :          71            72            73            74            75  
      7 :          81            82            83            84            85  
      8 :          91            92            93            94            95  

  Col:       5             6       
  Row
      0 :          16            17  
      1 :          26            27  
      2 :          36            37  
      3 :          46            47  
      4 :          56            57  
      5 :          66            67  
      6 :          76            77  
      7 :          86            87  
      8 :          96            97  

  The row permutation:

  
   0
   1
   2
   3
   4
   5
   6
   7
   8

  
   1
   2
   8
   5
   6
   7
   4
   3
   0


  The column permutation:

  
   0
   1
   2
   3
   4
   5
   6

  
   2
   3
   4
   5
   6
   0
   1


  The permuted matrix:

  Col:       0             1             2             3             4       
  Row
      0 :          96            97            91            92            93  
      1 :          16            17            11            12            13  
      2 :          26            27            21            22            23  
      3 :          86            87            81            82            83  
      4 :          76            77            71            72            73  
      5 :          46            47            41            42            43  
      6 :          56            57            51            52            53  
      7 :          66            67            61            62            63  
      8 :          36            37            31            32            33  

  Col:       5             6       
  Row
      0 :          94            95  
      1 :          14            15  
      2 :          24            25  
      3 :          84            85  
      4 :          74            75  
      5 :          44            45  
      6 :          54            55  
      7 :          64            65  
      8 :          34            35  

r8mat_2perm0_test
  Normal end of execution.

r8mat_perm0_test
  Python version: 3.6.9
  r8mat_perm0 reorders an integer matrix in place.
  The rows and columns use the same permutation.

  The input matrix:

  Col:       0             1             2             3             4       
  Row
      0 :          11            12            13            14            15  
      1 :          21            22            23            24            25  
      2 :          31            32            33            34            35  
      3 :          41            42            43            44            45  
      4 :          51            52            53            54            55  
      5 :          61            62            63            64            65  
      6 :          71            72            73            74            75  
      7 :          81            82            83            84            85  
      8 :          91            92            93            94            95  

  Col:       5             6             7             8       
  Row
      0 :          16            17            18            19  
      1 :          26            27            28            29  
      2 :          36            37            38            39  
      3 :          46            47            48            49  
      4 :          56            57            58            59  
      5 :          66            67            68            69  
      6 :          76            77            78            79  
      7 :          86            87            88            89  
      8 :          96            97            98            99  

  The row and column permutation:

  
   0
   1
   2
   3
   4
   5
   6
   7
   8

  
   1
   2
   8
   5
   6
   7
   4
   3
   0


  The permuted matrix:

  Col:       0             1             2             3             4       
  Row
      0 :          99            91            92            98            97  
      1 :          19            11            12            18            17  
      2 :          29            21            22            28            27  
      3 :          89            81            82            88            87  
      4 :          79            71            72            78            77  
      5 :          49            41            42            48            47  
      6 :          59            51            52            58            57  
      7 :          69            61            62            68            67  
      8 :          39            31            32            38            37  

  Col:       5             6             7             8       
  Row
      0 :          94            95            96            93  
      1 :          14            15            16            13  
      2 :          24            25            26            23  
      3 :          84            85            86            83  
      4 :          74            75            76            73  
      5 :          44            45            46            43  
      6 :          54            55            56            53  
      7 :          64            65            66            63  
      8 :          34            35            36            33  

r8mat_perm0_test
  Normal end of execution.

r8mat_permanent_test
  Python version: 3.6.9
  r8mat_permanent: the matrix permanent function.
  We will analyze matrices with 0 diagonal and
  1 on all offdiagonals.

  Order	    Permanent.

   2                   1
   3                   2
   4                   9
   5                  44
   6                 265
   7                1854
   8               14833
   9              133496
  10         1.33496e+06
  11         1.46846e+07
  12         1.76215e+08

r8mat_permanent_test:
  Normal end of execution.

r8mat_print_test
  Python version: 3.6.9
  r8mat_print prints an R8MAT.

  Here is an R8MAT:

  Col:       0             1             2             3             4       
  Row
      0 :          11            12            13            14            15  
      1 :          21            22            23            24            25  
      2 :          31            32            33            34            35  
      3 :          41            42            43            44            45  

  Col:       5       
  Row
      0 :          16  
      1 :          26  
      2 :          36  
      3 :          46  

r8mat_print_test:
  Normal end of execution.

r8mat_print_some_test
  Python version: 3.6.9
  r8mat_print_some prints some of an R8MAT.

  Here is an R8MAT:

  Col:       3             4             5       
  Row
      0 :          14            15            16  
      1 :          24            25            26  
      2 :          34            35            36  

r8mat_print_some_test:
  Normal end of execution.

r8poly_test
  Python version: 3.6.9
  r8poly() converts between power sum, factorial
  and Taylor forms, and can evaluate a polynomial


  All calls have input A as follows:
  0
  0
  0
  0
  0
  1


  Option IOPT = -3
  Output array:
  0
  24
  -50
  35
  -10
  1


  Option IOPT = -2
  Output array:
  0
  1
  15
  25
  10
  1


  Option IOPT = -1
  X0 = 2
  Value = 0

  Option IOPT = 0
  X0 = 2
  Value = 32

  Option IOPT = 6
  X0 = 2
  Output array:
  32
  80
  80
  40
  10
  1


  Option IOPT = 6
  X0 = -2
  Output array:
  -32
  80
  -80
  40
  -10
  1


r8poly_test:
  Normal end of execution.

r8poly_f2p_test
  Python version: 3.6.9
  r8poly_f2p: factorial => power sum.

  The power sum polynomial:

  p(x) =   4 * x^3
         + 3 * x^2
         + 2 * x
         + 1

  The factorial polynomial coefficients:

     0:             1
     1:             9
     2:            15
     3:             4

  The recovered power sum polynomial:

  p(x) =   4 * x^3
         + 3 * x^2
         + 2 * x
         + 1

r8poly_f2p_test
  Normal end of execution.

r8poly_fval_test
  Python version: 3.6.9
  r8poly_fval evaluates a polynomial in factorial form.

  The factorial polynomial coefficients:

     0:             1
     1:             2
     2:             3
     3:             4
     4:             5

  R8POLY(2) = 11
  The correct value is 11.

r8poly_nval_test:
  Normal end of execution.

r8poly_n2p_test
  Python version: 3.6.9
  r8poly_n2p: Newton => power sum

  The power sum polynomial:

  p(x) =   4 * x^3
         + 3 * x^2
         + 2 * x
         + 1

  Newton polynomial coefficients:

     0:            49
     1:           132
     2:            51
     3:             4

  Newton polynomial abscissas:

     0:             2
     1:             4
     2:             6
     3:             8

  The recovered power sum polynomial:

  p(x) =   4 * x^3
         + 3 * x^2
         + 2 * x
         + 1

r8poly_n2p_test:
  Normal end of execution.

r8poly_nval_test
  Python version: 3.6.9
  r8poly_nval evaluates a Newton polynomial.

  Newton polynomial coefficients:

     0:             1
     1:             2
     2:             3
     3:             4
     4:             5

  Newton polynomial abscissas:

     0:             0
     1:             1
     2:             2
     3:             3

  R8POLY(2) = 11
  The correct value is 11.

r8poly_nval_test:
  Normal end of execution.

r8poly_nx_test
  Python version: 3.6.9
  r8poly_nx replaces one abscissa in a Newton polynomial.

  Newton polynomial coefficients:

     0:             1
     1:             2
     2:             3

  Newton polynomial abscissas:

     0:             1
     1:             2
     2:             3

  Replace one abscissa by X = 0

  Newton polynomial coefficients:

     0:             5
     1:            -4
     2:             3

  Newton polynomial abscissas:

     0:             0
     1:             1
     2:             2

r8poly_nx_test
  Normal end of execution.

r8poly_p2f_test
  Python version: 3.6.9
  r8poly_p2f: power sum => factorial;

  The power sum polynomial:

  p(x) =   4 * x^3
         + 3 * x^2
         + 2 * x
         + 1

  The factorial polynomial coefficients:

     0:             1
     1:             9
     2:            15
     3:             4

  The recovered power sum polynomial:

  p(x) =   4 * x^3
         + 3 * x^2
         + 2 * x
         + 1

r8poly_p2f_test
  Normal end of execution.

r8poly_p2n_test
  Python version: 3.6.9
  r8poly_p2n: Power sum => Newton.

  The power sum polynomial:

  p(x) =   4 * x^3
         + 3 * x^2
         + 2 * x
         + 1

  Newton polynomial coefficients:

     0:            49
     1:           132
     2:            51
     3:             4

  Newton polynomial abscissas:

     0:             2
     1:             4
     2:             6
     3:             8

  The recovered power sum polynomial:

  p(x) =   4 * x^3
         + 3 * x^2
         + 2 * x
         + 1

r8poly_p2n_test:
  Normal end of execution.

r8poly_p2t_test
  Python version: 3.6.9
  r8poly_p2t: Power sum => Taylor.

  Taylor expansion point is X = 2

  The Taylor coefficients:

     0:             1
     1:             2
     2:             3
     3:             4

  The power sum polynomial:

  p(x) =   4 * x^3
         - 21 * x^2
         + 38 * x
         - 23

  The recovered Taylor coefficients:

     0:             1
     1:             2
     2:             3
     3:             4

r8poly_p2t_test:
  Normal end of execution.

r8poly_print_test
  Python version: 3.6.9
  r8poly_print prints an R8POLY.

  The R8POLY:

  p(x) =   9 * x^5
         + 0.78 * x^4
         + 56 * x^2
         - 3.4 * x
         + 12

r8poly_print_test:
  Normal end of execution.

r8poly_pval_test
  Python version: 3.6.9
  r8poly_pval evaluates a polynomial
  in power sum form.

  The polynomial to be evaluated:

  p(x) =   5 * x^4
         + 4 * x^3
         + 3 * x^2
         + 2 * x
         + 1

  At X = 2.000000
  Computed polynomial value is 129.000000
  Correct value is 129.

r8poly_pval_test
  Normal end of execution.

r8poly_t2p_test
  Python version: 3.6.9
  r8poly_t2p: Taylor => Power sum

  Taylor expansion point is X = 2

  The Taylor coefficients:

     0:             1
     1:             2
     2:             3
     3:             4

  The power sum polynomial:

  p(x) =   4 * x^3
         - 21 * x^2
         + 38 * x
         - 23

  The recovered Taylor coefficients:

     0:             1
     1:             2
     2:             3
     3:             4

r8poly_t2p_test:
  Normal end of execution.

r8vec_backtrack_test
  Python version: 3.6.9
  r8vec_backtrack uses backtracking, seeking a vector X of
  N values which satisfies some condition.

  In this demonstration, we have 8 values W(I).
  We seek all subsets that sum to 53.0.
  X(I) is 0.0 or 1.0 if the entry is skipped or used.

   1   
  53:  
  15
  22
  16

   2   
  53:  
  15
  14
  16
  8

   3   
  53:  
  22
  14
  9
  8


  Done!

r8vec_backtrack_test:
  Normal end of execution.

r8vec_frac_test
  Python version: 3.6.9
  r8vec_frac: K-th smallest real vector entry;

  The real array to search: 

     0:       6.09456
     1:       7.77402
     2:       6.06863
     3:       5.07321
     4:       2.50915
     5:       7.11738
     6:       3.22761
     7:       4.53039
     8:       6.07348
     9:       3.55421

Frac   r8vec_frac

   1  2.509148
   2  3.227605
   3  3.554206
   4  4.530393
   5  5.073209
   6  6.068632
   7  6.073483
   8  6.094561
   9  7.117377
  10  7.774017

r8vec_frac_test
  Normal end of execution.

r8vec_indicator1_test
  Python version: 3.6.9
  r8vec_indicator1 returns the 1-based indicator matrix.

  The 1-based indicator vector:

     0:             1
     1:             2
     2:             3
     3:             4
     4:             5
     5:             6
     6:             7
     7:             8
     8:             9
     9:            10

r8vec_indicator1_test
  Normal end of execution.

r8vec_mirror_next_test
  Python version: 3.6.9
  r8vec_mirror_next generates all sign variations
  of a real vector.

   0       1       2       3
   0      -1       2       3
   0       1      -2       3
   0      -1      -2       3
   0       1       2      -3
   0      -1       2      -3
   0       1      -2      -3
   0      -1      -2      -3

  Done.

   0       1       0       3
   0      -1       0       3
   0       1      -0      -3
   0      -1      -0      -3

  Done.

r8vec_mirror_next_test:
  Normal end of execution.

r8vec_print_test
  Python version: 3.6.9
  Test r8vec_print(), which prints an R8VEC.

  Use r8vec_print():

     0:       123.456
     1:         5e-06
     2:        -1e+06
     3:       3.14159

  Use python print():

[ 1.23456000e+02  5.00000000e-06 -1.00000000e+06  3.14159265e+00]

r8vec_print_test:
  Normal end of execution.

rat_add_test
  Python version: 3.6.9
  rat_add adds two rationals.

  A = 3/4
  B = 10/7
  C = A + B = 61/28

rat_add_test
  Normal end of execution.

rat_div_test
  Python version: 3.6.9
  rat_div divides two rationals.

  A = 3/4
  B = 10/7
  C = A / B = 21/40

rat_div_test
  Normal end of execution.

rat_farey_test
  Python version: 3.6.9
  rat_farey computes a row of the Farey fraction table.

  Row 1
  Number of fractions: 2
  0/1
  1/1


  Row 2
  Number of fractions: 3
  0/1
  1/2
  1/1


  Row 3
  Number of fractions: 5
  0/1
  1/3
  1/2
  2/3
  1/1


  Row 4
  Number of fractions: 7
  0/1
  1/4
  1/3
  1/2
  2/3
  3/4
  1/1


  Row 5
  Number of fractions: 11
  0/1
  1/5
  1/4
  1/3
  2/5
  1/2
  3/5
  2/3
  3/4
  4/5

  1/1


  Row 6
  Number of fractions: 13
  0/1
  1/6
  1/5
  1/4
  1/3
  2/5
  1/2
  3/5
  2/3
  3/4

  4/5
  5/6
  1/1


  Row 7
  Number of fractions: 19
  0/1
  1/7
  1/6
  1/5
  1/4
  2/7
  1/3
  2/5
  3/7
  1/2

  4/7
  3/5
  2/3
  5/7
  3/4
  4/5
  5/6
  6/7
  1/1


rat_farey_test
  Normal end of execution.

rat_farey2_test
  Python version: 3.6.9
  rat_farey2 computes a row of the Farey fraction table.

  Row 0
  Number of fractions: 2
  0/1
  1/1


  Row 1
  Number of fractions: 3
  0/1
  1/2
  1/1


  Row 2
  Number of fractions: 5
  0/1
  1/3
  1/2
  2/3
  1/1


  Row 3
  Number of fractions: 9
  0/1
  1/4
  1/3
  2/5
  1/2
  3/5
  2/3
  3/4
  1/1


  Row 4
  Number of fractions: 17
  0/1
  1/5
  1/4
  2/7
  1/3
  3/8
  2/5
  3/7
  1/2
  4/7

  3/5
  5/8
  2/3
  5/7
  3/4
  4/5
  1/1


rat_farey2_test
  Normal end of execution.

rat_mul_test
  Python version: 3.6.9
  rat_mul multiplies two rationals.

  A = 3/4
  B = 10/7
  C = A * B = 15/14

rat_mul_test
  Normal end of execution.

rat_normalize_test
  Python version: 3.6.9
  rat_normalize normalizes a rational.

           A           B             A             B
                                 normalized     normalized

           3           4             3           4
           1        1000             1        1000
          20           1            20           1
           8           4             2           1
         -10           7           -10           7
           9         -15            -3           5
         -11         -11             1           1

rat_to_cfrac_test
  Python version: 3.6.9
  rat_to_cfrac fraction => continued fraction,

  Regular fraction is   4096 /  15625

  Continued fraction coefficients:

     0       0
     1       3
     2       1
     3       4
     4       2
     5       1
     6       1
     7      11
     8      13

  The continued fraction convergents.
  The last row contains the value of the continued
  fraction, written as a common fraction.

  I, P(I), Q(I), P(I)/Q(I)

    0       0       1        0.000000
    1       1       3        0.333333
    2       1       4        0.250000
    3       5      19        0.263158
    4      11      42        0.261905
    5      16      61        0.262295
    6      27     103        0.262136
    7     313    1194        0.262144
    8    4096   15625        0.262144

rat_to_cfrac_test
  Normal end of execution.

rat_to_dec_test
  Python version: 3.6.9
  rat_to_dec fraction => decimal,

  In this test, choose the top and bottom
  of a rational at random, and compute the
  equivalent real number.

  Then convert to decimal, and the equivalent real.

  Then convert back to rational and the equivalent real.

  1.61922 = 910 / 562
  1.61922 = 1619217081850534 * 10^-15
  1.61922 = 809608540925267 / 500000000000000

  -0.488827 = -175 / 358
  -0.488827 = -4888268156424582 * 10^-16
  -0.488827 = -2444134078212291 / 5000000000000000

  0.963227 = 812 / 843
  0.963227 = 963226571767497 * 10^-15
  0.963227 = 963226571767497 / 1000000000000000

  2.47143 = 865 / 350
  2.47143 = 2471428571428572 * 10^-15
  2.47143 = 617857142857143 / 250000000000000

  1.73824 = 850 / 489
  1.73824 = 17382413087934564 * 10^-16
  1.73824 = 4345603271983641 / 2500000000000000

  -0.368421 = -154 / 418
  -0.368421 = -3684210526315789 * 10^-16
  -0.368421 = -3684210526315789 / 10000000000000000

  -0.13587 = -100 / 736
  -0.13587 = -1358695652173913 * 10^-16
  -0.13587 = -1358695652173913 / 10000000000000000

  -6.11811 = -777 / 127
  -6.11811 = -6118110236220472 * 10^-15
  -6.11811 = -764763779527559 / 125000000000000

  -1.36842 = -676 / 494
  -1.36842 = -1368421052631579 * 10^-15
  -1.36842 = -1368421052631579 / 1000000000000000

  -1.14667 = -516 / 450
  -1.14667 = -1146666666666667 * 10^-15
  -1.14667 = -1146666666666667 / 1000000000000000

rat_to_dec_test
  Normal end of execution.

rat_to_r8_test
  Python version: 3.6.9
  rat_to_r8 converts a rational to a real number.

  The maximum number of digits allowed is 4

     R   =>  A / B  =>  R2

     1.97874   19787   10000      1.9787
     4.45755    1783     400      4.4575
     3.62716    2267     625      3.6272
     4.98507   49851   10000      4.9851
     6.46901    6469    1000       6.469
     4.17509   41751   10000      4.1751
     3.98717    2492     625      3.9872
     6.89408   68941   10000      6.8941
   -0.285403   -1427    5000     -0.2854
    -2.41064  -12053    5000     -2.4106

rat_to_r8_test
  Normal end of execution.

rat_to_s_test
  Python version: 3.6.9
  rat_to_s converts a rational to a string.

           A           B    A/B

           3           4    3/4
           1        1000    1/1000
          20           1    20/1
           8           4    8/4
         -10           7    -10/7
           9         -15    9/-15
         -11         -11    -11/-11

rat_to_s_test:
  Normal end of execution.

rat_width_test
  Python version: 3.6.9
  rat_width determines the "width" of a rational.

       Top    Bottom   Width

      1000         3       4
      1000        40       4
      1000       500       4
      1000      6000       4
      1000     70000       5
         1         1       1
        -1       200       3
       -10       200       3
      -100       200       4
     -1000       200       5
         1      -200       3
        10      -200       3
       100      -200       4
      1000      -200       5
     10000      -200       6
        17      3000       4
   4000000   4000000       7

rat_width_test
  Normal end of execution.

regro_next_test
  Python version: 3.6.9
  regro_next generates all restricted growth
  functions.

   1  
   1
   1
   1
   1

   2  
   1
   1
   1
   2

   3  
   1
   1
   2
   1

   4  
   1
   1
   2
   2

   5  
   1
   1
   2
   3

   6  
   1
   2
   1
   1

   7  
   1
   2
   1
   2

   8  
   1
   2
   1
   3

   9  
   1
   2
   2
   1

  10  
   1
   2
   2
   2

  11  
   1
   2
   2
   3

  12  
   1
   2
   3
   1

  13  
   1
   2
   3
   2

  14  
   1
   2
   3
   3

  15  
   1
   2
   3
   4


regro_next_test:
  Normal end of execution.

rfrac_to_cfrac_test
  Python version: 3.6.9
  rfrac_to_cfrac: rational polynomial fraction to continued fraction.

  Rational polynomial numerator coefficients:

     0:             1
     1:             1
     2:             2

  Rational polynomial numerator coefficients:

     0:             1
     1:             3
     2:             1
     3:             1

  Continued fraction coefficients:

     0:             1
     1:           0.5
     2:       1.33333
     3:          -0.5
     4:          -1.5
     5:             2

  Recovered rational polynomial numerator coefficients:

     0:             1
     1:             1
     2:             2

  Recovered rational polynomial numerator coefficients:

     0:             1
     1:             3
     2:             1
     3:             1

rfrac_to_cfrac_test
  Normal end of execution.

rfrac_to_jfrac_test
  Python version: 3.6.9
  rfrac_to_jfrac converts a rational polynomial
  fraction to a J fraction.

  RFRAC P:

     0:      0.988967
     1:      0.294395
     2:      0.761449
     3:      0.839703
     4:      0.718505
     5:      0.120811

  RFRAC Q:

     0:       3.27531
     1:      0.775481
     2:       8.06367
     3:       1.72868
     4:       1.44962
     5:       7.35028
     6:             1

  JFRAC R:

     0:      0.120811
     1:      -13.8446
     2:       1.63512
     3:       5.85745
     4:      0.384901
     5:      0.915006

  JFRAC S:

     0:       1.40292
     1:       4.91265
     2:      -1.64376
     3:       3.43855
     4:     -0.149387
     5:     -0.610686

  Recovered RFRAC P:

     0:      0.988967
     1:      0.294395
     2:      0.761449
     3:      0.839703
     4:      0.718505
     5:      0.120811

  Recovered RFRAC Q:

     0:       3.27531
     1:      0.775481
     2:       8.06367
     3:       1.72868
     4:       1.44962
     5:       7.35028
     6:             1

rfrac_to_jfrac_test:
  Normal end of execution.

schroeder_test
  Python version: 3.6.9
  schroeder computes the Schroeder numbers.

     N        S(N)

     0         1
     1         1
     2         3
     3        11
     4        45
     5       197
     6       903
     7      4279
     8     20793
     9    103049

schroeder_test:
  Normal end of execution.

sort_heap_external_test
  Python version: 3.6.9
  sort_heap_external sorts objects externally.

  Unsorted array:

     0      18
     1      16
     2       2
     3       9
     4      19
     5      17
     6       1
     7       9
     8      12
     9      20
    10       9
    11       4
    12       6
    13      14
    14       8
    15      19
    16       5
    17      19
    18      13
    19       9

  Sorted array:

     0       1
     1       2
     2       4
     3       5
     4       6
     5       8
     6       9
     7       9
     8       9
     9       9
    10      12
    11      13
    12      14
    13      16
    14      17
    15      18
    16      19
    17      19
    18      19
    19      20

sort_heap_external_test:
  Normal end of execution.

subcomp_next_test
  Python version: 3.6.9
  subcomp_next generates subcompositions.

  Seek all subcompositions of N = 6
  Into K = 3 parts.

     #   Sum

     1     0  
   0
   0
   0

     2     1  
   1
   0
   0

     3     1  
   0
   1
   0

     4     1  
   0
   0
   1

     5     2  
   2
   0
   0

     6     2  
   1
   1
   0

     7     2  
   0
   2
   0

     8     2  
   1
   0
   1

     9     2  
   0
   1
   1

    10     2  
   0
   0
   2

    11     3  
   3
   0
   0

    12     3  
   2
   1
   0

    13     3  
   1
   2
   0

    14     3  
   0
   3
   0

    15     3  
   2
   0
   1

    16     3  
   1
   1
   1

    17     3  
   0
   2
   1

    18     3  
   1
   0
   2

    19     3  
   0
   1
   2

    20     3  
   0
   0
   3

    21     4  
   4
   0
   0

    22     4  
   3
   1
   0

    23     4  
   2
   2
   0

    24     4  
   1
   3
   0

    25     4  
   0
   4
   0

    26     4  
   3
   0
   1

    27     4  
   2
   1
   1

    28     4  
   1
   2
   1

    29     4  
   0
   3
   1

    30     4  
   2
   0
   2

    31     4  
   1
   1
   2

    32     4  
   0
   2
   2

    33     4  
   1
   0
   3

    34     4  
   0
   1
   3

    35     4  
   0
   0
   4

    36     5  
   5
   0
   0

    37     5  
   4
   1
   0

    38     5  
   3
   2
   0

    39     5  
   2
   3
   0

    40     5  
   1
   4
   0

    41     5  
   0
   5
   0

    42     5  
   4
   0
   1

    43     5  
   3
   1
   1

    44     5  
   2
   2
   1

    45     5  
   1
   3
   1

    46     5  
   0
   4
   1

    47     5  
   3
   0
   2

    48     5  
   2
   1
   2

    49     5  
   1
   2
   2

    50     5  
   0
   3
   2

    51     5  
   2
   0
   3

    52     5  
   1
   1
   3

    53     5  
   0
   2
   3

    54     5  
   1
   0
   4

    55     5  
   0
   1
   4

    56     5  
   0
   0
   5

    57     6  
   6
   0
   0

    58     6  
   5
   1
   0

    59     6  
   4
   2
   0

    60     6  
   3
   3
   0

    61     6  
   2
   4
   0

    62     6  
   1
   5
   0

    63     6  
   0
   6
   0

    64     6  
   5
   0
   1

    65     6  
   4
   1
   1

    66     6  
   3
   2
   1

    67     6  
   2
   3
   1

    68     6  
   1
   4
   1

    69     6  
   0
   5
   1

    70     6  
   4
   0
   2

    71     6  
   3
   1
   2

    72     6  
   2
   2
   2

    73     6  
   1
   3
   2

    74     6  
   0
   4
   2

    75     6  
   3
   0
   3

    76     6  
   2
   1
   3

    77     6  
   1
   2
   3

    78     6  
   0
   3
   3

    79     6  
   2
   0
   4

    80     6  
   1
   1
   4

    81     6  
   0
   2
   4

    82     6  
   1
   0
   5

    83     6  
   0
   1
   5

    84     6  
   0
   0
   6


subcomp_next_test
  Normal end of execution.

subcompnz_next_test
  Python version: 3.6.9
  subcompnz_next generates subcompositions
  using nonzero parts.

  Seek all subcompositions of N = 6
  using K = 3 nonzero parts.

     #   Sum

     1     3  
   1
   1
   1

     2     4  
   2
   1
   1

     3     4  
   1
   2
   1

     4     4  
   1
   1
   2

     5     5  
   3
   1
   1

     6     5  
   2
   2
   1

     7     5  
   1
   3
   1

     8     5  
   2
   1
   2

     9     5  
   1
   2
   2

    10     5  
   1
   1
   3

    11     6  
   4
   1
   1

    12     6  
   3
   2
   1

    13     6  
   2
   3
   1

    14     6  
   1
   4
   1

    15     6  
   3
   1
   2

    16     6  
   2
   2
   2

    17     6  
   1
   3
   2

    18     6  
   2
   1
   3

    19     6  
   1
   2
   3

    20     6  
   1
   1
   4


subcompnz_next_test
  Normal end of execution.

subcompnz2_next_test
  Python version: 3.6.9
  subcompnz2_next generates subcompositions
  using nonzero parts.

  Seek all subcompositions of N
  using K = 3 nonzero parts
  for 5 <= N <= 7

     #     N

     1     5  
   3
   1
   1

     2     5  
   2
   2
   1

     3     5  
   1
   3
   1

     4     5  
   2
   1
   2

     5     5  
   1
   2
   2

     6     5  
   1
   1
   3

     7     6  
   4
   1
   1

     8     6  
   3
   2
   1

     9     6  
   2
   3
   1

    10     6  
   1
   4
   1

    11     6  
   3
   1
   2

    12     6  
   2
   2
   2

    13     6  
   1
   3
   2

    14     6  
   2
   1
   3

    15     6  
   1
   2
   3

    16     6  
   1
   1
   4

    17     7  
   5
   1
   1

    18     7  
   4
   2
   1

    19     7  
   3
   3
   1

    20     7  
   2
   4
   1

    21     7  
   1
   5
   1

    22     7  
   4
   1
   2

    23     7  
   3
   2
   2

    24     7  
   2
   3
   2

    25     7  
   1
   4
   2

    26     7  
   3
   1
   3

    27     7  
   2
   2
   3

    28     7  
   1
   3
   3

    29     7  
   2
   1
   4

    30     7  
   1
   2
   4

    31     7  
   1
   1
   5


subcompnz2_next_test
  Normal end of execution.

subset_by_size_next_test
  Python version: 3.6.9
  subset_by_size_next generates all subsets of an N set.

   1
   1
   2
   3
   4
   5

   2
   1
   2
   3
   4

   3
   1
   2
   3
   5

   4
   1
   2
   4
   5

   5
   1
   3
   4
   5

   6
   2
   3
   4
   5

   7
   1
   2
   3

   8
   1
   2
   4

   9
   1
   2
   5

  10
   1
   3
   4

  11
   1
   3
   5

  12
   1
   4
   5

  13
   2
   3
   4

  14
   2
   3
   5

  15
   2
   4
   5

  16
   3
   4
   5

  17
   1
   2

  18
   1
   3

  19
   1
   4

  20
   1
   5

  21
   2
   3

  22
   2
   4

  23
   2
   5

  24
   3
   4

  25
   3
   5

  26
   4
   5

  27
   1

  28
   2

  29
   3

  30
   4

  31
   5

  32
  The empty set

subset_by_size_next_test
  Normal end of execution.

subset_gray_next_test
  Python version: 3.6.9
  subset_gray_next generates all subsets of an N set.
  using the Gray code ordering:
  0 0 1 0 1 means the subset contains 3 and 5.

  Gray code

   1     0     0     0     0     0
   2     1     0     0     0     0
   3     1     1     0     0     0
   4     0     1     0     0     0
   5     0     1     1     0     0
   6     1     1     1     0     0
   7     1     0     1     0     0
   8     0     0     1     0     0
   9     0     0     1     1     0
  10     1     0     1     1     0
  11     1     1     1     1     0
  12     0     1     1     1     0
  13     0     1     0     1     0
  14     1     1     0     1     0
  15     1     0     0     1     0
  16     0     0     0     1     0
  17     0     0     0     1     1
  18     1     0     0     1     1
  19     1     1     0     1     1
  20     0     1     0     1     1
  21     0     1     1     1     1
  22     1     1     1     1     1
  23     1     0     1     1     1
  24     0     0     1     1     1
  25     0     0     1     0     1
  26     1     0     1     0     1
  27     1     1     1     0     1
  28     0     1     1     0     1
  29     0     1     0     0     1
  30     1     1     0     0     1
  31     1     0     0     0     1
  32     0     0     0     0     1

subset_gray_next_test
  Normal end of execution.

subset_gray_rank_test
  Python version: 3.6.9
  subset_gray_rank returns rank of a subset of an N set
  using the Gray code ordering.

  For N = 5
  the subset is:
     1
     0
     1
     1
     0


  The rank is 28

subset_gray_rank_test:
  Normal end of execution.

subset_gray_unrank_test
  Python version: 3.6.9
  subset_gray_unrank finds the subset of an N set
  of a given rank under the Gray code ordering.

  N is 5

  Rank   Subset

     1
   0
   0
   0
   0
   0

     2
   0
   0
   0
   0
   1

     3
   0
   0
   0
   1
   1

     4
   0
   0
   0
   1
   0

     5
   0
   0
   1
   1
   0

     6
   0
   0
   1
   1
   1

     7
   0
   0
   1
   0
   1

     8
   0
   0
   1
   0
   0

     9
   0
   1
   1
   0
   0

    10
   0
   1
   1
   0
   1


subset_gray_unrank_test
  Normal end of execution.

subset_lex_next_test
  Python version: 3.6.9
  subset_lex_next generates all subsets of an N set.
  The user can impose a restriction on the
  maximum size of the subsets.

  Here, we require the subsets to be no larger
  than 3
     1

     1
     2

     1
     2
     3

     1
     2
     4

     1
     2
     5

     1
     3

     1
     3
     4

     1
     3
     5

     1
     4

     1
     4
     5

     1
     5

     2

     2
     3

     2
     3
     4

     2
     3
     5

     2
     4

     2
     4
     5

     2
     5

     3

     3
     4

     3
     4
     5

     3
     5

     4

     4
     5

     5

The empty set.

subset_lex_next_test:
  Normal end of execution.

subset_random_test
  Python version: 3.6.9
  subset_random randomly selects a subset.
  The number of elements in the set is 5

  
   1
   1
   1
   0
   0

  
   1
   1
   0
   0
   0

  
   0
   0
   1
   0
   0

  
   1
   1
   1
   1
   1

  
   0
   1
   0
   0
   1


subset_random_test
  Normal end of execution.

subtriangle_next_test
  Python version: 3.6.9
  subtriangle_next generates the indices of subtriangles
  in a triangle whose edges were divided into N subedges.

  For this test, N = 4

  Rank    I1  J1    I2  J2    I3  J3

     1     0   0     1   0     0   1
     2     1   1     0   1     1   0
     3     1   0     2   0     1   1
     4     2   1     1   1     2   0
     5     2   0     3   0     2   1
     6     3   1     2   1     3   0
     7     3   0     4   0     3   1
     8     0   1     1   1     0   2
     9     1   2     0   2     1   1
    10     1   1     2   1     1   2
    11     2   2     1   2     2   1
    12     2   1     3   1     2   2
    13     0   2     1   2     0   3
    14     1   3     0   3     1   2
    15     1   2     2   2     1   3
    16     0   3     1   3     0   4

subtriangle_next_test:
  Normal end of execution.

thue_binary_next_test
  Python version: 3.6.9
  thue_binary_next returns the next Thue binary sequence.

   1:  
0

   2:  
0
1

   4:  
0
1
1
0

   8:  
0
1
1
0
1
0
0
1

  16:  
0
1
1
0
1
0
0
1
1
0
0
1
0
1
1
0

  32:  
0
1
1
0
1
0
0
1
1
0
0
1
0
1
1
0
1
0
0
1
0
1
1
0
0
1
1
0
1
0
0
1

  64:  
0
1
1
0
1
0
0
1
1
0
0
1
0
1
1
0
1
0
0
1
0
1
1
0
0
1
1
0
1
0
0
1
1
0
0
1
0
1
1
0
0
1
1
0
1
0
0
1
0
1
1
0
1
0
0
1
1
0
0
1
0
1
1
0


thue_binary_next_test:
  Normal end of execution.

thue_ternary_next_test
  Python version: 3.6.9
  thue_ternary_next returns the next
  Thue ternary sequence.

0 1
1 1 0 2
2 1 0 2 1 2 0
3 1 0 2 1 2 0 1 0 2 0 1 2
4 1 0 2 1 2 0 1 0 2 0 1 2 1 0 2 1 2 0 1 2
 1 0 2 0
5 1 0 2 1 2 0 1 0 2 0 1 2 1 0 2 1 2 0 1 2
 1 0 2 0 1 0 2 1 2 0 1 0 2 0 1 2 1 0 2 0
 1 0 2 1 2 0 1 2

thue_ternary_next_test:
  Normal end of execution.

tuple_next_test
  Python version: 3.6.9
  tuple_next returns the next "tuple", that is,
  a vector of N integers, each between M1 and M2.

  M1 = 2
  M2 = 4
  N =  2

   #    X[0]   X[1]

   1  
   2  
   2  

   2  
   2  
   3  

   3  
   2  
   4  

   4  
   3  
   2  

   5  
   3  
   3  

   6  
   3  
   4  

   7  
   4  
   2  

   8  
   4  
   3  

   9  
   4  
   4  


tuple_next_test:
  Normal end of execution.

tuple_next2_test
  Python version: 3.6.9
  tuple_next2 returns the next "tuple", that is,
  a vector of N integers.

  N = 3

  Min 
   2
   3
   8


   1  
   2
   3
   8

   2  
   2
   3
   7

   3  
   2
   3
   6

   4  
   2
   3
   5

   5  
   3
   3
   8

   6  
   3
   3
   7

   7  
   3
   3
   6

   8  
   3
   3
   5

   9  
   4
   3
   8

  10  
   4
   3
   7

  11  
   4
   3
   6

  12  
   4
   3
   5


  Max 
   4
   3
   5


tuple_next2_test:
  Normal end of execution.

tuple_next_fast_test
  Python version: 3.6.9
  tuple_next_fast returns the next "tuple", that is,
  a vector of N integers, each between 1 and M.

  M = 3
  N = 2

   0  
         1  
         1  

   1  
         1  
         2  

   2  
         1  
         3  

   3  
         2  
         1  

   4  
         2  
         2  

   5  
         2  
         3  

   6  
         3  
         1  

   7  
         3  
         2  

   8  
         3  
         3  


tuple_next_fast_test:
  Normal end of execution.

tuple_next_ge_test
  Python version: 3.6.9
  tuple_next_ge returns the next "tuple", that is,
  a vector of N integers, each between 1 and M,
  with the constraint that the entries be
  nondecreasing.

  M = 3
  N = 3

   1
     1
     1
     1

   2
     1
     1
     2

   3
     1
     1
     3

   4
     1
     2
     2

   5
     1
     2
     3

   6
     1
     3
     3

   7
     2
     2
     2

   8
     2
     2
     3

   9
     2
     3
     3

  10
     3
     3
     3


tuple_next_ge_test:
  Normal end of execution.

triang_test
  Python version: 3.6.9
  triang relabels elements for a partial ordering,

  The input matrix:

  Col:       0        1        2        3        4        5        6        7        8        9  
  Row
    0:       1        0        0        0        0        0        0        0        0        0  
    1:       0        1        0        1        0        1        0        1        0        0  
    2:       1        0        1        1        0        0        0        0        0        0  
    3:       0        0        0        1        0        0        0        0        0        0  
    4:       1        1        1        1        1        1        1        1        0        1  
    5:       0        0        0        1        0        1        0        1        0        0  
    6:       1        0        1        1        0        1        1        1        0        1  
    7:       0        0        0        1        0        0        0        1        0        0  
    8:       0        0        0        0        0        0        0        0        0        0  
    9:       1        0        1        1        0        0        0        1        0        1  

  The new ordering:

  
   0
   1
   2
   3
   4
   5
   6
   7
   8
   9

  
   4
   5
   3
   8
   0
   6
   1
   7
   9
   2


  The reordered matrix:

  Col:       0        1        2        3        4        5        6        7        8        9  
  Row
    0:       1        1        1        1        1        1        1        1        1        0  
    1:       0        1        1        1        1        0        1        1        1        0  
    2:       0        0        1        1        1        0        0        1        1        0  
    3:       0        0        0        1        1        0        0        0        1        0  
    4:       0        0        0        0        1        0        0        0        0        0  
    5:       0        0        0        0        0        1        1        1        1        0  
    6:       0        0        0        0        0        0        1        1        1        0  
    7:       0        0        0        0        0        0        0        1        1        0  
    8:       0        0        0        0        0        0        0        0        1        0  
    9:       0        0        0        0        0        0        0        0        0        0  

triang_test:
  Normal end of execution.

tuple_next_test
  Python version: 3.6.9
  tuple_next returns the next "tuple", that is,
  a vector of N integers, each between M1 and M2.

  M1 = 2
  M2 = 4
  N =  2

   #    X[0]   X[1]

   1  
   2  
   2  

   2  
   2  
   3  

   3  
   2  
   4  

   4  
   3  
   2  

   5  
   3  
   3  

   6  
   3  
   4  

   7  
   4  
   2  

   8  
   4  
   3  

   9  
   4  
   4  


tuple_next_test:
  Normal end of execution.

tuple_next2_test
  Python version: 3.6.9
  tuple_next2 returns the next "tuple", that is,
  a vector of N integers.

  N = 3

  Min 
   2
   3
   8


   1  
   2
   3
   8

   2  
   2
   3
   7

   3  
   2
   3
   6

   4  
   2
   3
   5

   5  
   3
   3
   8

   6  
   3
   3
   7

   7  
   3
   3
   6

   8  
   3
   3
   5

   9  
   4
   3
   8

  10  
   4
   3
   7

  11  
   4
   3
   6

  12  
   4
   3
   5


  Max 
   4
   3
   5


tuple_next2_test:
  Normal end of execution.

ubvec_add_test
  ubvec_add adds unsigned binary vectors representing
  unsigned integers

        I        J        K = I + J


        82        31
  Directly:                113
  ubvec_add                113

         1        30
  Directly:                 31
  ubvec_add                 31

         5        84
  Directly:                 89
  ubvec_add                 89

        42        90
  Directly:                132
  ubvec_add                132

        48        22
  Directly:                 70
  ubvec_add                 70

        25        47
  Directly:                 72
  ubvec_add                 72

        70        83
  Directly:                153
  ubvec_add                153

         2        37
  Directly:                 39
  ubvec_add                 39

        54        36
  Directly:                 90
  ubvec_add                 90

        74        37
  Directly:                111
  ubvec_add                111

ubvec_add_test
  Normal end of execution.

ubvec_print_test
  Python version: 3.6.9
  ubvec_print prints an unsigned binary vector.

  UBVEC:
  
0
0
1
1
1
0
1
0
0
1


ubvec_print_test
  Normal end of execution.

ubvec_to_ui4_test
  Python version: 3.6.9
  ubvec_to_ui4 converts an unsigned binary vector
  to an unsigned integer

  ui4 --> UBVEC  -->  ui4

   0  
0
0
0
0
0
0
0
0
0
0
   0
   1  
0
0
0
0
0
0
0
0
0
1
   1
   2  
0
0
0
0
0
0
0
0
1
0
   2
   3  
0
0
0
0
0
0
0
0
1
1
   3
   4  
0
0
0
0
0
0
0
1
0
0
   4
   5  
0
0
0
0
0
0
0
1
0
1
   5
   6  
0
0
0
0
0
0
0
1
1
0
   6
   7  
0
0
0
0
0
0
0
1
1
1
   7
   8  
0
0
0
0
0
0
1
0
0
0
   8
   9  
0
0
0
0
0
0
1
0
0
1
   9
  10  
0
0
0
0
0
0
1
0
1
0
  10

ubvec_to_ui4_test
  Normal end of execution.

ubvec_xor_test
  ubvec_xor exclusive-ors unsigned binary vectors representing
  unsigned integers

        I        J        K = I XOR J

        96        27       123
        46        57        23
        78        73         7
        60        54        10
        91        64        27
        74        29        87
        98        24       122
        34        30        60
        39        35         4
         1        42        43

ubvec_xor_test
  Normal end of execution.

ui4_to_ubvec_test
  Python version: 3.6.9
  ui4_to_ubvec converts an unsigned integer to an
  unsigned binary vector;

  ui4 --> UBVEC  -->  ui4

   0  
0
0
0
0
0
0
0
0
0
0
   0
   1  
0
0
0
0
0
0
0
0
0
1
   1
   2  
0
0
0
0
0
0
0
0
1
0
   2
   3  
0
0
0
0
0
0
0
0
1
1
   3
   4  
0
0
0
0
0
0
0
1
0
0
   4
   5  
0
0
0
0
0
0
0
1
0
1
   5
   6  
0
0
0
0
0
0
0
1
1
0
   6
   7  
0
0
0
0
0
0
0
1
1
1
   7
   8  
0
0
0
0
0
0
1
0
0
0
   8
   9  
0
0
0
0
0
0
1
0
0
1
   9
  10  
0
0
0
0
0
0
1
0
1
0
  10

ui4_to_ubvec_test
  Normal end of execution.

vec_colex_next_test
  Python version: 3.6.9
  vec_colex_next generates all DIM_nUM-vectors
  in colex order in a given base BASE.

  The spatial dimension DIM_nUM = 3
  The base BASE =                 3

 0 0 0
 1 0 0
 2 0 0
 0 1 0
 1 1 0
 2 1 0
 0 2 0
 1 2 0
 2 2 0
 0 0 1
 1 0 1
 2 0 1
 0 1 1
 1 1 1
 2 1 1
 0 2 1
 1 2 1
 2 2 1
 0 0 2
 1 0 2
 2 0 2
 0 1 2
 1 1 2
 2 1 2
 0 2 2
 1 2 2
 2 2 2

vec_colex_next_test:
  Normal end of execution.

vec_colex_next2_test
  Python version: 3.6.9
  vec_colex_next2 generates all DIM_nUM-vectors
  in colex order in a given base BASE.

  The spatial dimension DIM_nUM = 3
  The base vector: 2 1 3

 0 0 0
 1 0 0
 0 0 1
 1 0 1
 0 0 2
 1 0 2

vec_colex_next2_test:
  Normal end of execution.

vec_colex_next3_test
  Python version: 3.6.9
  vec_colex_next3 generates all DIM_nUM-vectors
  in colex order in a given base BASE.

  The spatial dimension DIM_nUM = 3
  The base vector: 2 1 3

 1 1 1
 2 1 1
 1 1 2
 2 1 2
 1 1 3
 2 1 3

vec_colex_next3_test:
  Normal end of execution.

vec_gray_next_test
  Python version: 3.6.9
  vec_gray_next generates product space elements.

  The number of components is 4
  The number of elements is 16
  Each component has its own number of degrees of
  freedom.

  Rank Change          2     2     1     4

     1     0           0     0     0     0
     2     3           0     0     0     1
     3     3           0     0     0     2
     4     3           0     0     0     3
     5     1           0     1     0     3
     6     3           0     1     0     2
     7     3           0     1     0     1
     8     3           0     1     0     0
     9     0           1     1     0     0
    10     3           1     1     0     1
    11     3           1     1     0     2
    12     3           1     1     0     3
    13     1           1     0     0     3
    14     3           1     0     0     2
    15     3           1     0     0     1
    16     3           1     0     0     0

vec_gray_next_test:
  Normal end of execution.

vec_gray_rank_test
  Python version: 3.6.9
  vec_gray_rank ranks product space elements.

  The number of components is 4
  The number of elements is 16
  Each component has its own number of degrees of
  freedom.

  vec_gray_rank reports the element

  1  1  0  2

  has rank 11

vec_gray_rank_test:
  Normal end of execution.

vec_gray_unrank_test
  Python version: 3.6.9
  vec_gray_unrank unranks product space elements.

  The number of components is 4
  The number of elements is 16
  Each component has its own number of degrees of
  freedom.

  vec_gray_unrank reports the element of rank 7:

  0  1  0  1

vec_gray_unrank_test:
  Normal end of execution.

vec_lex_next_test
  Python version: 3.6.9
  vec_lex_next generates all DIM_nUM-vectors
  in lex order in a given base BASE.

  The spatial dimension DIM_nUM = 3
  The base BASE =                 3

 0 0 0
 0 0 1
 0 0 2
 0 1 0
 0 1 1
 0 1 2
 0 2 0
 0 2 1
 0 2 2
 1 0 0
 1 0 1
 1 0 2
 1 1 0
 1 1 1
 1 1 2
 1 2 0
 1 2 1
 1 2 2
 2 0 0
 2 0 1
 2 0 2
 2 1 0
 2 1 1
 2 1 2
 2 2 0
 2 2 1
 2 2 2

vec_lex_next_test:
  Normal end of execution.

vec_random_test
  Python version: 3.6.9
  vec_random generates a random N-vector
  in a given base.
  Here, we use base 3

   0   0   0
   2   0   1
   0   0   0
   2   2   0
   2   0   0

vec_random_test:
  Normal end of execution.

vector_constrained_next_test
  Python version: 3.6.9
  vector_constrained_next:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_max(1:N),
  Set
    P = Product X_max(1:N)
  Accept only vectors for which:
    sum ( (X(1:N)-1) * P / X_max(1:N) ) <= P
  XMIN: 2 2 1
  XMAX: 4 5 3

  Maximum allowed CONSTRAINT = P =        60

         1:         2         2         1            27
         2:         3         2         1            42
         3:         4         2         1            57
         4:         2         3         1            39
         5:         3         3         1            54
         6:         2         4         1            51
         7:         2         2         2            47
         8:         2         3         2            59

vector_constrained_next_test
  Normal end of execution.

vector_constrained_next2_test
  Python version: 3.6.9
  vector_constrained_next2:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_max(1:N),
  Set
    P = Product X_max(1:N)
  Accept only vectors for which:
    sum ( X(1:N) * P / X_max(1:N) ) <= P
  XMIN: 1 1
  XMAX: 5 6

  Maximum allowed CONSTRAINT = P =        120

         1         1         1            44
         2         1         2            64
         3         1         3            84
         4         1         4           104
  XMIN: 1 1 1
  XMAX: 5 6 4

  Maximum allowed CONSTRAINT = P =        120

         1         1         1         1            74
         2         1         2         1            94
         3         1         3         1           114
         4         1         1         2           104

vector_constrained_next2_test
  Normal end of execution.

vector_constrained_next3_test
  Python version: 3.6.9
  vector_constrained_next3:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_max(1:N),
  Set
    CONSTRAINT = sum ( X(1:N) / X_max(1:N) )
  Accept only vectors for which:
    CONSTRAINT <= 1
  XMIN: 1 1
  XMAX: 5 6

  Maximum allowed CONSTRAINT = P =        120

         1         1         1      0.366667
         2         2         1      0.566667
         3         3         1      0.766667
         4         4         1      0.966667
         5         1         2      0.533333
         6         2         2      0.733333
         7         3         2      0.933333
         8         1         3           0.7
         9         2         3           0.9
        10         1         4      0.866667
  XMIN: 1 1 1
  XMAX: 5 6 4

  Maximum allowed CONSTRAINT = P =        120

         1         1         1         1      0.616667
         2         2         1         1      0.816667
         3         1         2         1      0.783333
         4         2         2         1      0.983333
         5         1         3         1          0.95
         6         1         1         2      0.866667

vector_constrained_next3_test
  Normal end of execution.

vector_constrained_next4_test
  Python version: 3.6.9
  vector_constrained_next4:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_max(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    TOTAL <= Q

  ALPHA:        4.000000        3.000000
  Q:         20.000000
  XMIN: 1 0
  XMAX: 2 6

         1        4.000000         1         0
         2        8.000000         2         0
         3        7.000000         1         1
         4       11.000000         2         1
         5       10.000000         1         2
         6       14.000000         2         2
         7       13.000000         1         3
         8       17.000000         2         3
         9       16.000000         1         4
        10       20.000000         2         4
        11       19.000000         1         5

  ALPHA:        4.000000        3.000000        5.000000
  Q:         20.000000
  XMIN: 1 0 1
  XMAX: 2 6 4

         1        9.000000         1         0         1
         2       13.000000         2         0         1
         3       12.000000         1         1         1
         4       16.000000         2         1         1
         5       15.000000         1         2         1
         6       19.000000         2         2         1
         7       18.000000         1         3         1
         8       14.000000         1         0         2
         9       18.000000         2         0         2
        10       17.000000         1         1         2
        11       20.000000         1         2         2
        12       19.000000         1         0         3

vector_constrained_next4_test
  Normal end of execution.

vector_constrained_next5_test
  Python version: 3.6.9
  vector_constrained_next5:
  Generate integer vectors X such that:
    SUM_MIN <= sum ( X(1:N) ) <= SUM_max,
  We require every X(I) to be at least 1.

  N =       3
  SUM_MIN = 5
  SUM_max = 7

         #        X(1)      X(2)      X(3)

         1:         3         1         1
         2:         2         2         1
         3:         2         1         2
         4:         1         3         1
         5:         1         2         2
         6:         1         1         3
         7:         4         1         1
         8:         3         2         1
         9:         3         1         2
        10:         2         3         1
        11:         2         2         2
        12:         2         1         3
        13:         1         4         1
        14:         1         3         2
        15:         1         2         3
        16:         1         1         4
        17:         5         1         1
        18:         4         2         1
        19:         4         1         2
        20:         3         3         1
        21:         3         2         2
        22:         3         1         3
        23:         2         4         1
        24:         2         3         2
        25:         2         2         3
        26:         2         1         4
        27:         1         5         1
        28:         1         4         2
        29:         1         3         3
        30:         1         2         4
        31:         1         1         5

vector_constrained_next5_test
  Normal end of execution.

vector_constrained_next6_test
  Python version: 3.6.9
  vector_constrained_next6:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_max(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    Q_MIN <= TOTAL <= Q_max

  ALPHA:        4.000000        3.000000

  Q_MIN:     16.000000
  Q_max:     20.000000
  X_MIN:   1   0
  X_max:   2   6

         1       16.000000         1         4
         2       19.000000         1         5
         3       17.000000         2         3
         4       20.000000         2         4

  ALPHA:        4.000000        3.000000        5.000000

  Q_MIN:     16.000000
  Q_max:     20.000000
  X_MIN:   1   0   1
  X_max:   2   6   4

         1       19.000000         1         0         3
         2       17.000000         1         1         2
         3       20.000000         1         2         2
         4       18.000000         1         3         1
         5       18.000000         2         0         2
         6       16.000000         2         1         1
         7       19.000000         2         2         1

vector_constrained_next6_test
  Normal end of execution.

vector_constrained_next7_test
  Python version: 3.6.9
  vector_constrained_next7:
  Consider vectors:
    0 <= X(1:N) <= X_max(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    Q_MIN <= TOTAL <= Q_max

  ALPHA:        4.000000        3.000000

  Q_MIN:     16.000000
  Q_max:     20.000000
  X_max:   2   6

         1       18.000000         0         6
         2       19.000000         1         5
         3       17.000000         2         3
         4       20.000000         2         4

  ALPHA:        4.000000        3.000000        5.000000

  Q_MIN:     16.000000
  Q_max:     20.000000
  X_max:   2   6   4

         1       20.000000         0         0         4
         2       18.000000         0         1         3
         3       19.000000         0         3         2
         4       17.000000         0         4         1
         5       20.000000         0         5         1
         6       18.000000         0         6         0
         7       19.000000         1         0         3
         8       17.000000         1         1         2
         9       20.000000         1         2         2
        10       18.000000         1         3         1
        11       19.000000         1         5         0
        12       18.000000         2         0         2
        13       19.000000         2         2         1
        14       17.000000         2         3         0
        15       20.000000         2         4         0

vector_constrained_next7_test
  Normal end of execution.

vector_next_test
  Python version: 3.6.9
  vector_next generates all vectors X such that:
  X_MIN(1:N) <= X(1:N) <= X_max(1:N)

  X_MIN:      1     4
  X( 1):      1     4
  X( 2):      2     4
  X( 3):      1     5
  X( 4):      2     5
  X( 5):      1     6
  X( 6):      2     6
  X_max:      2     6

  X_MIN:      1     4     3
  X( 1):      1     4     3
  X( 2):      2     4     3
  X( 3):      1     5     3
  X( 4):      2     5     3
  X( 5):      1     6     3
  X( 6):      2     6     3
  X( 7):      1     4     4
  X( 8):      2     4     4
  X( 9):      1     5     4
  X(10):      2     5     4
  X(11):      1     6     4
  X(12):      2     6     4
  X_max:      2     6     4

vector_next_test:
  Normal end of execution.

ytb_enum_test:
  Python version: 3.6.9
  ytb_enum counts Young tableaus.

   N       YTB(N)

   0         0
   1         1
   2         2
   3         4
   4        10
   5        26
   6        76
   7       232
   8       764
   9      2620
  10      9496

ytb_enum_test:
  Normal end of execution.

ytb_next_test
  Python version: 3.6.9
  ytb_next generates Young tableaus.

   1     4     6  
   2     5  
   3  

   1     3     6  
   2     5  
   4  

   1     2     6  
   3     5  
   4  

   1     3     6  
   2     4  
   5  

   1     2     6  
   3     4  
   5  

   1     4     5  
   2     6  
   3  

   1     3     5  
   2     6  
   4  

   1     2     5  
   3     6  
   4  

   1     3     4  
   2     6  
   5  

   1     2     4  
   3     6  
   5  

   1     2     3  
   4     6  
   5  

   1     3     5  
   2     4  
   6  

   1     2     5  
   3     4  
   6  

   1     3     4  
   2     5  
   6  

   1     2     4  
   3     5  
   6  

   1     2     3  
   4     5  
   6  

ytb_next_test:
  Normal end of execution.

ytb_print_test
  Python version: 3.6.9
  ytb_print prints a Young tableau.

  A Young tableau:
   1     2     6  
   3     4  
   5  

ytb_print_test:
  Normal end of execution.

ytb_random_test():
  Python version: 3.6.9
  ytb_random() generates a random Young tableau

   1     2     6  
   3     4  
   5  

   1     3     4  
   2     5  
   6  

   1     2     5  
   3     6  
   4  

   1     4     6  
   2     5  
   3  

   1     2     4  
   3     5  
   6  

ytb_random_test():
  Normal end of execution.

subset_test():
  Normal end of execution.
Tue Oct 19 17:15:53 2021
